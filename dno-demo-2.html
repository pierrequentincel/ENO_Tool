<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOM - Distribution Network Design</title>
    <!-- Solver Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/highs@1.8.0/build/highs.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/glpk.js@4.0.1/dist/glpk.min.js"></script>
    <!-- Leaflet.js for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --cel-red: #CB333B;
            --cel-blue: #385D7F;
            --cel-dark-blue: #2c4a5f;
            --cel-orange: #FE5000;
            --cel-green: #30B700;
            --cel-yellow: #FFD100;
            --bg-light: #F5F7FA;
            --text-dark: #2D3748;
            --sidebar-bg: #4A6883;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-light);
            color: var(--text-dark);
        }
        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background-color: var(--sidebar-bg);
            color: white;
            padding: 30px 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .logo-section {
            text-align: center;
            margin-bottom: 30px;
        }
        .logo-section img {
            width: 200px;
            margin-bottom: 20px;
        }
        .company-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .project-name {
            font-size: 14px;
            opacity: 0.9;
            border-top: 2px solid rgba(255,255,255,0.3);
            padding-top: 15px;
            margin-top: 15px;
        }

        .sidebar-section {
            margin-bottom: 30px;
        }
        .sidebar-section h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .scenario-select, .unit-select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background-color: white;
            color: var(--text-dark);
            font-size: 14px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .sidebar-button {
            background-color: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .sidebar-button:hover {
            background-color: rgba(255,255,255,0.3);
        }
        .sidebar-button.primary {
            background-color: var(--cel-blue);
            border-color: var(--cel-blue);
        }
        .sidebar-button.primary:hover {
            background-color: var(--cel-dark-blue);
        }

        /* Main Content */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background-color: white;
            border-bottom: 2px solid #e2e8f0;
        }
        .tab {
            padding: 15px 30px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #64748b;
        }
        .tab.active {
            color: var(--cel-blue);
            border-bottom-color: var(--cel-blue);
        }
        .tab:hover {
            background-color: #f8fafc;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Key Metrics */
        .section-title {
            font-size: 28px;
            font-weight: 600;
            color: var(--cel-blue);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--cel-blue);
        }
        .scenario-label {
            font-size: 18px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 20px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 40px;
        }
        .metric-card {
            background: white;
            padding: 15px 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 110px;
        }
        .metric-label {
            font-size: 11px;
            color: #64748b;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .metric-sublabel {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 8px;
            min-height: 12px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--cel-blue);
        }
        .metric-tag {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 12px;
            background-color: #e2e8f0;
            color: #64748b;
            font-size: 11px;
            border-radius: 12px;
        }

        /* Cost Breakdown */
        .cost-breakdown {
            margin-top: 40px;
        }
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        .chart-wrapper {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 20px;
        }

        /* Map Container */
        #map-container, #map-container-analytics {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #map, #map-analytics {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .network-map-section {
            margin-top: 40px;
            margin-bottom: 40px;
        }

        /* Map Comparison Container */
        #map-comparison-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        #map-comparison-container.two-scenarios {
            grid-template-columns: 1fr;
        }
        .map-container-single {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .map-container-single canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .map-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(74, 104, 131, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            z-index: 5;
        }
        #tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            display: none;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
        }

        /* Settings Expander */
        .settings-expander {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        .settings-toggle {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 14px;
            font-weight: 600;
        }
        .settings-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .settings-content.expanded {
            max-height: 800px;
        }
        .parameter-input {
            margin-bottom: 15px;
        }
        .parameter-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            opacity: 0.9;
        }
        .parameter-input input {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
        }
        .dc-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .dc-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .dc-checkbox input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="logo-section">
                <img src="pictures/ATOM_logo.png" alt="ATOM Logo">
                <div class="company-name">Acme Milk Corporate (AMC)</div>
                <div class="project-name">Distribution Network Design</div>
            </div>

            <button class="sidebar-button primary">
                ‚ÑπÔ∏è Scenario Comparison
            </button>

            <div class="sidebar-section">
                <h3>Scenario Selection</h3>
                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px;">First Scenario:</label>
                <select class="scenario-select" id="scenario-select-1">
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>

                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px; margin-top: 15px;">Second Scenario:</label>
                <select class="scenario-select" id="scenario-select-2">
                    <option value="">Choose an option</option>
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>

                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px; margin-top: 15px;">Third Scenario:</label>
                <select class="scenario-select" id="scenario-select-3">
                    <option value="">Choose an option</option>
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>
            </div>

            <div class="sidebar-section">
                <h3>Unit Selection</h3>
                <select class="unit-select" id="unit-select">
                    <option value="usd">US Dollar (USD)</option>
                    <option value="eur">Euro (EUR)</option>
                </select>
            </div>

            <button class="sidebar-button" id="run-optimization">
                üîÑ Run Optimization
            </button>
            <button class="sidebar-button" id="save-scenario">
                üíæ Save Scenario
            </button>

            <div class="settings-expander">
                <div class="settings-toggle" id="settings-toggle">
                    <span>‚öôÔ∏è Advanced Settings</span>
                    <span id="toggle-icon">‚ñº</span>
                </div>
                <div class="settings-content" id="settings-content">
                    <div class="sidebar-section">
                        <h3>Parameters</h3>
                        <div class="parameter-input">
                            <label>First Mile Rate ($/pallet/1,000km):</label>
                            <input type="number" id="first-mile-rate" value="5.60" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>Last Mile Rate ($/pallet/1,000km):</label>
                            <input type="number" id="last-mile-rate" value="9.60" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>Storage Rate ($/pallet/month):</label>
                            <input type="number" id="storage-rate" value="0.30" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>DIO (days):</label>
                            <input type="number" id="dio" value="30">
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <h3>DC Selection</h3>
                        <div class="dc-list" id="dc-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <div class="tabs">
                <div class="tab active" data-tab="new-scenario">New Scenario</div>
                <div class="tab" data-tab="analytics">Analytics</div>
            </div>

            <div class="content-area">
                <!-- Analytics Tab -->
                <div class="tab-content" id="analytics-tab">
                    <h2 class="section-title">Key Metrics</h2>

                    <!-- Scenario 1 -->
                    <div class="scenario-label" id="scenario-label-1">0,5_Baseline_2028</div>
                    <div class="metrics-grid" id="metrics-grid-1">
                        <!-- Metrics will be populated by JavaScript -->
                    </div>

                    <!-- Scenario 2 (hidden by default) -->
                    <div id="scenario-2-section" style="display: none;">
                        <div class="scenario-label" id="scenario-label-2">Scenario 2</div>
                        <div class="metrics-grid" id="metrics-grid-2">
                            <!-- Metrics will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="network-map-section">
                        <h2 class="section-title">Network Map</h2>
                        <div id="map-comparison-container">
                            <!-- Scenario 1 Map -->
                            <div id="map-container-analytics-1" class="map-container-single">
                                <div class="map-label">Scenario 1</div>
                                <div id="map-analytics-1" style="width: 100%; height: 500px; z-index: 1;"></div>
                            </div>

                            <!-- Scenario 2 Map (hidden by default) -->
                            <div id="map-container-analytics-2" class="map-container-single" style="display: none;">
                                <div class="map-label">Scenario 2</div>
                                <div id="map-analytics-2" style="width: 100%; height: 500px; z-index: 1;"></div>
                            </div>
                        </div>
                    </div>

                    <div class="cost-breakdown">
                        <h2 class="section-title">Cost Breakdown</h2>
                        <div class="charts-container">
                            <div class="chart-wrapper">
                                <div class="chart-title">Absolute Logistics Cost Breakdown</div>
                                <canvas id="absolute-chart" width="400" height="300"></canvas>
                            </div>
                            <div class="chart-wrapper">
                                <div class="chart-title">Relative Logistics Cost Breakdown</div>
                                <canvas id="relative-chart" width="400" height="300"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- New Scenario Tab -->
                <div class="tab-content active" id="new-scenario-tab">
                    <h2 class="section-title">New Scenario</h2>

                    <!-- Reference Scenario Section - inline layout -->
                    <div style="margin-bottom: 20px; display: flex; align-items: center; gap: 15px;">
                        <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Reference Scenario</h3>
                        <select id="reference-scenario-select" style="width: 250px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                            <option value="">Select a scenario...</option>
                            <option value="baseline">0,5_Baseline_2028</option>
                        </select>
                    </div>
                    <div id="reference-scenario-display" style="display: none; margin-bottom: 20px;">
                        <div class="metrics-grid" id="reference-metrics"></div>
                        <div style="margin-top: 20px;">
                            <div id="reference-map" style="width: 100%; height: 400px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                        </div>
                        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;" id="reference-parameters"></div>
                    </div>

                    <!-- New Scenario Creator -->
                    <div style="background: white; padding: 20px 25px 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); min-height: 850px;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Create New Scenario</h3>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #64748b;">
                                <span>Preload:</span>
                                <select id="preload-scenario-select" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                    <option value="">None</option>
                                    <option value="baseline">0,5_Baseline_2028</option>
                                </select>
                            </label>
                            <button id="reset-to-preloaded" style="display: none; padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset</button>
                        </div>

                        <!-- Full width map -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 10px;">Network Preview</h4>
                            <div id="new-scenario-map" style="width: 100%; height: 450px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                            <div style="margin-top: 10px; display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; gap: 10px;">
                                    <button id="add-dc-btn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üìç Add DC</button>
                                    <button id="remove-dc-btn" style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üóëÔ∏è Remove DC</button>
                                </div>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #64748b;">
                                    <input type="checkbox" id="show-volume-circles" checked>
                                    <span>Show DC volume circles</span>
                                </label>
                            </div>
                            <div id="dc-mode-hint" style="display: none; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 12px; margin-top: 10px;"></div>
                        </div>

                        <!-- Parameters (left) and DC Selection (right) below map -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                            <!-- Left: Parameters -->
                            <div>
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">Parameters</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">First Mile Rate ($/pallet/1,000km)</label>
                                        <input type="number" id="new-first-mile-rate" value="5.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">Last Mile Rate ($/pallet/1,000km)</label>
                                        <input type="number" id="new-last-mile-rate" value="9.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">Storage Rate ($/pallet/month)</label>
                                        <input type="number" id="new-storage-rate" value="0.30" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">DIO (days)</label>
                                        <input type="number" id="new-dio" value="30" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                </div>
                            </div>

                            <!-- Right: DC Selection -->
                            <div>
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">DC Selection</h4>
                                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <button id="select-all-dcs" style="flex: 1; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Select All</button>
                                    <button id="clear-all-dcs" style="flex: 1; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear All</button>
                                </div>
                                <div id="new-dc-list" style="max-height: 180px; overflow-y: auto;"></div>
                            </div>
                        </div>

                        <div style="margin-top: 25px; display: flex; gap: 15px; align-items: center;">
                            <div style="display: inline-flex; position: relative;">
                                <button id="run-new-optimization" style="padding: 12px 24px; background: var(--cel-blue); color: white; border: none; border-radius: 4px 0 0 4px; font-weight: 600; cursor: pointer; font-size: 14px;">Run Optimization (Heuristic)</button>
                                <button id="run-new-optimization-dropdown" style="padding: 12px 12px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 0 4px 4px 0; cursor: pointer; border-left: 1px solid rgba(255,255,255,0.3);">‚ñº</button>
                                <div id="solver-dropdown-menu" style="display: none; position: absolute; bottom: 100%; left: 0; background: white; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 -4px 12px rgba(0,0,0,0.15); z-index: 100; min-width: 220px; margin-bottom: 2px;">
                                    <div class="solver-option" data-solver="heuristic" style="padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #eee;">
                                        <strong style="display: block; color: var(--text-dark);">Heuristic</strong>
                                        <small style="color: #64748b;">Fast local search (~1-10ms)</small>
                                    </div>
                                    <div class="solver-option" data-solver="highs" style="padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #eee;">
                                        <strong style="display: block; color: var(--text-dark);">HiGHS</strong>
                                        <small style="color: #64748b;">MIP solver - optimal solutions</small>
                                    </div>
                                    <div class="solver-option" data-solver="glpk" style="padding: 10px 15px; cursor: pointer;">
                                        <strong style="display: block; color: var(--text-dark);">GLPK</strong>
                                        <small style="color: #64748b;">GNU MIP solver - optimal solutions</small>
                                    </div>
                                </div>
                            </div>
                            <span id="new-scenario-solver-label" style="display: none;"></span>
                            <button id="save-new-scenario" style="padding: 12px 24px; background: var(--cel-green); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Save Scenario</button>
                        </div>
                    </div>

                    <!-- Scenario Feed (dynamically populated) -->
                    <div id="scenario-feed" style="margin-top: 40px;"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                tab.classList.add('active');
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(tabName + '-tab').classList.add('active');

                // Redraw maps when switching tabs
                if (tabName === 'new-scenario') {
                    setTimeout(() => {
                        if (mapNewScenario) {
                            mapNewScenario.invalidateSize();
                            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                        }
                    }, 100);
                } else if (tabName === 'analytics') {
                    setTimeout(() => {
                        if (mapAnalytics1) {
                            mapAnalytics1.invalidateSize();
                            renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                        }
                        if (mapAnalytics2 && scenario2) {
                            mapAnalytics2.invalidateSize();
                            renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
                        }
                    }, 100);
                }
            });
        });

        // Settings toggle
        document.getElementById('settings-toggle').addEventListener('click', () => {
            const content = document.getElementById('settings-content');
            const icon = document.getElementById('toggle-icon');
            content.classList.toggle('expanded');
            icon.textContent = content.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
        });

        // JavaScript code here
        // ===== LEAFLET MAP INFRASTRUCTURE =====

        // Indonesia map center and bounds
        const INDONESIA_CENTER = [-2.5, 106.0];
        const INDONESIA_ZOOM = 5;

        // Map instances
        let mapAnalytics1 = null;
        let mapAnalytics2 = null;
        let mapNewScenario = null;
        let mapReference = null;

        // Marker layer groups (for easy clearing/updating)
        let markersAnalytics1 = null;
        let markersAnalytics2 = null;
        let markersNewScenario = null;
        let markersReference = null;

        // Add/Remove DC mode
        let addDCMode = false;
        let removeDCMode = false;

        // Volume circle visibility
        let showVolumeCircles = true;

        // Custom icons
        const factoryIcon = L.divIcon({
            className: 'factory-icon',
            html: '<div style="background: #CB333B; color: white; width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">F</div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12]
        });

        function createDCIcon(dc, throughput = 0, isActive = true, showVolume = true) {
            // If showVolume is true, size varies by throughput; otherwise fixed size
            const size = isActive
                ? (showVolume ? Math.max(20, Math.min(40, Math.sqrt(throughput) / 8)) : 20)
                : 16;
            const bgColor = isActive ? '#385D7F' : '#999';
            const border = isActive ? '2px solid white' : '2px dashed #666';
            return L.divIcon({
                className: 'dc-icon',
                html: `<div style="background: ${bgColor}; color: white; width: ${size}px; height: ${size}px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; border: ${border}; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${dc.id.replace('DC','')}</div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // Initialize a Leaflet map
        function initLeafletMap(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return null;

            // Check if map already exists
            if (container._leaflet_id) {
                return null; // Already initialized
            }

            const map = L.map(containerId, {
                center: INDONESIA_CENTER,
                zoom: INDONESIA_ZOOM,
                zoomControl: true
            });

            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap ¬© CARTO',
                maxZoom: 18
            }).addTo(map);

            return map;
        }

        // Initialize all maps (called after DOM ready)
        function initAllMaps() {
            // Analytics maps
            mapAnalytics1 = initLeafletMap('map-analytics-1');
            if (mapAnalytics1) {
                markersAnalytics1 = L.layerGroup().addTo(mapAnalytics1);
            }

            mapAnalytics2 = initLeafletMap('map-analytics-2');
            if (mapAnalytics2) {
                markersAnalytics2 = L.layerGroup().addTo(mapAnalytics2);
            }

            // New Scenario map (main interactive map)
            mapNewScenario = initLeafletMap('new-scenario-map');
            if (mapNewScenario) {
                markersNewScenario = L.layerGroup().addTo(mapNewScenario);
                // Ensure scroll wheel zoom is always enabled
                mapNewScenario.scrollWheelZoom.enable();

                // Click to add DC
                mapNewScenario.on('click', function(e) {
                    if (addDCMode) {
                        const newId = 'DC' + (dcLocations.length + 1);
                        const newDC = {
                            id: newId,
                            name: 'New DC ' + (dcLocations.length + 1),
                            lat: e.latlng.lat,
                            lng: e.latlng.lng,
                            active: true
                        };
                        dcLocations.push(newDC);
                        newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
                        updateNewScenarioDCList();
                        // Re-assign demand points to nearest DCs after adding new DC
                        assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                        addDCMode = false;
                        document.getElementById('add-dc-btn').classList.remove('active');
                        document.getElementById('add-dc-btn').style.background = '#007bff';
                        document.getElementById('dc-mode-hint').style.display = 'none';
                    }
                });
            }

            // Reference map
            mapReference = initLeafletMap('reference-map');
            if (mapReference) {
                markersReference = L.layerGroup().addTo(mapReference);
            }
        }

        // Render markers on a map
        function renderMapMarkers(map, markersLayer, dcs, demands, interactive = false) {
            if (!map || !markersLayer) return;

            markersLayer.clearLayers();

            // Add factory marker
            const factoryMarker = L.marker([factory.lat, factory.lng], {icon: factoryIcon})
                .bindPopup(`<b>${factory.name || 'Factory'}</b><br>Main production facility`);
            markersLayer.addLayer(factoryMarker);

            // Add DC markers (size varies by throughput when showVolumeCircles is on)
            dcs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);

                const icon = createDCIcon(dc, throughput, dc.active, showVolumeCircles);
                const marker = L.marker([dc.lat, dc.lng], {icon: icon});

                // Popup content with action buttons for interactive maps
                const popupId = `dc-popup-${dc.id}`;
                const popupContent = `
                    <div id="${popupId}">
                        <b>${dc.name}</b><br>
                        Status: ${dc.active ? 'Active' : 'Inactive'}<br>
                        Throughput: ${throughput.toLocaleString()} pallets
                        ${interactive ? `
                            <div style="margin-top: 10px; display: flex; gap: 8px;">
                                <button onclick="window.toggleDCFromPopup('${dc.id}')" style="padding: 4px 10px; background: ${dc.active ? '#ffc107' : '#28a745'}; color: ${dc.active ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    ${dc.active ? 'Deactivate' : 'Activate'}
                                </button>
                                <button onclick="window.deleteDCFromPopup('${dc.id}')" style="padding: 4px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
                marker.bindPopup(popupContent);

                markersLayer.addLayer(marker);
            });

            // Add demand points as small circle markers (always visible)
            demands.forEach(point => {
                const color = point.assignedDC ? '#385D7F' : '#999';
                const circle = L.circleMarker([point.lat, point.lng], {
                    radius: 4,
                    fillColor: color,
                    color: color,
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.6
                });
                circle.bindPopup(`Demand: ${point.demand.toLocaleString()} pallets<br>Cluster: ${point.cluster}`);
                markersLayer.addLayer(circle);
            });

            // Draw flow lines (first mile and last mile)
            const activeDCs = dcs.filter(dc => dc.active);

            // First mile lines (factory to DCs) - clickable with popup
            activeDCs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                if (throughput > 0) {
                    const line = L.polyline([[factory.lat, factory.lng], [dc.lat, dc.lng]], {
                        color: '#385D7F',
                        weight: 3,
                        opacity: 0.6
                    });
                    line.bindPopup(`
                        <b>First Mile</b><br>
                        <b>Origin:</b> ${factory.name}<br>
                        <b>Destination:</b> ${dc.name}<br>
                        <b>Volume:</b> ${throughput.toLocaleString()} pallets/month
                    `);
                    markersLayer.addLayer(line);
                }
            });

            // Last mile lines (DCs to demand points) - clickable with popup
            demands.forEach(point => {
                let assignedDC = point.assignedDC;
                if (!assignedDC || !dcs.includes(assignedDC)) {
                    assignedDC = dcs.find(dc => dc.id === point.assignedDCId);
                }
                if (assignedDC && assignedDC.active) {
                    const line = L.polyline([[assignedDC.lat, assignedDC.lng], [point.lat, point.lng]], {
                        color: '#FE5000',
                        weight: 2,
                        opacity: 0.4
                    });
                    line.bindPopup(`
                        <b>Last Mile</b><br>
                        <b>Origin:</b> ${assignedDC.name}<br>
                        <b>Destination:</b> Cluster ${point.cluster}<br>
                        <b>Volume:</b> ${point.demand.toLocaleString()} pallets/month
                    `);
                    markersLayer.addLayer(line);
                }
            });
        }

        // Legacy function names for compatibility
        // Draw map using Leaflet
        function drawMap() {
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (scenario2 && mapAnalytics2 && markersAnalytics2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        }

        // Initialize maps when DOM is ready
        setTimeout(initAllMaps, 100);

        // Data structures - Indonesia coordinates (lat/lng)
        let demandPoints = [];
        let dcLocations = [
            {id: 'DC1', name: 'Medan Hub', lat: 3.5952, lng: 98.6722, active: true},
            {id: 'DC2', name: 'Pekanbaru Hub', lat: 0.5071, lng: 101.4478, active: false},
            {id: 'DC3', name: 'Palembang Hub', lat: -2.9761, lng: 104.7754, active: true},
            {id: 'DC4', name: 'Lampung Hub', lat: -5.4294, lng: 105.2610, active: false},
            {id: 'DC5', name: 'Jakarta Hub', lat: -6.2088, lng: 106.8456, active: true},
            {id: 'DC6', name: 'Bandung Hub', lat: -6.9175, lng: 107.6191, active: false},
            {id: 'DC7', name: 'Semarang Hub', lat: -6.9666, lng: 110.4196, active: true},
            {id: 'DC8', name: 'Yogyakarta Hub', lat: -7.7956, lng: 110.3695, active: false},
            {id: 'DC9', name: 'Surabaya Hub', lat: -7.2575, lng: 112.7521, active: true},
            {id: 'DC10', name: 'Malang Hub', lat: -7.9666, lng: 112.6326, active: false},
            {id: 'DC11', name: 'Padang Hub', lat: -0.9471, lng: 100.4172, active: false},
            {id: 'DC12', name: 'Jambi Hub', lat: -1.6101, lng: 103.6131, active: false}
        ];
        const factory = {lat: -6.1897, lng: 106.5108, name: 'Factory (Jatake, Tangerang)'};

        // Scenario storage
        let scenario1 = {
            demandPoints: [],
            dcLocations: JSON.parse(JSON.stringify(dcLocations)),
            name: '0,5_Baseline_2028'
        };
        let scenario2 = null;

        // Seeded random number generator for consistent demand generation
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        // Generate demand points - Indonesia coordinates
        // Target: ~350k pallets/month (50x scale for realistic unit costs)
        function generateDemandPoints() {
            demandPoints = [];
            const random = seededRandom(12345); // Fixed seed for consistent results
            // Clusters around major Indonesian cities
            const clusters = [
                // Cluster A: Greater Jakarta area (West Java)
                {center: {lat: -6.2088, lng: 106.8456}, spread: 0.5, count: 25, demandRange: [1600, 4500], id: 'A'},
                // Cluster B: Surabaya / East Java
                {center: {lat: -7.2575, lng: 112.7521}, spread: 0.6, count: 20, demandRange: [3650, 7700], id: 'B'},
                // Cluster C: Bandung / West Java
                {center: {lat: -6.9175, lng: 107.6191}, spread: 0.4, count: 20, demandRange: [1600, 3650], id: 'C'},
                // Cluster D: Medan / North Sumatra
                {center: {lat: 3.5952, lng: 98.6722}, spread: 0.5, count: 15, demandRange: [2000, 4650], id: 'D'},
                // Cluster E: Semarang / Central Java
                {center: {lat: -6.9666, lng: 110.4196}, spread: 0.4, count: 12, demandRange: [2650, 6300], id: 'E'}
            ];
            clusters.forEach(cluster => {
                for (let i = 0; i < cluster.count; i++) {
                    const lat = cluster.center.lat + (random() - 0.5) * cluster.spread;
                    const lng = cluster.center.lng + (random() - 0.5) * cluster.spread;
                    const demand = Math.floor(random() * (cluster.demandRange[1] - cluster.demandRange[0]) + cluster.demandRange[0]);
                    demandPoints.push({lat, lng, demand, cluster: cluster.id, assignedDC: null, distance: 0});
                }
            });
            // Scattered points across Sumatra and Java
            const scatteredAreas = [
                {latMin: -8, latMax: -6, lngMin: 105, lngMax: 114}, // Java
                {latMin: -3, latMax: 4, lngMin: 98, lngMax: 105}    // Sumatra
            ];
            for (let i = 0; i < 12; i++) {
                const area = scatteredAreas[i < 8 ? 0 : 1]; // More in Java
                const lat = area.latMin + random() * (area.latMax - area.latMin);
                const lng = area.lngMin + random() * (area.lngMax - area.lngMin);
                const demand = Math.floor(random() * 1600 + 800);
                demandPoints.push({lat, lng, demand, cluster: 'scattered', assignedDC: null, distance: 0});
            }
        }

        // Distance calculation - Haversine formula for lat/lng
        function distance(p1, p2) {
            const R = 6371; // Earth radius in km
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLng = (p2.lng - p1.lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            let dist = R * c; // Distance in km

            // Sea crossing penalty: Sumatra (lng < 106) to Java (lng > 106) via Sunda Strait
            const crossesSea = (p1.lng < 106 && p2.lng > 106) || (p1.lng > 106 && p2.lng < 106);
            if (crossesSea) dist *= 1.3; // 30% penalty for sea crossing

            return dist;
        }

        // Assign customers to DCs
        function assignCustomers() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            demandPoints.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) { // Assign to nearest DC regardless of distance to fulfill all demand
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null; // Store DC ID for cloning
                point.distance = minDist;
            });
        }

        // Assign customers to DCs (for scenario data with separate DC arrays)
        function assignCustomersToScenario(demands, dcs) {
            const activeDCs = dcs.filter(dc => dc.active);
            demands.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null;
                point.distance = minDist;
            });
        }

        // Calculate costs
        function calculateCosts() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value) / 1000;
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value) / 1000;
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            // First mile
            activeDCs.forEach(dc => {
                const dist = distance(factory, dc);
                if (dist > 4000) return; // SLA violation, but for now ignore
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate;
            });

            // Last mile and storage
            activeDCs.forEach(dc => {
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                const avgInventory = throughput * (dio / 365);
                totalStorage += avgInventory * storageRate * 12;
                demandPoints.filter(p => p.assignedDC === dc).forEach(p => {
                    totalTransport += p.distance * p.demand * lastMileRate;
                });
            });

            return {total: totalTransport + totalStorage, transport: totalTransport, storage: totalStorage, activeDCs: activeDCs.length};
        }

        // Draw map using Leaflet
        function drawMap() {
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (scenario2 && mapAnalytics2 && markersAnalytics2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        }

        // Note: Tooltips are now handled by Leaflet popups on markers

        // Optimization function
        function optimize() {
            // Heuristic optimization
            // Step 1: Activate all feasible DCs (distance from factory <= 4000 km)
            dcLocations.forEach(dc => {
                dc.active = distance(factory, dc) <= 4000;
            });
            assignCustomers();
            
            // Step 2: Local search - try closing DCs that don't reduce total cost
            let improved = true;
            let iterations = 0;
            while (improved && iterations < 10) { // Limit iterations
                improved = false;
                iterations++;
                const currentCosts = calculateCosts();
                for (let i = 0; i < dcLocations.length; i++) {
                    if (!dcLocations[i].active) continue;
                    // Try closing this DC
                    dcLocations[i].active = false;
                    assignCustomers();
                    const trialCosts = calculateCosts();
                    if (trialCosts.total < currentCosts.total) {
                        // Keep closed
                        improved = true;
                        break; // Accept first improvement
                    } else {
                        // Reopen
                        dcLocations[i].active = true;
                    }
                }
            }
            assignCustomers();
        }

        // ===== MIP SOLVER IMPLEMENTATIONS =====

        // Global solver instances (initialized lazily)
        let highsInstance = null;
        let glpkInstance = null;

        // Initialize HiGHS solver
        async function initHiGHS() {
            if (highsInstance) return highsInstance;
            try {
                // HiGHS from CDN exposes a global 'highs' factory function
                if (typeof highs === 'undefined') {
                    throw new Error('HiGHS library not loaded');
                }
                highsInstance = await highs({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/highs@1.8.0/build/${file}`
                });
                console.log('HiGHS initialized successfully');
                return highsInstance;
            } catch (e) {
                console.error('Failed to initialize HiGHS:', e);
                throw e;
            }
        }

        // Initialize GLPK solver
        async function initGLPK() {
            if (glpkInstance) return glpkInstance;
            try {
                if (typeof GLPK === 'undefined') {
                    throw new Error('GLPK library not loaded');
                }
                glpkInstance = await GLPK();
                console.log('GLPK initialized successfully');
                return glpkInstance;
            } catch (e) {
                console.error('Failed to initialize GLPK:', e);
                throw e;
            }
        }

        // Optimized greedy solver (better than simple heuristic, faster than MIP)
        function optimizeGreedy(targetDCs, targetDemands, params) {
            const { firstMileRate, lastMileRate, storageRate, dio } = params;

            // Calculate cost for a given DC configuration
            function calcTotalCost() {
                const activeDCs = targetDCs.filter(dc => dc.active);
                if (activeDCs.length === 0) return Infinity;

                let total = 0;
                targetDemands.forEach(point => {
                    let minDist = Infinity;
                    let bestDC = null;
                    activeDCs.forEach(dc => {
                        const dist = distance(point, dc);
                        if (dist < minDist) {
                            minDist = dist;
                            bestDC = dc;
                        }
                    });
                    if (bestDC) {
                        // Last mile cost
                        total += minDist * point.demand * lastMileRate / 1000 * 12;
                        point.assignedDC = bestDC;
                        point.distance = minDist;
                    }
                });

                // First mile and storage costs
                activeDCs.forEach(dc => {
                    const throughput = targetDemands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                    const distFromFactory = distance(factory, dc);
                    total += distFromFactory * throughput * firstMileRate / 1000 * 12;
                    total += throughput * (dio / 365) * storageRate * 12;
                });

                return total;
            }

            // Start with all DCs active
            targetDCs.forEach(dc => dc.active = true);
            let bestCost = calcTotalCost();

            // Greedy removal - keep removing DCs while cost improves
            let improved = true;
            while (improved) {
                improved = false;
                let bestRemoval = -1;
                let bestNewCost = bestCost;

                for (let i = 0; i < targetDCs.length; i++) {
                    if (!targetDCs[i].active) continue;

                    targetDCs[i].active = false;
                    const newCost = calcTotalCost();

                    if (newCost < bestNewCost) {
                        bestNewCost = newCost;
                        bestRemoval = i;
                    }

                    targetDCs[i].active = true;
                }

                if (bestRemoval >= 0) {
                    targetDCs[bestRemoval].active = false;
                    bestCost = bestNewCost;
                    improved = true;
                }
            }

            // Final assignment
            calcTotalCost();
        }

        // HiGHS optimization
        async function optimizeWithHiGHS(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value);
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value);
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            try {
                const solver = await initHiGHS();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate assignment costs for each customer to each DC
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const firstMileDist = distance(factory, dc);

                        const unitCost = (lastMileDist * lastMileRate / 1000 +
                                         firstMileDist * firstMileRate / 1000 +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build LP string
                let lp = 'Minimize\n obj:';
                const terms = [];

                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        terms.push(` ${costs[c][d].toFixed(2)} x${c}_${d}`);
                    }
                }
                lp += terms.join(' +') + '\n';

                lp += 'Subject To\n';

                // Each customer assigned to exactly one DC
                for (let c = 0; c < numCustomers; c++) {
                    const assignTerms = [];
                    for (let d = 0; d < numDCs; d++) {
                        assignTerms.push(`x${c}_${d}`);
                    }
                    lp += ` c${c}: ${assignTerms.join(' + ')} = 1\n`;
                }

                // Linking: x[c,d] <= y[d]
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` l${c}_${d}: x${c}_${d} - y${d} <= 0\n`;
                    }
                }

                lp += 'Binary\n';
                for (let d = 0; d < numDCs; d++) {
                    lp += ` y${d}\n`;
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` x${c}_${d}\n`;
                    }
                }
                lp += 'End\n';

                console.log('Solving with HiGHS...');
                const result = solver.solve(lp);
                console.log('HiGHS result:', result);

                if (result.Status === 'Optimal') {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.Columns[`y${d}`]?.Primal || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.ObjectiveValue };
                } else {
                    throw new Error('HiGHS status: ' + result.Status);
                }
            } catch (e) {
                console.error('HiGHS failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const params = { firstMileRate, lastMileRate, storageRate, dio };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // GLPK optimization
        async function optimizeWithGLPK(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value);
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value);
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            try {
                const glpk = await initGLPK();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate costs
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const firstMileDist = distance(factory, dc);

                        const unitCost = (lastMileDist * lastMileRate / 1000 +
                                         firstMileDist * firstMileRate / 1000 +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build objective
                const objective = [];
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        objective.push({ name: `x${c}_${d}`, coef: costs[c][d] });
                    }
                }

                // Build constraints
                const subjectTo = [];

                // Assignment constraints
                for (let c = 0; c < numCustomers; c++) {
                    const vars = [];
                    for (let d = 0; d < numDCs; d++) {
                        vars.push({ name: `x${c}_${d}`, coef: 1 });
                    }
                    subjectTo.push({
                        name: `assign${c}`,
                        vars: vars,
                        bnds: { type: glpk.GLP_FX, lb: 1, ub: 1 }
                    });
                }

                // Linking constraints
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        subjectTo.push({
                            name: `link${c}_${d}`,
                            vars: [
                                { name: `x${c}_${d}`, coef: 1 },
                                { name: `y${d}`, coef: -1 }
                            ],
                            bnds: { type: glpk.GLP_UP, lb: 0, ub: 0 }
                        });
                    }
                }

                // Binary variables list
                const binaries = [];
                for (let d = 0; d < numDCs; d++) {
                    binaries.push(`y${d}`);
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        binaries.push(`x${c}_${d}`);
                    }
                }

                const model = {
                    name: 'FacilityLocation',
                    objective: {
                        direction: glpk.GLP_MIN,
                        name: 'cost',
                        vars: objective
                    },
                    subjectTo: subjectTo,
                    binaries: binaries
                };

                console.log('Solving with GLPK...');
                const result = await glpk.solve(model, { msglev: glpk.GLP_MSG_OFF });
                console.log('GLPK result:', result);

                if (result.result.status === glpk.GLP_OPT) {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.result.vars[`y${d}`] || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.result.z };
                } else {
                    throw new Error('GLPK status: ' + result.result.status);
                }
            } catch (e) {
                console.error('GLPK failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const params = { firstMileRate, lastMileRate, storageRate, dio };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // Unified optimization function that uses selected solver
        async function runOptimization(solver = 'heuristic') {
            const startTime = performance.now();
            let result;

            try {
                if (solver === 'heuristic') {
                    optimize();
                    result = { success: true };
                } else if (solver === 'highs') {
                    result = await optimizeWithHiGHS();
                } else if (solver === 'glpk') {
                    result = await optimizeWithGLPK();
                }
            } catch (e) {
                console.error('Optimization error:', e);
                alert('Optimization failed: ' + e.message);
                result = { success: false };
            }

            const endTime = performance.now();
            const solveTime = Math.round(endTime - startTime);

            return { ...result, solveTime, solver };
        }

        // Update results
        let comparisonScenario = null;

        // Helper function to generate metrics HTML
        function generateMetricsHTML(dcs, demands, scenarioName) {
            // Calculate costs for this scenario
            const activeDCs = dcs.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value) / 1000;
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value) / 1000;
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            // First mile
            activeDCs.forEach(dc => {
                const dist = distance(factory, dc);
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate * 12;
            });

            // Last mile & storage
            demands.forEach(point => {
                if (point.assignedDC || point.assignedDCId) {
                    totalTransport += point.distance * point.demand * lastMileRate * 12;
                }
            });

            activeDCs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                totalStorage += throughput * (dio / 365) * storageRate * 12;
            });

            const costs = {
                total: totalTransport + totalStorage,
                transport: totalTransport,
                storage: totalStorage,
                activeDCs: activeDCs.length
            };

            // Calculate total demand (monthly)
            const totalDemand = demands.reduce((sum, p) => sum + p.demand, 0);

            // FMCG Product Structure:
            // 1 pallet = 60 cartons √ó 50 pieces = 3,000 pieces
            // NSV per piece = $0.10
            // NSV per pallet = 3,000 √ó $0.10 = $300
            const nsvPerPallet = 300;
            // NSV is annual (monthly demand √ó 12 months)
            const nsv = totalDemand * 12 * nsvPerPallet;
            const costPerNSV = costs.total / nsv;

            // Calculate unit cost to serve
            const unitCostToServe = costs.total / totalDemand;

            // Calculate lead time as simple average of lead time to all customers (distance / 500 km/day)
            const avgLeadTime = demands.reduce((sum, p) => sum + ((p.distance || 0) / 500), 0) / demands.length;

            // Calculate total stock: sum for each DC of (DIO * annual output quantity)/365
            // Annual output = monthly demand * 12
            let totalStock = 0;
            activeDCs.forEach(dc => {
                const monthlyThroughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const annualThroughput = monthlyThroughput * 12;
                totalStock += (dio * annualThroughput) / 365;
            });

            // Calculate DIO - should equal the input DIO parameter
            const calculatedDIO = dio;

            // Calculate IOC: average inventory value * WACC (10%)
            // Average inventory value = total stock (pallets) * NSV per pallet
            const avgInventoryValue = totalStock * nsvPerPallet;
            const ioc = avgInventoryValue * 0.10;

            return `
                <div class="metric-card">
                    <div class="metric-label">Number DCs</div>
                    <div class="metric-sublabel">-</div>
                    <div class="metric-value">${costs.activeDCs}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost per NSV</div>
                    <div class="metric-sublabel">Ratio</div>
                    <div class="metric-value">${(costPerNSV * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales Value</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(nsv / 1000000).toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales</div>
                    <div class="metric-sublabel">Volume</div>
                    <div class="metric-value">${Math.round(totalDemand / 1000)}</div>
                    <div class="metric-sublabel" style="margin-top:5px">(k Pallets)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost-to-Serve</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(costs.total / 1000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Unit Cost-to-</div>
                    <div class="metric-sublabel">Serve</div>
                    <div class="metric-value">${Math.round(unitCostToServe).toLocaleString()}</div>
                    <div class="metric-sublabel" style="margin-top:5px">(USD/Pallet)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">IOC</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(ioc / 1000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">DIO</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${calculatedDIO.toFixed(0)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Lead Time</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${avgLeadTime.toFixed(2)}</div>
                </div>
            `;
        }

        function updateResults() {
            const costs = calculateCosts();

            // Update scenario 1
            document.getElementById('scenario-label-1').textContent = scenario1.name;
            document.getElementById('metrics-grid-1').innerHTML = generateMetricsHTML(
                scenario1.dcLocations,
                scenario1.demandPoints,
                scenario1.name
            );

            // Update scenario 2 if exists
            if (scenario2) {
                document.getElementById('scenario-2-section').style.display = 'block';
                document.getElementById('map-container-analytics-2').style.display = 'block';
                document.getElementById('map-comparison-container').classList.add('two-scenarios');
                document.getElementById('scenario-label-2').textContent = scenario2.name;
                document.getElementById('metrics-grid-2').innerHTML = generateMetricsHTML(
                    scenario2.dcLocations,
                    scenario2.demandPoints,
                    scenario2.name
                );

                // Invalidate Leaflet map sizes after making them visible
                setTimeout(() => {
                    if (mapAnalytics1) mapAnalytics1.invalidateSize();
                    if (mapAnalytics2) mapAnalytics2.invalidateSize();
                    // Force redraw of both maps
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }
                    if (mapAnalytics2 && markersAnalytics2) {
                        renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
                    }
                }, 50);
            } else {
                document.getElementById('scenario-2-section').style.display = 'none';
                document.getElementById('map-container-analytics-2').style.display = 'none';
                document.getElementById('map-comparison-container').classList.remove('two-scenarios');
                // Clear the second map markers
                if (markersAnalytics2) markersAnalytics2.clearLayers();
            }

            // Update charts
            updateCharts(costs);
        }

        // Draw charts
        function updateCharts(costs) {
            // Sample data for waterfall chart effect
            const firstMileCost = costs.transport * 0.52; // Estimate
            const storageCost = costs.storage;
            const lastMileCost = costs.transport * 0.48;

            // Absolute chart
            const absoluteCanvas = document.getElementById('absolute-chart');
            const absCtx = absoluteCanvas.getContext('2d');
            absCtx.clearRect(0, 0, absoluteCanvas.width, absoluteCanvas.height);

            // Draw bars for absolute cost
            const maxCost = costs.total;
            const barWidth = 80;
            const spacing = 50;
            const chartHeight = 250;
            const baseY = 270;

            // First mile
            const fm_height = (firstMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50, baseY - fm_height, barWidth, fm_height);
            absCtx.fillStyle = '#2D3748';
            absCtx.font = '14px Arial';
            absCtx.textAlign = 'center';
            absCtx.fillText(Math.round(firstMileCost / 1000) + 'M', 90, baseY - fm_height - 5);

            // Storage (stacked on first mile)
            const st_height = (storageCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + barWidth + spacing, baseY - fm_height - st_height, barWidth, fm_height + st_height);
            absCtx.fillText(Math.round((firstMileCost + storageCost) / 1000) + 'M', 90 + barWidth + spacing, baseY - fm_height - st_height - 5);

            // Last mile (stacked on storage)
            const lm_height = (lastMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight, barWidth, costs.total / maxCost * chartHeight);
            absCtx.fillText(Math.round(costs.total / 1000) + 'M', 90 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight - 5);

            // Relative chart (cost per pallet)
            const relativeCanvas = document.getElementById('relative-chart');
            const relCtx = relativeCanvas.getContext('2d');
            relCtx.clearRect(0, 0, relativeCanvas.width, relativeCanvas.height);

            const totalDemand = demandPoints.reduce((sum, p) => sum + p.demand, 0);
            const fm_per_pallet = firstMileCost / totalDemand;
            const st_per_pallet = storageCost / totalDemand;
            const lm_per_pallet = lastMileCost / totalDemand;
            const total_per_pallet = costs.total / totalDemand;

            const maxPerPallet = total_per_pallet;

            // First mile
            const fm_height_rel = (fm_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50, baseY - fm_height_rel, barWidth, fm_height_rel);
            relCtx.fillStyle = '#2D3748';
            relCtx.font = '14px Arial';
            relCtx.textAlign = 'center';
            relCtx.fillText(Math.round(fm_per_pallet), 90, baseY - fm_height_rel - 5);

            // Storage (stacked)
            const st_height_rel = (st_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + barWidth + spacing, baseY - fm_height_rel - st_height_rel, barWidth, fm_height_rel + st_height_rel);
            relCtx.fillText(Math.round(fm_per_pallet + st_per_pallet), 90 + barWidth + spacing, baseY - fm_height_rel - st_height_rel - 5);

            // Last mile (stacked)
            const total_height_rel = (total_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - total_height_rel, barWidth, total_height_rel);
            relCtx.fillText(Math.round(total_per_pallet), 90 + (barWidth + spacing) * 2, baseY - total_height_rel - 5);
        }

        // Initialize
        generateDemandPoints();
        assignCustomers();

        // Initialize scenario 1 with current state
        scenario1.demandPoints = JSON.parse(JSON.stringify(demandPoints));
        scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
        // Re-assign customers to restore object references
        assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);

        drawMap();
        updateResults();

        // Load saved scenarios into all dropdowns
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('dno-scenario-')) {
                const name = key.replace('dno-scenario-', '');
                ['scenario-select-1', 'scenario-select-2', 'scenario-select-3'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    }
                });
            }
        }

        // DC list
        const dcList = document.getElementById('dc-list');
        dcLocations.forEach(dc => {
            const div = document.createElement('div');
            div.className = 'dc-checkbox';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = dc.id;
            checkbox.checked = dc.active;
            checkbox.addEventListener('change', () => {
                dc.active = checkbox.checked;
                assignCustomers();
                drawMap();
                updateResults();
            });
            const label = document.createElement('label');
            label.htmlFor = dc.id;
            label.textContent = dc.name;
            div.appendChild(checkbox);
            div.appendChild(label);
            dcList.appendChild(div);
        });

        // Parameters
        ['first-mile-rate', 'last-mile-rate', 'storage-rate', 'dio'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                updateResults();
            });
        });

        // Solver dropdown split button handling
        let selectedSolver = 'heuristic';
        const solverNames = {
            'heuristic': 'Heuristic',
            'highs': 'HiGHS',
            'glpk': 'GLPK'
        };

        const dropdownMenu = document.getElementById('solver-dropdown-menu');
        const dropdownBtn = document.getElementById('run-new-optimization-dropdown');

        // Toggle dropdown menu
        dropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdownMenu.style.display = dropdownMenu.style.display === 'none' ? 'block' : 'none';
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener('click', () => {
            dropdownMenu.style.display = 'none';
        });

        // Handle solver selection from dropdown
        document.querySelectorAll('.solver-option').forEach(option => {
            option.addEventListener('mouseenter', () => {
                option.style.backgroundColor = '#f0f4f8';
            });
            option.addEventListener('mouseleave', () => {
                option.style.backgroundColor = 'white';
            });
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                selectedSolver = option.dataset.solver;
                document.getElementById('run-new-optimization').textContent = 'Run Optimization (' + solverNames[selectedSolver] + ')';
                dropdownMenu.style.display = 'none';
            });
        });

        // Run optimization
        document.getElementById('run-optimization').addEventListener('click', () => {
            optimize();
            // Update checkboxes
            dcLocations.forEach(dc => {
                document.getElementById(dc.id).checked = dc.active;
            });
            // Update scenario 1 with optimized state
            scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
            scenario1.demandPoints = JSON.parse(JSON.stringify(demandPoints));
            assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);

            drawMap();
            updateResults();
        });

        // Save scenario
        document.getElementById('save-scenario').addEventListener('click', () => {
            const name = prompt('Enter scenario name:');
            if (name) {
                const scenario = {
                    name,
                    dcActive: dcLocations.map(dc => dc.active),
                    parameters: {
                        firstMileRate: document.getElementById('first-mile-rate').value,
                        lastMileRate: document.getElementById('last-mile-rate').value,
                        storageRate: document.getElementById('storage-rate').value,
                        dio: document.getElementById('dio').value
                    },
                    demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));
                alert('Scenario saved!');
            }
        });

        // Helper function to load a scenario
        function loadScenario(scenarioValue, scenarioName) {
            const tempDcLocations = JSON.parse(JSON.stringify(dcLocations));
            const tempDemandPoints = JSON.parse(JSON.stringify(demandPoints));

            if (scenarioValue === 'baseline') {
                tempDcLocations.forEach((dc, i) => dc.active = [0,2,4,6,8].includes(i));
            } else {
                // Load saved scenario
                const savedScenario = JSON.parse(localStorage.getItem('dno-scenario-' + scenarioValue));
                if (savedScenario) {
                    tempDcLocations.forEach((dc, i) => dc.active = savedScenario.dcActive[i]);
                    savedScenario.demands.forEach((d, i) => {
                        if (tempDemandPoints[i]) tempDemandPoints[i].demand = d.demand;
                    });
                }
            }

            // Assign customers for temp data using the scenario-specific function
            assignCustomersToScenario(tempDemandPoints, tempDcLocations);

            return {
                demandPoints: tempDemandPoints,
                dcLocations: tempDcLocations,
                name: scenarioName
            };
        }

        // Scenario select handlers
        const select1 = document.getElementById('scenario-select-1');
        const select2 = document.getElementById('scenario-select-2');

        select1.addEventListener('change', (e) => {
            if (e.target.value === '') return;
            const scenarioName = select1.options[select1.selectedIndex].text;
            scenario1 = loadScenario(e.target.value, scenarioName);

            // Update current working state
            dcLocations = JSON.parse(JSON.stringify(scenario1.dcLocations));
            demandPoints = JSON.parse(JSON.stringify(scenario1.demandPoints));

            // Update DC checkboxes
            dcLocations.forEach(dc => {
                const checkbox = document.getElementById(dc.id);
                if (checkbox) checkbox.checked = dc.active;
            });

            drawMap();
            updateResults();
        });

        select2.addEventListener('change', (e) => {
            if (e.target.value === '') {
                scenario2 = null;
            } else {
                const scenarioName = select2.options[select2.selectedIndex].text;
                scenario2 = loadScenario(e.target.value, scenarioName);
            }

            drawMap();
            updateResults();
        });

        // ===== NEW SCENARIO TAB IMPLEMENTATION =====

        // New working state for scenario creator
        let newScenarioDCs = JSON.parse(JSON.stringify(dcLocations));
        let newScenarioDemands = JSON.parse(JSON.stringify(demandPoints));
        let scenarioFeedCounter = 0;

        // Initialize DC list for new scenario creator
        const newDCList = document.getElementById('new-dc-list');

        // Function to update the DC list UI
        function updateNewScenarioDCList() {
            reinitializeNewScenarioCheckboxes();
        }

        // Function to reinitialize DC checkboxes with current newScenarioDCs array
        function reinitializeNewScenarioCheckboxes() {
            // Clear existing checkboxes
            newDCList.innerHTML = '';

            // Create new checkboxes linked to current newScenarioDCs
            newScenarioDCs.forEach(dc => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; font-size: 13px;';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'new-' + dc.id;
                checkbox.checked = dc.active;
                checkbox.style.marginRight = '8px';
                checkbox.addEventListener('change', () => {
                    dc.active = checkbox.checked;
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                });
                const label = document.createElement('label');
                label.htmlFor = 'new-' + dc.id;
                label.textContent = dc.name;
                div.appendChild(checkbox);
                div.appendChild(label);
                newDCList.appendChild(div);
            });
        }

        // Initial checkbox setup
        reinitializeNewScenarioCheckboxes();

        // Select All button handler
        document.getElementById('select-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = true);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Clear All button handler
        document.getElementById('clear-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = false);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Add DC button handler
        document.getElementById('add-dc-btn').addEventListener('click', function() {
            addDCMode = !addDCMode;
            removeDCMode = false;
            document.getElementById('remove-dc-btn').classList.remove('active');
            this.classList.toggle('active');
            const hint = document.getElementById('dc-mode-hint');
            if (addDCMode) {
                this.style.background = '#0056b3';
                hint.textContent = 'üìç Click on the map to add a new DC location';
                hint.style.display = 'block';
            } else {
                this.style.background = '#007bff';
                hint.style.display = 'none';
            }
        });

        // Remove DC button handler
        document.getElementById('remove-dc-btn').addEventListener('click', function() {
            removeDCMode = !removeDCMode;
            addDCMode = false;
            document.getElementById('add-dc-btn').classList.remove('active');
            document.getElementById('add-dc-btn').style.background = '#007bff';
            this.classList.toggle('active');
            const hint = document.getElementById('dc-mode-hint');
            if (removeDCMode) {
                this.style.background = '#a71d2a';
                hint.textContent = 'üóëÔ∏è Click on a DC marker on the map to remove it';
                hint.style.display = 'block';
            } else {
                this.style.background = '#dc3545';
                hint.style.display = 'none';
            }
        });

        // Global function to toggle DC active state from popup
        window.toggleDCFromPopup = function(dcId) {
            // Find DC in newScenarioDCs and toggle
            const dc = newScenarioDCs.find(d => d.id === dcId);
            if (dc) {
                dc.active = !dc.active;
                // Also update in dcLocations if present
                const mainDC = dcLocations.find(d => d.id === dcId);
                if (mainDC) mainDC.active = dc.active;
                // Close popup and refresh
                mapNewScenario.closePopup();
                updateNewScenarioDCList();
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }
        };

        // Global function to delete DC from popup
        window.deleteDCFromPopup = function(dcId) {
            // Remove from dcLocations
            const idx = dcLocations.findIndex(d => d.id === dcId);
            if (idx > -1) {
                dcLocations.splice(idx, 1);
            }
            // Remove from newScenarioDCs
            const nsIdx = newScenarioDCs.findIndex(d => d.id === dcId);
            if (nsIdx > -1) {
                newScenarioDCs.splice(nsIdx, 1);
            }
            // Close popup and refresh
            mapNewScenario.closePopup();
            updateNewScenarioDCList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        };

        // Volume circles toggle handler
        document.getElementById('show-volume-circles').addEventListener('change', function() {
            showVolumeCircles = this.checked;
            // Re-render all visible maps
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }
            if (mapAnalytics1 && markersAnalytics1 && scenario1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (mapAnalytics2 && markersAnalytics2 && scenario2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        });

        // Initial assignment and draw for new scenario
        assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
        setTimeout(() => {
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        }, 200);

        // Reference Scenario select handler
        document.getElementById('reference-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                document.getElementById('reference-scenario-display').style.display = 'none';
                return;
            }

            const refScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Show display
            document.getElementById('reference-scenario-display').style.display = 'block';

            // Generate metrics
            document.getElementById('reference-metrics').innerHTML = generateMetricsHTML(
                refScenario.dcLocations,
                refScenario.demandPoints,
                refScenario.name
            );

            // Draw map using Leaflet
            if (mapReference && markersReference) {
                mapReference.invalidateSize();
                renderMapMarkers(mapReference, markersReference, refScenario.dcLocations, refScenario.demandPoints, false);
            }

            // Display parameters
            const params = document.getElementById('reference-parameters');
            params.innerHTML = `
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>First Mile Rate:</strong><br>$${document.getElementById('first-mile-rate').value}/pallet/1,000km
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Last Mile Rate:</strong><br>$${document.getElementById('last-mile-rate').value}/pallet/1,000km
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Storage Rate:</strong><br>$${document.getElementById('storage-rate').value}/pallet/month
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>DIO:</strong><br>${document.getElementById('dio').value} days
                </div>
            `;
        });

        // Store preloaded scenario state for reset functionality
        let preloadedState = null;

        // Preload scenario handler
        document.getElementById('preload-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                preloadedState = null;
                document.getElementById('reset-to-preloaded').style.display = 'none';
                return;
            }

            const preloadScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Update DCs
            newScenarioDCs = JSON.parse(JSON.stringify(preloadScenario.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadScenario.demandPoints));

            // Store preloaded state for reset
            preloadedState = {
                dcLocations: JSON.parse(JSON.stringify(preloadScenario.dcLocations)),
                demandPoints: JSON.parse(JSON.stringify(preloadScenario.demandPoints)),
                firstMileRate: document.getElementById('first-mile-rate').value,
                lastMileRate: document.getElementById('last-mile-rate').value,
                storageRate: document.getElementById('storage-rate').value,
                dio: document.getElementById('dio').value
            };

            // Reinitialize checkboxes with new DC array
            reinitializeNewScenarioCheckboxes();

            // Update parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;

            // Show reset button
            document.getElementById('reset-to-preloaded').style.display = 'block';

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Reset to preloaded handler
        document.getElementById('reset-to-preloaded').addEventListener('click', () => {
            if (!preloadedState) return;

            // Restore preloaded state
            newScenarioDCs = JSON.parse(JSON.stringify(preloadedState.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadedState.demandPoints));

            // Reinitialize checkboxes with restored DC array
            reinitializeNewScenarioCheckboxes();

            // Restore parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Run Optimization handler
        document.getElementById('run-new-optimization').addEventListener('click', async () => {
            const btn = document.getElementById('run-new-optimization');
            const dropdownBtn = document.getElementById('run-new-optimization-dropdown');
            btn.disabled = true;
            dropdownBtn.disabled = true;
            btn.textContent = '‚è≥ Optimizing...';

            try {
                scenarioFeedCounter++;
                const solver = selectedSolver;
                const scenarioName = 'Run_' + scenarioFeedCounter + '_' + solverNames[solver] + '_' + new Date().toLocaleTimeString();

                // Get parameters
                const firstMile = parseFloat(document.getElementById('new-first-mile-rate').value);
                const lastMile = parseFloat(document.getElementById('new-last-mile-rate').value);
                const storage = parseFloat(document.getElementById('new-storage-rate').value);
                const dio = parseInt(document.getElementById('new-dio').value);

                // Clone current state
                const runDCs = JSON.parse(JSON.stringify(newScenarioDCs));
                const runDemands = JSON.parse(JSON.stringify(demandPoints));

                const startTime = performance.now();

                if (solver === 'heuristic') {
                    // Run heuristic optimization on runDCs
                    function calculateScenarioCost(dcs, demands) {
                        const activeDCs = dcs.filter(dc => dc.active);
                        let total = 0;
                        const fm = firstMile / 1000;
                        const lm = lastMile / 1000;

                        activeDCs.forEach(dc => {
                            const dist = distance(factory, dc);
                            const throughput = demands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                            total += dist * throughput * fm * 12;
                            total += throughput * (dio / 365) * storage * 12;
                        });
                        demands.forEach(point => {
                            if (point.assignedDC) {
                                total += point.distance * point.demand * lm * 12;
                            }
                        });
                        return total;
                    }

                    // Start with all DCs active that are within range
                    runDCs.forEach(dc => {
                        dc.active = distance(factory, dc) <= 4000;
                    });
                    assignCustomersToScenario(runDemands, runDCs);
                    let currentCost = calculateScenarioCost(runDCs, runDemands);

                    let improved = true;
                    let iterations = 0;
                    while (improved && iterations < 10) {
                        improved = false;
                        iterations++;
                        let bestSavings = 0;
                        let bestDCToClose = -1;

                        for (let i = 0; i < runDCs.length; i++) {
                            if (!runDCs[i].active) continue;
                            runDCs[i].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            const allAssigned = runDemands.every(p => p.assignedDC !== null);
                            if (allAssigned) {
                                const newCost = calculateScenarioCost(runDCs, runDemands);
                                const savings = currentCost - newCost;
                                if (savings > bestSavings) {
                                    bestSavings = savings;
                                    bestDCToClose = i;
                                }
                            }
                            runDCs[i].active = true;
                        }

                        if (bestDCToClose >= 0) {
                            runDCs[bestDCToClose].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            currentCost = calculateScenarioCost(runDCs, runDemands);
                            improved = true;
                        }
                    }
                    assignCustomersToScenario(runDemands, runDCs);

                } else if (solver === 'highs' || solver === 'glpk') {
                    // Use MIP solver with the target arrays directly
                    try {
                        if (solver === 'highs') {
                            await optimizeWithHiGHS(runDCs, runDemands);
                        } else {
                            await optimizeWithGLPK(runDCs, runDemands);
                        }
                    } catch (e) {
                        console.error('Solver error in New Scenario:', e);
                    }
                    // Ensure customers are assigned after optimization
                    assignCustomersToScenario(runDemands, runDCs);
                }

                const endTime = performance.now();
                const solveTime = Math.round(endTime - startTime);

                // Add to scenario feed
                addScenarioToFeed(scenarioName, runDCs, runDemands, {firstMile, lastMile, storage, dio, solver: solverNames[solver], solveTime});

            } finally {
                btn.disabled = false;
                dropdownBtn.disabled = false;
                btn.textContent = 'Run Optimization (' + solverNames[selectedSolver] + ')';
            }
        });

        // Save Scenario handler
        document.getElementById('save-new-scenario').addEventListener('click', () => {
            const name = prompt('Enter scenario name:');
            if (!name) return;

            const scenario = {
                name,
                dcActive: newScenarioDCs.map(dc => dc.active),
                parameters: {
                    firstMileRate: document.getElementById('new-first-mile-rate').value,
                    lastMileRate: document.getElementById('new-last-mile-rate').value,
                    storageRate: document.getElementById('new-storage-rate').value,
                    dio: document.getElementById('new-dio').value
                },
                demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
            };
            localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));

            // Add to all dropdowns
            const option1 = document.createElement('option');
            option1.value = name;
            option1.textContent = name;
            document.getElementById('scenario-select-1').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-2').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-3').appendChild(option1.cloneNode(true));
            document.getElementById('reference-scenario-select').appendChild(option1.cloneNode(true));
            document.getElementById('preload-scenario-select').appendChild(option1);

            alert('Scenario saved!');
        });

        // Function to add scenario to feed
        function addScenarioToFeed(name, dcs, demands, params) {
            const feed = document.getElementById('scenario-feed');
            const scenarioId = 'scenario-' + Date.now();

            const scenarioBlock = document.createElement('div');
            scenarioBlock.id = scenarioId;
            scenarioBlock.style.cssText = 'background: white; padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px;';

            const solverInfo = params.solver ? `<span style="margin-left: 10px; padding: 4px 10px; background: var(--cel-blue); color: white; border-radius: 12px; font-size: 12px;">${params.solver}${params.solveTime ? ' - ' + params.solveTime + 'ms' : ''}</span>` : '';

            scenarioBlock.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center;">
                        <h3 style="font-size: 18px; font-weight: 600; color: var(--text-dark); margin: 0;">${name}</h3>
                        ${solverInfo}
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="toggle-btn" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Collapse</button>
                        <button class="hide-btn" style="padding: 6px 14px; background: #ffc107; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Hide</button>
                        <button class="save-btn" style="padding: 6px 14px; background: var(--cel-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Save</button>
                        <button class="delete-btn" style="padding: 6px 14px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Delete</button>
                    </div>
                </div>
                <div class="metrics-grid scenario-metrics" style="margin-bottom: 0;"></div>
                <div class="scenario-details" style="margin-top: 15px;">
                    <div>
                        <div class="scenario-map" id="${scenarioId}-map" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 8px;"></div>
                    </div>
                    <div style="margin-top: 20px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px;">
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>First Mile Rate:</strong><br>$${params.firstMile}/pallet/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Last Mile Rate:</strong><br>$${params.lastMile}/pallet/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Storage Rate:</strong><br>$${params.storage}/pallet/month</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>DIO:</strong><br>${params.dio} days</div>
                        <div style="padding: 15px; background: #e8f4fd; border-radius: 4px;"><strong>Solver:</strong><br>${params.solver || 'Heuristic'}${params.solveTime ? ' (' + params.solveTime + 'ms)' : ''}</div>
                    </div>
                </div>
            `;

            feed.appendChild(scenarioBlock);

            // Generate metrics
            const metricsGrid = scenarioBlock.querySelector('.scenario-metrics');
            metricsGrid.innerHTML = generateMetricsHTML(dcs, demands, name);

            // Initialize mini Leaflet map for scenario
            setTimeout(() => {
                const mapContainer = document.getElementById(scenarioId + '-map');
                if (mapContainer && !mapContainer._leaflet_id) {
                    const miniMap = L.map(mapContainer, {
                        center: INDONESIA_CENTER,
                        zoom: INDONESIA_ZOOM,
                        zoomControl: true,
                        scrollWheelZoom: false
                    });
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                        attribution: '¬© CARTO',
                        maxZoom: 18
                    }).addTo(miniMap);

                    const markersLayer = L.layerGroup().addTo(miniMap);
                    renderMapMarkers(miniMap, markersLayer, dcs, demands, false);

                    // Store map reference for cleanup
                    mapContainer._leafletMap = miniMap;
                }
            }, 100);

            // Add event listeners
            scenarioBlock.querySelector('.toggle-btn').addEventListener('click', function() {
                const details = scenarioBlock.querySelector('.scenario-details');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    this.textContent = 'Collapse';
                } else {
                    details.style.display = 'none';
                    this.textContent = 'Expand';
                }
            });

            scenarioBlock.querySelector('.hide-btn').addEventListener('click', () => {
                scenarioBlock.style.display = 'none';
            });

            scenarioBlock.querySelector('.save-btn').addEventListener('click', () => {
                const saveName = prompt('Enter scenario name:', name);
                if (!saveName) return;

                const scenario = {
                    name: saveName,
                    dcActive: dcs.map(dc => dc.active),
                    parameters: {
                        firstMileRate: params.firstMile,
                        lastMileRate: params.lastMile,
                        storageRate: params.storage,
                        dio: params.dio
                    },
                    demands: demands.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + saveName, JSON.stringify(scenario));

                // Update the scenario block heading to reflect the saved name
                const heading = scenarioBlock.querySelector('h3');
                if (heading) {
                    heading.textContent = saveName;
                }

                // Update the internal name variable for future operations
                name = saveName;

                // Add to all dropdowns if not already there
                const existingOption = document.querySelector(`option[value="${saveName}"]`);
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = saveName;
                    option.textContent = saveName;
                    document.getElementById('scenario-select-1').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-2').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-3').appendChild(option.cloneNode(true));
                    document.getElementById('reference-scenario-select').appendChild(option.cloneNode(true));
                    document.getElementById('preload-scenario-select').appendChild(option);
                }

                alert('Scenario saved as "' + saveName + '"!');
            });

            scenarioBlock.querySelector('.delete-btn').addEventListener('click', () => {
                scenarioBlock.remove();
                // Remove from localStorage if it was saved
                localStorage.removeItem('dno-scenario-' + name);
                // Remove from dropdowns
                document.querySelectorAll('option').forEach(opt => {
                    if (opt.value === name) opt.remove();
                });
            });
        }

        // Function to restore saved scenarios from localStorage on page load
        function restoreSavedScenarios() {
            // Find all saved scenarios in localStorage
            const savedScenarios = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('dno-scenario-')) {
                    const scenarioName = key.replace('dno-scenario-', '');
                    const scenarioData = JSON.parse(localStorage.getItem(key));
                    savedScenarios.push({ name: scenarioName, data: scenarioData });
                }
            }

            // Restore each scenario to the feed
            savedScenarios.forEach(({ name, data }) => {
                // Reconstruct DC locations with active states
                const dcs = JSON.parse(JSON.stringify(dcLocations));
                dcs.forEach((dc, index) => {
                    if (data.dcActive && data.dcActive[index] !== undefined) {
                        dc.active = data.dcActive[index];
                    }
                });

                // Use current demand points (they're generated with a fixed seed)
                const demands = JSON.parse(JSON.stringify(demandPoints));

                // Assign customers to DCs
                assignCustomersToScenario(demands, dcs);

                // Extract parameters
                const params = {
                    firstMile: parseFloat(data.parameters.firstMileRate),
                    lastMile: parseFloat(data.parameters.lastMileRate),
                    storage: parseFloat(data.parameters.storageRate),
                    dio: parseInt(data.parameters.dio)
                };

                // Add to scenario feed
                addScenarioToFeed(name, dcs, demands, params);
            });
        }

        // Restore saved scenarios when page loads
        restoreSavedScenarios();
    </script>
</body>
</html>