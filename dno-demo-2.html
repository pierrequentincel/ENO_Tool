<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOM - Distribution Network Design</title>
    <link rel="icon" type="image/png" href="pictures/ATOM_logo_crop.png">
    <!-- Solver Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/highs@1.8.0/build/highs.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/glpk.js@4.0.1/dist/glpk.min.js"></script>
    <!-- Leaflet.js for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- D3 Delaunay for Voronoi diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>
    <!-- KaTeX for LaTeX formula rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        :root {
            --cel-red: #CB333B;
            --cel-blue: #385D7F;
            --cel-dark-blue: #2c4a5f;
            --cel-orange: #FE5000;
            --cel-green: #30B700;
            --cel-yellow: #FFD100;
            --bg-light: #F5F7FA;
            --text-dark: #2D3748;
            --sidebar-bg: #4A6883;
        }
        /* Spinner animation for loading states */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 8px;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-light);
            color: var(--text-dark);
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header Navigation Bar */
        .header-nav {
            display: flex;
            align-items: center;
            background-color: white;
            border-bottom: 2px solid #e2e8f0;
            padding: 0 20px;
            height: 56px;
            flex-shrink: 0;
        }
        .header-brand {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-right: 30px;
            border-right: 1px solid #e2e8f0;
            margin-right: 10px;
        }
        .header-brand img {
            height: 36px;
            width: auto;
            background-color: var(--cel-blue);
            padding: 4px 8px;
            border-radius: 4px;
        }
        .header-brand-text {
            font-size: 18px;
            font-weight: 700;
            color: var(--cel-blue);
            letter-spacing: -0.5px;
        }

        /* Scenario Selection for Analytics */
        .scenario-selection-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            padding: 15px 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 25px;
        }
        .scenario-selection-bar label {
            font-size: 13px;
            color: #64748b;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .scenario-selection-bar select {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 13px;
            min-width: 180px;
        }

        /* Main Content */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Tabs */
        .tabs {
            display: flex;
            align-items: center;
        }
        .tab {
            padding: 18px 24px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #64748b;
            font-size: 14px;
            margin-bottom: -2px;
        }
        .tab.active {
            color: var(--cel-blue);
            border-bottom-color: var(--cel-blue);
        }
        .tab:hover {
            background-color: #f8fafc;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Key Metrics */
        .section-title {
            font-size: 28px;
            font-weight: 600;
            color: var(--cel-blue);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--cel-blue);
        }
        .scenario-label {
            font-size: 18px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 20px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 40px;
        }
        .metric-card {
            background: white;
            padding: 12px 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .metric-label {
            font-size: 11px;
            color: #64748b;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .metric-sublabel {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 8px;
            min-height: 12px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--cel-blue);
        }
        .metric-tag {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 12px;
            background-color: #e2e8f0;
            color: #64748b;
            font-size: 11px;
            border-radius: 12px;
        }

        /* Cost Breakdown */
        .cost-breakdown {
            margin-top: 40px;
        }
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        .chart-wrapper {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 20px;
        }

        /* Map Container */
        #map-container, #map-container-analytics {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #map, #map-analytics {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .network-map-section {
            margin-top: 40px;
            margin-bottom: 40px;
        }

        /* Map Comparison Container */
        #map-comparison-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        #map-comparison-container.two-scenarios {
            grid-template-columns: 1fr;
        }
        .map-container-single {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .map-container-single canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .map-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(74, 104, 131, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            z-index: 5;
        }
        #tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            display: none;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Header Navigation Bar -->
        <div class="header-nav">
            <div class="header-brand">
                <img src="pictures/ATOM_logo.png" alt="ATOM Logo">
                <span class="header-brand-text">ENO Sandbox</span>
            </div>
            <div class="tabs">
                <div class="tab active" data-tab="new-scenario">New Scenario</div>
                <div class="tab" data-tab="analytics">Analytics</div>
                <div class="tab" data-tab="data-admin">Data Admin</div>
                <div class="tab" data-tab="info">Documentation</div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <div class="content-area">
                <!-- Analytics Tab -->
                <div class="tab-content" id="analytics-tab">
                    <!-- Scenario Selection -->
                    <div class="scenario-selection-bar">
                        <label>
                            <span>First Scenario:</span>
                            <select id="scenario-select-1">
                                <option value="baseline">0,5_Baseline_2028</option>
                            </select>
                        </label>
                        <label>
                            <span>Second Scenario:</span>
                            <select id="scenario-select-2">
                                <option value="">Choose an option</option>
                                <option value="baseline">0,5_Baseline_2028</option>
                            </select>
                        </label>
                        <label>
                            <span>Third Scenario:</span>
                            <select id="scenario-select-3">
                                <option value="">Choose an option</option>
                                <option value="baseline">0,5_Baseline_2028</option>
                            </select>
                        </label>
                    </div>

                    <h2 class="section-title">Key Metrics</h2>

                    <!-- Scenario 1 -->
                    <div class="scenario-label" id="scenario-label-1">0,5_Baseline_2028</div>
                    <div class="metrics-grid" id="metrics-grid-1">
                        <!-- Metrics will be populated by JavaScript -->
                    </div>

                    <!-- Scenario 2 (hidden by default) -->
                    <div id="scenario-2-section" style="display: none;">
                        <div class="scenario-label" id="scenario-label-2">Scenario 2</div>
                        <div class="metrics-grid" id="metrics-grid-2">
                            <!-- Metrics will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="network-map-section">
                        <h2 class="section-title">Network Map</h2>
                        <div id="map-comparison-container">
                            <!-- Scenario 1 Map -->
                            <div id="map-container-analytics-1" class="map-container-single">
                                <div class="map-label">Scenario 1</div>
                                <div id="map-analytics-1" style="width: 100%; height: 500px; z-index: 1;"></div>
                            </div>

                            <!-- Scenario 2 Map (hidden by default) -->
                            <div id="map-container-analytics-2" class="map-container-single" style="display: none;">
                                <div class="map-label">Scenario 2</div>
                                <div id="map-analytics-2" style="width: 100%; height: 500px; z-index: 1;"></div>
                            </div>
                        </div>
                    </div>

                    <div class="cost-breakdown">
                        <h2 class="section-title">Cost Breakdown</h2>
                        <div class="charts-container">
                            <div class="chart-wrapper">
                                <div class="chart-title">Absolute Logistics Cost Breakdown</div>
                                <canvas id="absolute-chart" width="400" height="300"></canvas>
                            </div>
                            <div class="chart-wrapper">
                                <div class="chart-title">Relative Logistics Cost Breakdown</div>
                                <canvas id="relative-chart" width="400" height="300"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- New Scenario Tab -->
                <div class="tab-content active" id="new-scenario-tab">
                    <h2 class="section-title">New Scenario</h2>

                    <!-- Data Input (Collapsible) -->
                    <div style="margin-top: 30px; margin-bottom: 30px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <!-- Collapsible Header -->
                        <div id="data-input-toggle" style="display: flex; align-items: center; justify-content: space-between; padding: 15px 20px; cursor: pointer; user-select: none;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="data-input-toggle-icon" style="font-size: 12px; color: #666;">&#9654;</span>
                                <img src="pictures/data.png" alt="Data" style="height: 24px; width: auto;">
                                <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Data Input</h3>
                            </div>
                        </div>

                        <!-- Collapsible Content -->
                        <div id="data-input-content" style="display: none; padding: 0 20px 20px 20px;">

                            <!-- 3-Column Layout -->
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">

                            <!-- Demand Data Section -->
                            <div style="border: 1px solid #e9ecef; border-radius: 8px; padding: 15px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: var(--text-dark);">Demand Data</h4>
                                    <span style="font-size: 10px; color: #888;">lat, lng, demand</span>
                                </div>

                                <!-- File Selection -->
                                <select id="demand-file-select" style="width: 100%; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-bottom: 6px;">
                                    <option value="">-- Select a file --</option>
                                </select>
                                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                                    <button id="demand-file-save" style="flex: 1; padding: 5px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Save current data">Save</button>
                                    <button id="demand-file-rename" style="flex: 1; padding: 5px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Rename selected file">Rename</button>
                                    <button id="demand-file-delete" style="flex: 1; padding: 5px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Delete selected file">Delete</button>
                                </div>

                                <!-- Upload Area -->
                                <div id="demand-drop-zone" style="border: 2px dashed #ccc; border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.2s; margin-bottom: 8px;">
                                    <input type="file" id="demand-file-upload" accept=".csv" style="display: none;">
                                    <div style="color: #666; font-size: 12px;">
                                        <span style="font-size: 20px; display: block; margin-bottom: 4px;">üìÅ</span>
                                        Drop CSV or <span style="color: #007bff; text-decoration: underline;">browse</span>
                                    </div>
                                </div>

                                <!-- Status -->
                                <div id="demand-file-status" style="font-size: 11px; color: #666; margin-bottom: 8px;">
                                    <span id="demand-point-count">0</span> demand points loaded
                                </div>

                                <!-- Expandable Data Table -->
                                <div>
                                    <div id="demand-table-toggle-input" style="display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none;">
                                        <span id="demand-table-icon-input" style="font-size: 10px; color: #666;">&#9654;</span>
                                        <span style="font-size: 11px; color: #666;">View Data Table</span>
                                    </div>
                                    <div id="demand-table-container-input" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 4px;">
                                        <table id="demand-data-table-input" style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                            <thead style="position: sticky; top: 0; background: #f8f9fa;">
                                                <tr>
                                                    <th style="padding: 6px; text-align: left; border-bottom: 1px solid #dee2e6;">#</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Lat</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Lng</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Demand</th>
                                                </tr>
                                            </thead>
                                            <tbody id="demand-table-body-input"></tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>

                            <!-- Factories Data Section -->
                            <div style="border: 1px solid #e9ecef; border-radius: 8px; padding: 15px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: var(--text-dark);">Factories Data</h4>
                                    <span style="font-size: 10px; color: #888;">lat, lng</span>
                                </div>

                                <!-- File Selection -->
                                <select id="factories-file-select" style="width: 100%; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-bottom: 6px;">
                                    <option value="">-- Select a file --</option>
                                </select>
                                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                                    <button id="factories-file-save" style="flex: 1; padding: 5px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Save current data">Save</button>
                                    <button id="factories-file-rename" style="flex: 1; padding: 5px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Rename selected file">Rename</button>
                                    <button id="factories-file-delete" style="flex: 1; padding: 5px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Delete selected file">Delete</button>
                                </div>

                                <!-- Upload Area -->
                                <div id="factories-drop-zone" style="border: 2px dashed #ccc; border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.2s; margin-bottom: 8px;">
                                    <input type="file" id="factories-file-upload" accept=".csv" style="display: none;">
                                    <div style="color: #666; font-size: 12px;">
                                        <span style="font-size: 20px; display: block; margin-bottom: 4px;">üè≠</span>
                                        Drop CSV or <span style="color: #007bff; text-decoration: underline;">browse</span>
                                    </div>
                                </div>

                                <!-- Status -->
                                <div id="factories-file-status" style="font-size: 11px; color: #666; margin-bottom: 8px;">
                                    <span id="factories-point-count">0</span> factories loaded
                                </div>

                                <!-- Expandable Data Table -->
                                <div>
                                    <div id="factories-table-toggle-input" style="display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none;">
                                        <span id="factories-table-icon-input" style="font-size: 10px; color: #666;">&#9654;</span>
                                        <span style="font-size: 11px; color: #666;">View Data Table</span>
                                    </div>
                                    <div id="factories-table-container-input" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 4px;">
                                        <table id="factories-data-table-input" style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                            <thead style="position: sticky; top: 0; background: #f8f9fa;">
                                                <tr>
                                                    <th style="padding: 6px; text-align: left; border-bottom: 1px solid #dee2e6;">#</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Lat</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Lng</th>
                                                </tr>
                                            </thead>
                                            <tbody id="factories-table-body-input"></tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>

                            <!-- DCs Data Section -->
                            <div style="border: 1px solid #e9ecef; border-radius: 8px; padding: 15px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <h4 style="margin: 0; font-size: 14px; font-weight: 600; color: var(--text-dark);">DCs Data</h4>
                                    <span style="font-size: 10px; color: #888;">lat, lng</span>
                                </div>

                                <!-- File Selection -->
                                <select id="dcs-file-select" style="width: 100%; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; margin-bottom: 6px;">
                                    <option value="">-- Select a file --</option>
                                </select>
                                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                                    <button id="dcs-file-save" style="flex: 1; padding: 5px 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Save current data">Save</button>
                                    <button id="dcs-file-rename" style="flex: 1; padding: 5px 8px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Rename selected file">Rename</button>
                                    <button id="dcs-file-delete" style="flex: 1; padding: 5px 8px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Delete selected file">Delete</button>
                                </div>

                                <!-- Upload Area -->
                                <div id="dcs-drop-zone" style="border: 2px dashed #ccc; border-radius: 8px; padding: 15px; text-align: center; cursor: pointer; transition: all 0.2s; margin-bottom: 8px;">
                                    <input type="file" id="dcs-file-upload" accept=".csv" style="display: none;">
                                    <div style="color: #666; font-size: 12px;">
                                        <span style="font-size: 20px; display: block; margin-bottom: 4px;">üì¶</span>
                                        Drop CSV or <span style="color: #007bff; text-decoration: underline;">browse</span>
                                    </div>
                                </div>

                                <!-- Status -->
                                <div id="dcs-file-status" style="font-size: 11px; color: #666; margin-bottom: 8px;">
                                    <span id="dcs-point-count">0</span> DCs loaded
                                </div>

                                <!-- Expandable Data Table -->
                                <div>
                                    <div id="dcs-table-toggle-input" style="display: flex; align-items: center; gap: 6px; cursor: pointer; user-select: none;">
                                        <span id="dcs-table-icon-input" style="font-size: 10px; color: #666;">&#9654;</span>
                                        <span style="font-size: 11px; color: #666;">View Data Table</span>
                                    </div>
                                    <div id="dcs-table-container-input" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 4px;">
                                        <table id="dcs-data-table-input" style="width: 100%; border-collapse: collapse; font-size: 11px;">
                                            <thead style="position: sticky; top: 0; background: #f8f9fa;">
                                                <tr>
                                                    <th style="padding: 6px; text-align: left; border-bottom: 1px solid #dee2e6;">#</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Lat</th>
                                                    <th style="padding: 6px; text-align: right; border-bottom: 1px solid #dee2e6;">Lng</th>
                                                </tr>
                                            </thead>
                                            <tbody id="dcs-table-body-input"></tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>

                            </div><!-- End 3-Column Layout -->

                        </div>
                    </div>

                    <!-- Demand Clustering Tool (Collapsible) -->
                    <div style="margin-top: 30px; margin-bottom: 30px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <!-- Collapsible Header -->
                        <div id="clustering-toggle" style="display: flex; align-items: center; justify-content: space-between; padding: 15px 20px; cursor: pointer; user-select: none;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="clustering-toggle-icon" style="font-size: 12px; color: #666;">&#9654;</span>
                                <img src="pictures/cluster.png" alt="Cluster" style="height: 24px; width: auto;">
                                <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Demand Clustering Tool</h3>
                            </div>
                        </div>

                        <!-- Collapsible Content -->
                        <div id="clustering-content" style="display: none; padding: 0 20px 20px 20px;">
                            <!-- Controls Row -->
                            <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                                <!-- Number of Clusters (using number input for performance) -->
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-size: 13px; color: #64748b;">Clusters:</label>
                                    <input type="number" id="cluster-count" min="1" max="200" value="50" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; width: 80px;">
                                </div>

                                <!-- Algorithm Selection -->
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-size: 13px; color: #64748b;">Algorithm:</label>
                                    <select id="clustering-algorithm" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                        <option value="kmeans">Weighted K-Means</option>
                                        <option value="kmedoids">Weighted K-Medoids</option>
                                    </select>
                                </div>

                                <!-- Run Clustering Button -->
                                <button id="run-clustering" style="padding: 8px 16px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
                                    Run Clustering
                                </button>

                                <!-- Clustering Action Buttons (hidden until clustering runs) -->
                                <div id="clustering-action-buttons" style="display: none; align-items: center; gap: 10px; margin-left: auto;">
                                    <button id="reset-clustering" style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Reset</button>
                                    <button id="add-centroids-as-dcs" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Add Centroids</button>
                                    <button id="replace-dcs-with-centroids" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Replace DCs</button>
                                </div>
                            </div>

                            <!-- Clustering Status/Info -->
                            <div id="clustering-info" style="display: none; padding: 10px 15px; background: #e8f4fd; border-radius: 4px; font-size: 12px; color: var(--cel-dark-blue);">
                                <!-- Will show clustering results info -->
                            </div>

                            <!-- Embedded Clustering Map -->
                            <div id="clustering-map-container" style="display: none; margin-top: 15px;">
                                <!-- Map Visualization Controls -->
                                <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 10px; padding: 10px 15px; background: #f8f9fa; border-radius: 4px;">
                                    <span style="font-size: 13px; font-weight: 600; color: #64748b;">Visualization:</span>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #64748b;">
                                        <input type="checkbox" id="show-voronoi" checked>
                                        <span>Voronoi Tiles</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #64748b;">
                                        <input type="checkbox" id="show-demand-points" checked>
                                        <span>Demand Points</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #64748b;">
                                        <input type="checkbox" id="show-centroid-links">
                                        <span>Centroid Links</span>
                                    </label>
                                </div>
                                <!-- The Map -->
                                <div id="clustering-map" style="width: 100%; height: 520px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- New Scenario Creator (Collapsible) -->
                    <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <!-- Collapsible Header -->
                        <div id="scenario-toggle" style="display: flex; align-items: center; justify-content: space-between; padding: 15px 20px; cursor: pointer; user-select: none;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="scenario-toggle-icon" style="font-size: 12px; color: #666;">&#9654;</span>
                                <img src="pictures/scenario.png" alt="Scenario" style="height: 24px; width: auto;">
                                <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Create New Scenario</h3>
                            </div>
                            <div style="display: flex; align-items: center; gap: 15px;">
                                <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #64748b;" onclick="event.stopPropagation();">
                                    <span>Preload:</span>
                                    <select id="preload-scenario-select" onclick="event.stopPropagation();" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                        <option value="">None</option>
                                        <option value="baseline">0,5_Baseline_2028</option>
                                    </select>
                                </label>
                                <button id="reset-to-preloaded" onclick="event.stopPropagation();" style="display: none; padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset</button>
                            </div>
                        </div>

                        <!-- Collapsible Content -->
                        <div id="scenario-content" style="display: none; padding: 0 20px 20px 20px;">
                        <!-- Run Controls -->
                        <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                            <!-- Run Mode Selector -->
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 13px; color: #64748b;">Mode:</span>
                                <select id="run-mode-select" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                    <option value="auto">Auto Run</option>
                                    <option value="manual">Manual</option>
                                </select>
                            </div>

                            <!-- Solver Selector -->
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 13px; color: #64748b;">Solver:</span>
                                <select id="solver-select" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                    <option value="highs">HiGHS</option>
                                    <option value="heuristic">Heuristic</option>
                                    <option value="glpk">GLPK</option>
                                </select>
                            </div>

                            <!-- Run Button (only shown in Manual mode) -->
                            <button id="run-new-optimization" style="display: none; padding: 10px 20px; background: var(--cel-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 13px;">Run Optimization</button>

                            <!-- Run Time Indicator -->
                            <span id="run-time-indicator" style="display: none; margin-left: 15px; padding: 6px 12px; background: #e8f4fd; color: var(--cel-blue); border-radius: 4px; font-size: 12px; font-weight: 500;"></span>

                            <!-- Spacer to push buttons to the right -->
                            <div style="flex: 1;"></div>

                            <!-- Quick Save Button -->
                            <button id="quick-save-scenario" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 500; cursor: pointer; font-size: 13px;">Quick Save</button>

                            <!-- Save Button -->
                            <button id="save-new-scenario" style="padding: 10px 20px; background: var(--cel-green); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 13px;">Save Scenario</button>
                        </div>

                        <!-- Key Indicators -->
                        <div id="live-indicators" class="metrics-grid" style="grid-template-columns: repeat(8, 1fr); margin-bottom: 15px;">
                            <div class="metric-card">
                                <div class="metric-label">Total Cost</div>
                                <div class="metric-sublabel">(B IDR)</div>
                                <div class="metric-value" id="live-total-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Transport</div>
                                <div class="metric-sublabel">(B IDR)</div>
                                <div class="metric-value" id="live-transport-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Storage</div>
                                <div class="metric-sublabel">(B IDR)</div>
                                <div class="metric-value" id="live-storage-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Active DCs</div>
                                <div class="metric-sublabel">-</div>
                                <div class="metric-value" id="live-active-dcs">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Cost per NSV</div>
                                <div class="metric-sublabel">Ratio</div>
                                <div class="metric-value" id="live-cost-per-nsv">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Unit CTS</div>
                                <div class="metric-sublabel">(IDR/PCS)</div>
                                <div class="metric-value" id="live-unit-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">DOS</div>
                                <div class="metric-sublabel">(days)</div>
                                <div class="metric-value" id="live-dio">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Lead Time</div>
                                <div class="metric-sublabel">(days)</div>
                                <div class="metric-value" id="live-lead-time">-</div>
                            </div>
                        </div>

                        <!-- Full width map -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 10px;">Network Preview</h4>
                            <div id="new-scenario-map" style="width: 100%; height: 450px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                            <div style="margin-top: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <p style="margin: 0; font-size: 12px; color: #888; font-style: italic;">Click on an empty space to add a DC or factory. Click on a facility to deactivate or delete it.</p>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #64748b; white-space: nowrap;">
                                    <input type="checkbox" id="show-volume-circles">
                                    <span>Show DC volume</span>
                                </label>
                            </div>
                            <p style="margin-top: 4px; font-size: 12px; color: #888; font-style: italic;">Note: On manual run, links between facilities are based on distance only and may change after running the optimization.</p>
                            <div id="dc-type-legend" style="display: none; margin-top: 10px; padding: 8px 12px; background: #f8fafc; border-radius: 6px; font-size: 12px;">
                                <span style="font-weight: 600; margin-right: 12px;">DC Types:</span>
                                <span style="color: #1a365d; margin-right: 12px;">‚ñ≤ RDC</span>
                                <span style="color: #2f855a; margin-right: 12px;">‚ñ≤ DC Direct</span>
                                <span style="color: #dd6b20; margin-right: 12px;">‚ñ≤ Satellite</span>
                            </div>
                            <div id="map-click-popup" style="display: none; position: fixed; background: white; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px; z-index: 1000;">
                                <p style="margin: 0 0 10px 0; font-size: 13px; font-weight: 600;">Add at this location:</p>
                                <div style="display: flex; gap: 8px;">
                                    <button id="popup-add-dc" style="padding: 8px 16px; background: #385D7F; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">DC</button>
                                    <button id="popup-add-factory" style="padding: 8px 16px; background: #CB333B; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Factory</button>
                                    <button id="popup-cancel" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Cancel</button>
                                </div>
                            </div>
                        </div>

                        <!-- Parameters (left) and DC Selection (right) below map -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                            <!-- Left: Parameters -->
                            <div>
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">Parameters</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">First Mile Rate (IDR/PCS/1,000km)</label>
                                        <input type="number" id="new-first-mile-rate" value="5.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">Last Mile Rate (IDR/PCS/1,000km)</label>
                                        <input type="number" id="new-last-mile-rate" value="9.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">Storage Rate (IDR/PCS/month)</label>
                                        <input type="number" id="new-storage-rate" value="0.30" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">DOS (days)</label>
                                        <input type="number" id="new-dio" value="30" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div style="grid-column: span 2;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #64748b; cursor: pointer;">
                                                <input type="checkbox" id="new-min-dc-size-enabled">
                                                Min DC Size
                                            </label>
                                            <input type="number" id="new-min-dc-size" value="500" min="0" style="width: 90px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5;" disabled>
                                            <span style="font-size: 12px; color: #64748b;">PCS</span>
                                        </div>
                                    </div>
                                    <div style="grid-column: span 2;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #64748b; cursor: pointer;">
                                                <input type="checkbox" id="new-mid-mile-enabled">
                                                Min Volume for NDC Supply
                                            </label>
                                            <input type="number" id="new-min-volume-threshold" value="10" min="0" style="width: 70px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5;" disabled>
                                            <span style="font-size: 12px; color: #64748b;">M PCS</span>
                                        </div>
                                    </div>
                                    <div style="grid-column: span 2;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="font-size: 12px; color: #64748b;">Mid Mile Rate</label>
                                            <input type="number" id="new-mid-mile-rate" value="100" min="0" style="width: 80px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5;" disabled>
                                            <span style="font-size: 12px; color: #64748b;">IDR/PCS/1,000km</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Right: Factory & DC Selection -->
                            <div>
                                <!-- Factory Selection -->
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">Factory Selection</h4>
                                <div id="new-factory-list" style="max-height: 100px; overflow-y: auto; margin-bottom: 15px;"></div>

                                <!-- DC Selection -->
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">DC Selection</h4>
                                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <button id="select-all-dcs" style="flex: 1; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Select All</button>
                                    <button id="clear-all-dcs" style="flex: 1; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear All</button>
                                </div>
                                <div id="new-dc-list" style="max-height: 180px; overflow-y: auto;"></div>
                            </div>
                        </div>

                    </div>

                    <!-- Scenario Feed (dynamically populated) -->
                    <div id="scenario-feed-controls" style="margin-top: 40px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="font-size: 16px; font-weight: 600; color: var(--text-dark); margin: 0;">Scenario Results</h3>
                            <div style="display: flex; gap: 10px;">
                                <button id="expand-all-scenarios" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Expand All</button>
                                <button id="collapse-all-scenarios" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Collapse All</button>
                            </div>
                        </div>
                        </div>
                    </div>
                    <div id="scenario-feed"></div>
                </div>

                <!-- Data Admin Tab -->
                <div class="tab-content" id="data-admin-tab">
                    <h2 class="section-title">Data Admin</h2>

                    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 18px; color: var(--text-dark);">Demand Data</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            Upload a CSV file with columns: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">lat,lng,demand</code>
                        </p>

                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap;">
                            <input type="file" id="demand-csv-input" accept=".csv" style="flex: 1; min-width: 200px;">
                            <button id="load-demand-btn" class="btn" style="padding: 10px 20px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Load CSV</button>
                            <button id="reset-demand-btn" class="btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Reset to Default</button>
                        </div>

                        <div id="demand-data-summary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">Current Data:</span>
                                <strong><span id="demand-count">0</span> demand points</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Total Volume:</span>
                                <strong><span id="demand-total-volume">0</span> PCS/month</strong>
                            </div>
                        </div>

                        <div id="csv-error" style="color: #d32f2f; margin-top: 15px; padding: 10px; background: #ffebee; border-radius: 4px; display: none;"></div>
                        <div id="csv-success" style="color: #2e7d32; margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;"></div>

                        <!-- Data Table Section -->
                        <div style="margin-top: 20px; border-top: 1px solid #e9ecef; padding-top: 15px;">
                            <div id="demand-table-toggle" style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                                <span id="demand-table-icon" style="font-size: 12px; color: #666;">‚ñ∂</span>
                                <span style="font-weight: 600; color: var(--text-dark);">View Data Table</span>
                            </div>
                            <div id="demand-table-container" style="display: none; margin-top: 15px; max-height: 400px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 4px;">
                                <table id="demand-data-table" style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                    <thead style="position: sticky; top: 0; background: #f8f9fa;">
                                        <tr>
                                            <th class="sortable-header" data-sort="index" style="padding: 10px; text-align: left; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                # <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                            <th class="sortable-header" data-sort="lat" style="padding: 10px; text-align: right; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                Latitude <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                            <th class="sortable-header" data-sort="lng" style="padding: 10px; text-align: right; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                Longitude <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                            <th class="sortable-header" data-sort="demand" style="padding: 10px; text-align: right; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                Demand (PCS) <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody id="demand-table-body">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Factory Data Section -->
                    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px; margin-top: 30px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 18px; color: var(--text-dark);">Factory Data</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            Upload a CSV file with columns: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">lat,lng</code>
                        </p>

                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap;">
                            <input type="file" id="factory-csv-input" accept=".csv" style="flex: 1; min-width: 200px;">
                            <button id="load-factory-btn" class="btn" style="padding: 10px 20px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Load CSV</button>
                            <button id="reset-factory-btn" class="btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Reset to Default</button>
                        </div>

                        <div id="factory-data-summary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Current Data:</span>
                                <strong><span id="factory-count">0</span> factories</strong>
                            </div>
                        </div>

                        <div id="factory-csv-error" style="color: #d32f2f; margin-top: 15px; padding: 10px; background: #ffebee; border-radius: 4px; display: none;"></div>
                        <div id="factory-csv-success" style="color: #2e7d32; margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;"></div>
                    </div>

                    <!-- DC Data Section -->
                    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px; margin-top: 30px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 18px; color: var(--text-dark);">Distribution Center Data</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            Upload a CSV file with columns: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">lat,lng</code>
                        </p>

                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap;">
                            <input type="file" id="dc-csv-input" accept=".csv" style="flex: 1; min-width: 200px;">
                            <button id="load-dc-btn" class="btn" style="padding: 10px 20px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Load CSV</button>
                            <button id="reset-dc-btn" class="btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Reset to Default</button>
                        </div>

                        <div id="dc-data-summary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Current Data:</span>
                                <strong><span id="dc-count">0</span> distribution centers</strong>
                            </div>
                        </div>

                        <div id="dc-csv-error" style="color: #d32f2f; margin-top: 15px; padding: 10px; background: #ffebee; border-radius: 4px; display: none;"></div>
                        <div id="dc-csv-success" style="color: #2e7d32; margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;"></div>
                    </div>
                </div>

                <!-- Info Tab -->
                <div class="tab-content" id="info-tab">
                    <div style="padding: 20px; max-width: 1200px; margin: 0 auto;">
                        <h2 style="font-size: 24px; font-weight: 600; color: var(--text-dark); margin-bottom: 20px;">Model Documentation</h2>
                        <p style="color: #666; margin-bottom: 30px;">This page documents all assumptions, parameters, and mathematical formulas used in the distribution network optimization model.</p>

                        <!-- Default Parameters Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin: 0;">Default Parameters</h3>
                                <button id="edit-default-params-btn" style="padding: 8px 16px; background: var(--cel-blue); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 500;">Edit</button>
                            </div>

                            <!-- Display Mode -->
                            <div id="params-display-mode">
                                <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                                    <thead>
                                        <tr style="background: #f8f9fa;">
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Parameter</th>
                                            <th style="padding: 12px; text-align: right; border-bottom: 2px solid #dee2e6;">Value</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Unit</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Description</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">First Mile Rate</td><td id="display-first-mile" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">50</td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/1,000km</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Transport cost from factory to DC</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Mid Mile Rate</td><td id="display-mid-mile" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">100</td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/1,000km</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Transport cost from RDC to Satellite DC</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Last Mile Rate</td><td id="display-last-mile" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">200</td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/1,000km</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Transport cost from DC to customer</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Storage Rate</td><td id="display-storage" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">1400</td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/month</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Warehousing cost per unit</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">DOS</td><td id="display-dio" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">20</td><td style="padding: 10px; border-bottom: 1px solid #eee;">days</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Days of Stock</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">WACC</td><td id="display-wacc" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">10</td><td style="padding: 10px; border-bottom: 1px solid #eee;">%</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Weighted Average Cost of Capital</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Truck Speed</td><td id="display-truck-speed" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">40</td><td style="padding: 10px; border-bottom: 1px solid #eee;">km/h</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Average truck speed for deliveries</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Opening Hours</td><td id="display-opening-hours" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">12</td><td style="padding: 10px; border-bottom: 1px solid #eee;">h/day</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Customer receiving hours per day</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">NSV per Piece</td><td id="display-nsv" style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">47,000</td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Net Sales Value per unit</td></tr>
                                        <tr><td style="padding: 10px;">Earth Radius</td><td style="padding: 10px; text-align: right;">6,371</td><td style="padding: 10px;">km</td><td style="padding: 10px;">Used in Haversine formula (constant)</td></tr>
                                    </tbody>
                                </table>
                            </div>

                            <!-- Edit Mode -->
                            <div id="params-edit-mode" style="display: none;">
                                <table style="width: 100%; border-collapse: collapse; font-size: 14px;">
                                    <thead>
                                        <tr style="background: #f8f9fa;">
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Parameter</th>
                                            <th style="padding: 12px; text-align: right; border-bottom: 2px solid #dee2e6;">Value</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Unit</th>
                                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6;">Description</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">First Mile Rate</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-first-mile" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/1,000km</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Transport cost from factory to DC</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Mid Mile Rate</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-mid-mile" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/1,000km</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Transport cost from RDC to Satellite DC</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Last Mile Rate</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-last-mile" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/1,000km</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Transport cost from DC to customer</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Storage Rate</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-storage" step="0.01" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR/PCS/month</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Warehousing cost per unit</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">DOS</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-dio" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">days</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Days of Stock</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">WACC</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-wacc" step="0.1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">%</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Weighted Average Cost of Capital</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Truck Speed</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-truck-speed" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">km/h</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Average truck speed for deliveries</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">Opening Hours</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-opening-hours" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">h/day</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Customer receiving hours per day</td></tr>
                                        <tr><td style="padding: 10px; border-bottom: 1px solid #eee;">NSV per Piece</td><td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;"><input type="number" id="edit-nsv" step="1" style="width: 80px; padding: 6px; border: 1px solid #ccc; border-radius: 4px; text-align: right;"></td><td style="padding: 10px; border-bottom: 1px solid #eee;">IDR</td><td style="padding: 10px; border-bottom: 1px solid #eee;">Net Sales Value per unit</td></tr>
                                        <tr><td style="padding: 10px;">Earth Radius</td><td style="padding: 10px; text-align: right;">6,371</td><td style="padding: 10px;">km</td><td style="padding: 10px;">Used in Haversine formula (constant)</td></tr>
                                    </tbody>
                                </table>
                                <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
                                    <button id="cancel-params-btn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Cancel</button>
                                    <button id="save-params-btn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Save Changes</button>
                                </div>
                            </div>
                        </div>

                        <!-- Distance Formula Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px;">
                            <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin-bottom: 15px;">Distance Calculation (Haversine Formula)</h3>
                            <p style="color: #666; margin-bottom: 15px;">The great-circle distance between two points on a sphere is calculated using:</p>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                                <p style="font-size: 16px; margin-bottom: 10px;">$$a = \sin^2\left(\frac{\Delta\phi}{2}\right) + \cos(\phi_1) \cdot \cos(\phi_2) \cdot \sin^2\left(\frac{\Delta\lambda}{2}\right)$$</p>
                                <p style="font-size: 16px;">$$d = 2R \cdot \arctan2\left(\sqrt{a}, \sqrt{1-a}\right)$$</p>
                            </div>
                            <p style="color: #666; font-size: 13px;"><strong>Where:</strong> $\phi$ = latitude, $\lambda$ = longitude, $R$ = 6,371 km (Earth's radius)</p>
                            <div style="background: #fff3cd; padding: 12px; border-radius: 4px; margin-top: 15px;">
                                <strong>Sea Crossing Penalty:</strong> Routes between Sumatra (lng &lt; 106¬∞) and Java (lng &gt; 106¬∞) incur a 30% distance penalty (√ó1.3) to account for ferry crossings.
                            </div>
                        </div>

                        <!-- Cost Formulas Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px;">
                            <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin-bottom: 15px;">Cost Formulas</h3>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 20px 0 10px 0;">First Mile Cost (Annual)</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                                <p>$$C_{FM} = \sum_{dc \in \text{ActiveDCs}} d(\text{factory}, dc) \times \text{throughput}_{dc} \times \text{rate}_{FM} \times \frac{12}{1000}$$</p>
                            </div>
                            <div style="background: #e8f5e9; padding: 12px 15px; border-radius: 8px; margin-top: 10px; font-size: 13px;">
                                <strong>Example:</strong> A DC receives 10,000 PCS/month and is 500 km from the factory.<br>
                                $C_{FM} = 500 \times 10{,}000 \times 5.60 \times \frac{12}{1000} = 336{,}000$ IDR/year
                            </div>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 20px 0 10px 0;">Last Mile Cost (Annual)</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                                <p>$$C_{LM} = \sum_{p \in \text{DemandPoints}} d(dc_p, p) \times \text{demand}_p \times \text{rate}_{LM} \times \frac{12}{1000}$$</p>
                            </div>
                            <div style="background: #e8f5e9; padding: 12px 15px; border-radius: 8px; margin-top: 10px; font-size: 13px;">
                                <strong>Example:</strong> A customer with 2,000 PCS/month demand is 100 km from its assigned DC.<br>
                                $C_{LM} = 100 \times 2{,}000 \times 9.60 \times \frac{12}{1000} = 23{,}040$ IDR/year
                            </div>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 20px 0 10px 0;">Mid Mile Cost (Annual) <span style="background: #6b46c1; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; font-weight: normal;">Optional</span></h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                                <p>$$C_{MM} = \sum_{sat \in \text{Satellites}} d(rdc_{sat}, sat) \times \text{throughput}_{sat} \times \text{rate}_{MM} \times \frac{12}{1000}$$</p>
                            </div>
                            <div style="background: #f3e8ff; padding: 12px 15px; border-radius: 8px; margin-top: 10px; font-size: 13px;">
                                <strong>When enabled:</strong> DCs with throughput below threshold (default 10M PCS) are classified as Satellites and receive goods from the nearest RDC instead of directly from the factory.<br>
                                <strong>Example:</strong> A Satellite DC handles 5M PCS/month and is 200 km from its supplying RDC.<br>
                                $C_{MM} = 200 \times 5{,}000{,}000 \times 100 \times \frac{12}{1000} = 1{,}200{,}000{,}000$ IDR/year
                            </div>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 20px 0 10px 0;">Storage Cost (Annual)</h4>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center;">
                                <p>$$C_{Storage} = \sum_{dc \in \text{ActiveDCs}} \left(\frac{\text{Throughput}_{dc} \times DOS}{365}\right) \times \text{rate}_{storage} \times 12$$</p>
                                <p style="font-size: 12px; color: #666; margin-top: 5px;">where Throughput is annual (PCS/year)</p>
                            </div>
                            <div style="background: #e8f5e9; padding: 12px 15px; border-radius: 8px; margin-top: 10px; font-size: 13px;">
                                <strong>Example:</strong> A DC handles 10,000,000 PCS/year with DOS = 30 days.<br>
                                Average inventory $= \frac{10{,}000{,}000 \times 30}{365} = 821{,}918$ PCS<br>
                                $C_{Storage} = 821{,}918 \times 0.30 \times 12 = 2{,}958{,}905$ IDR/year
                            </div>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 20px 0 10px 0;">Total Cost</h4>
                            <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; text-align: center;">
                                <p style="font-size: 18px;">$$C_{Total} = C_{FM} + C_{MM} + C_{LM} + C_{Storage}$$</p>
                                <p style="font-size: 12px; color: #666; margin-top: 5px;">where $C_{MM} = 0$ if mid-mile is disabled</p>
                            </div>
                            <div style="background: #e8f5e9; padding: 12px 15px; border-radius: 8px; margin-top: 10px; font-size: 13px;">
                                <strong>Example:</strong> Using the examples above for a single DC with one customer:<br>
                                $C_{Total} = 336{,}000 + 23{,}040 + 2{,}958{,}905 = 3{,}317{,}945$ IDR/year
                            </div>
                        </div>

                        <!-- Financial Metrics Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px;">
                            <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin-bottom: 15px;">Financial Metrics</h3>

                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 13px; font-weight: 600; color: #333; margin-bottom: 10px;">NSV (Net Sales Value - Annual)</h4>
                                    <p style="text-align: center;">$$NSV = \sum \text{demand} \times 47,000$$</p>
                                    <p style="font-size: 11px; color: #666; text-align: center;">where demand is annual volume (PCS/year)</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 13px; font-weight: 600; color: #333; margin-bottom: 10px;">Cost to NSV Ratio</h4>
                                    <p style="text-align: center;">$$\text{Ratio} = \frac{C_{Total}}{NSV} \times 100\%$$</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 13px; font-weight: 600; color: #333; margin-bottom: 10px;">Unit Cost to Serve</h4>
                                    <p style="text-align: center;">$$\text{UnitCTS} = \frac{C_{Total}}{\sum \text{demand}}$$</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 13px; font-weight: 600; color: #333; margin-bottom: 10px;">Total Stock</h4>
                                    <p style="text-align: center;">$$\text{Stock} = \sum_{dc} \frac{DOS \times \text{Throughput}_{dc}}{365}$$</p>
                                    <p style="font-size: 11px; color: #666; text-align: center;">where Throughput is annual (PCS/year)</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 13px; font-weight: 600; color: #333; margin-bottom: 10px;">IOC (Inventory Carrying Cost)</h4>
                                    <p style="text-align: center;">$$IOC = \text{Stock} \times NSV_{piece} \times WACC$$</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 13px; font-weight: 600; color: #333; margin-bottom: 10px;">Average Lead Time</h4>
                                    <p style="text-align: center;">$$\text{LeadTime (days)} = \frac{1}{n}\sum_{p} \frac{\text{distance}_p}{\text{TruckSpeed} \times \text{OpeningHours}}$$</p>
                                    <p style="font-size: 11px; color: #666; text-align: center; margin-top: 5px;">where TruckSpeed is in km/h and OpeningHours is h/day</p>
                                </div>
                            </div>
                        </div>

                        <!-- Clustering Algorithms Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px;">
                            <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin-bottom: 15px;">Clustering Algorithms</h3>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 15px 0 10px 0;">Weighted K-Means</h4>
                            <p style="color: #666; margin-bottom: 10px;">Centroids are calculated as the demand-weighted average of cluster points:</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 15px;">
                                <p>$$\bar{x}_k = \frac{\sum_{i \in C_k} \text{demand}_i \times x_i}{\sum_{i \in C_k} \text{demand}_i}$$</p>
                            </div>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 15px 0 10px 0;">K-Means++ Initialization</h4>
                            <p style="color: #666; margin-bottom: 10px;">Initial centroids are selected with probability proportional to squared distance and demand:</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center; margin-bottom: 15px;">
                                <p>$$P(x_i) \propto D(x_i)^2 \times \text{demand}_i$$</p>
                            </div>

                            <h4 style="font-size: 14px; font-weight: 600; color: #333; margin: 15px 0 10px 0;">Weighted K-Medoids (PAM)</h4>
                            <p style="color: #666;">Similar to K-Means but centroids are restricted to actual data points (medoids). The swap step minimizes the total weighted distance within each cluster.</p>
                        </div>

                        <!-- Key Assumptions Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px; margin-bottom: 20px;">
                            <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin-bottom: 15px;">Key Assumptions</h3>
                            <ul style="color: #666; line-height: 1.8; padding-left: 20px;">
                                <li><strong>Demand Fulfillment:</strong> All demand must be fulfilled - no service level constraints on maximum distance</li>
                                <li><strong>Factory SLA:</strong> Distribution centers must be within 4,000 km of the nearest active factory</li>
                                <li><strong>Cost Annualization:</strong> Monthly demand is multiplied by 12 for annual cost calculations</li>
                                <li><strong>Inventory Valuation:</strong> Inventory is valued at Net Sales Value (300 IDR/piece)</li>
                                <li><strong>Single Product:</strong> Model assumes a single FMCG product type</li>
                                <li><strong>Customer Assignment:</strong> Each customer is assigned to the nearest active DC (greedy nearest-neighbor)</li>
                                <li><strong>DC Throughput:</strong> No capacity constraints on DCs - throughput equals sum of assigned demand</li>
                                <li><strong>Transport Mode:</strong> Single transport mode with constant speed (500 km/day)</li>
                            </ul>
                        </div>

                        <!-- Optimization Methods Section -->
                        <div style="background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 20px;">
                            <h3 style="font-size: 18px; font-weight: 600; color: var(--cel-blue); margin-bottom: 15px;">Optimization Methods</h3>

                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 10px;">Heuristic</h4>
                                    <p style="color: #666; font-size: 13px;">Activates all DCs within SLA, then iteratively closes DCs if total cost improves. Fast but may find local optima.</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 10px;">Greedy</h4>
                                    <p style="color: #666; font-size: 13px;">Starts with all DCs active, iteratively removes the DC that most reduces cost until no improvement is possible.</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 10px;">HiGHS Solver</h4>
                                    <p style="color: #666; font-size: 13px;">Mixed-integer linear programming solver that finds globally optimal DC selection given the cost model.</p>
                                </div>

                                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
                                    <h4 style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 10px;">GLPK Solver</h4>
                                    <p style="color: #666; font-size: 13px;">Alternative MIP solver using the GNU Linear Programming Kit for optimization.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                tab.classList.add('active');
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(tabName + '-tab').classList.add('active');

                // Redraw maps when switching tabs
                if (tabName === 'new-scenario') {
                    setTimeout(() => {
                        if (mapNewScenario) {
                            mapNewScenario.invalidateSize();
                            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                        }
                    }, 100);
                } else if (tabName === 'analytics') {
                    setTimeout(() => {
                        if (mapAnalytics1) {
                            mapAnalytics1.invalidateSize();
                            renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                        }
                        if (mapAnalytics2 && scenario2) {
                            mapAnalytics2.invalidateSize();
                            renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
                        }
                    }, 100);
                } else if (tabName === 'info') {
                    // Render LaTeX formulas with KaTeX
                    setTimeout(() => {
                        if (typeof renderMathInElement === 'function') {
                            renderMathInElement(document.getElementById('info-tab'), {
                                delimiters: [
                                    {left: '$$', right: '$$', display: true},
                                    {left: '$', right: '$', display: false}
                                ],
                                throwOnError: false
                            });
                        }
                    }, 100);
                }
            });
        });

        // JavaScript code here

        // ===== DEFAULT PARAMETERS =====
        const DEFAULT_FIRST_MILE_RATE = 50;    // IDR/PCS/1,000km
        const DEFAULT_LAST_MILE_RATE = 200;    // IDR/PCS/1,000km
        const DEFAULT_STORAGE_RATE = 1400;     // IDR/PCS/month
        const DEFAULT_DIO = 20;                // DOS (Days of Stock)
        const DEFAULT_TRUCK_SPEED = 40;        // km/h
        const DEFAULT_OPENING_HOURS = 12;      // hours/day
        const DEFAULT_MID_MILE_RATE = 100;     // IDR/PCS/1,000km
        const DEFAULT_MIN_VOLUME_THRESHOLD = 10000000;  // 10M PCS

        // ===== LEAFLET MAP INFRASTRUCTURE =====

        // Indonesia map center and bounds
        const INDONESIA_CENTER = [-2.5, 106.0];
        const INDONESIA_ZOOM = 5;

        // Map instances
        let mapAnalytics1 = null;
        let mapAnalytics2 = null;
        let mapNewScenario = null;
        let mapReference = null;

        // Marker layer groups (for easy clearing/updating)
        let markersAnalytics1 = null;
        let markersAnalytics2 = null;
        let markersNewScenario = null;
        let markersReference = null;

        // Pending click location for popup
        let pendingClickLocation = null;

        // Volume circle visibility
        let showVolumeCircles = false;

        // Custom icon functions
        // Factory icon: Red square when active, gray dashed outline when inactive
        function createFactoryIcon(factory, isActive = true) {
            const size = 24;
            const bgColor = isActive ? '#CB333B' : '#f5f5f5';
            const textColor = isActive ? 'white' : '#999';
            const border = isActive ? '2px solid white' : '2px dashed #999';
            return L.divIcon({
                className: 'factory-icon',
                html: `<div style="background: ${bgColor}; color: ${textColor}; width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: ${border}; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${factory.id ? factory.id.replace('F','') : 'F'}</div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // DC icon: Blue triangle when active, gray dashed outline when inactive
        // Get DC color based on classification type
        function getDCColor(dc) {
            if (!dc.active) return '#f5f5f5';
            switch(dc.dcType) {
                case 'rdc': return '#1a365d';      // Dark blue - RDC (hub supplying satellites)
                case 'direct': return '#2f855a';   // Green - Direct from factory
                case 'satellite': return '#dd6b20'; // Orange - Receives from RDC
                case 'local_rdc': return '#6b46c1'; // Purple - Edge case (warning)
                default: return '#385D7F';          // Default blue
            }
        }

        function createDCIcon(dc, throughput = 0, isActive = true, showVolume = true) {
            // If showVolume is true, size varies by throughput; otherwise fixed size
            const size = isActive
                ? (showVolume ? Math.max(20, Math.min(40, Math.sqrt(throughput) / 8)) : 20)
                : 18;
            const bgColor = getDCColor(dc);
            const labelColor = isActive ? bgColor : '#999';
            // Triangle using CSS borders - outer container includes space for label
            return L.divIcon({
                className: 'dc-icon',
                html: `<div style="position: relative; width: ${size}px; height: ${size + 14}px; display: flex; flex-direction: column; align-items: center;">
                    <div style="position: relative; width: ${size}px; height: ${size}px;">
                        <div style="width: 0; height: 0; border-left: ${size/2}px solid transparent; border-right: ${size/2}px solid transparent; border-bottom: ${size}px solid ${isActive ? 'white' : '#999'}; position: absolute; top: 0; left: 0; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));"></div>
                        <div style="width: 0; height: 0; border-left: ${(size-4)/2}px solid transparent; border-right: ${(size-4)/2}px solid transparent; border-bottom: ${size-4}px solid ${bgColor}; position: absolute; top: 3px; left: 2px;"></div>
                    </div>
                    <span style="color: ${labelColor}; font-size: 9px; font-weight: bold; white-space: nowrap; text-shadow: 0 0 2px white, 0 0 2px white; margin-top: 2px;">${dc.id.replace('DC','')}</span>
                </div>`,
                iconSize: [size, size + 14],
                iconAnchor: [size/2, size]
            });
        }

        // Demand point icon: Light orange circle
        function createDemandIcon(point) {
            const size = 8;
            return L.divIcon({
                className: 'demand-icon',
                html: `<div style="background: #FFB366; width: ${size}px; height: ${size}px; border-radius: 50%; border: 1px solid #FF8C00; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // Clustered demand point icon with cluster color
        function createClusteredDemandIcon(point, clusterColor) {
            const size = 8;
            return L.divIcon({
                className: 'clustered-demand-icon',
                html: `<div style="background: ${clusterColor}; width: ${size}px; height: ${size}px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.3); box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // Centroid icon (triangle) with cluster color and uniform white outline using SVG
        function createCentroidIcon(centroid, clusterIndex, clusterColor) {
            const size = 18;
            return L.divIcon({
                className: 'centroid-icon',
                html: `<div style="display: flex; flex-direction: column; align-items: center;">
                    <svg width="${size}" height="${size}" viewBox="0 0 20 20" style="filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));">
                        <polygon points="10,2 18,18 2,18" fill="${clusterColor}" stroke="white" stroke-width="2" stroke-linejoin="round"/>
                    </svg>
                    <span style="color: ${clusterColor}; font-size: 9px; font-weight: bold; white-space: nowrap; text-shadow: 0 0 2px white, 0 0 2px white; margin-top: 1px;">C${clusterIndex + 1}</span>
                </div>`,
                iconSize: [size, size + 12],
                iconAnchor: [size/2, size]
            });
        }

        // Render clustered view on map
        function renderClusteredView(map, markersLayer, demands, clusteringResult, showLines) {
            if (!map || !markersLayer) return;
            markersLayer.clearLayers();

            const { centroids, assignments } = clusteringResult;

            // Add clustered demand points
            demands.forEach((point, i) => {
                const clusterIdx = assignments[i];
                const color = clusterColors[clusterIdx];
                const icon = createClusteredDemandIcon(point, color);
                const marker = L.marker([point.lat, point.lng], { icon: icon });
                marker.bindPopup(`
                    <b>Demand Point</b><br>
                    Demand: ${point.demand.toLocaleString()} pieces<br>
                    Cluster: ${clusterIdx + 1}
                `);
                markersLayer.addLayer(marker);

                // Draw line to centroid if enabled
                if (showLines && centroids[clusterIdx]) {
                    const centroid = centroids[clusterIdx];
                    const line = L.polyline(
                        [[point.lat, point.lng], [centroid.lat, centroid.lng]],
                        { color: color, weight: 1, opacity: 0.4 }
                    );
                    markersLayer.addLayer(line);
                }
            });

            // Add centroids as triangles
            centroids.forEach((centroid, i) => {
                const color = clusterColors[i];
                const icon = createCentroidIcon(centroid, i, color);
                const marker = L.marker([centroid.lat, centroid.lng], { icon: icon });

                const clusterDemand = demands
                    .filter((_, j) => assignments[j] === i)
                    .reduce((sum, p) => sum + p.demand, 0);
                const clusterSize = demands.filter((_, j) => assignments[j] === i).length;

                marker.bindPopup(`
                    <b>Cluster ${i + 1} Centroid</b><br>
                    Points: ${clusterSize}<br>
                    Total Demand: ${clusterDemand.toLocaleString()} pieces<br>
                    Lat: ${centroid.lat.toFixed(4)}<br>
                    Lng: ${centroid.lng.toFixed(4)}
                    ${centroid.isMedoid ? '<br><i>(Medoid - actual demand location)</i>' : ''}
                `);
                markersLayer.addLayer(marker);
            });

            // Still show factories
            factories.forEach(f => {
                const icon = createFactoryIcon(f, f.active);
                const marker = L.marker([f.lat, f.lng], { icon: icon });
                marker.bindPopup(`<b>${f.name || 'Factory'}</b><br>Status: ${f.active ? 'Active' : 'Inactive'}`);
                markersLayer.addLayer(marker);
            });
        }

        // Clustering map instance
        let clusteringMap = null;
        let clusteringMarkersLayer = null;
        let voronoiLayer = null;

        // Create Voronoi polygons using d3-delaunay
        function createVoronoiPolygons(centroids, bounds) {
            if (!centroids || centroids.length < 2) return [];

            // Convert centroids to points array for Delaunay
            const points = centroids.map(c => [c.lng, c.lat]);

            // Create Delaunay triangulation
            const delaunay = d3.Delaunay.from(points);

            // Create Voronoi diagram with bounds
            const voronoi = delaunay.voronoi([
                bounds.west, bounds.south, bounds.east, bounds.north
            ]);

            // Extract cell polygons
            const polygons = [];
            for (let i = 0; i < centroids.length; i++) {
                const cell = voronoi.cellPolygon(i);
                if (cell) {
                    // Convert [lng, lat] back to [lat, lng] for Leaflet
                    const latLngs = cell.map(pt => [pt[1], pt[0]]);
                    polygons.push({
                        latLngs: latLngs,
                        centroidIndex: i
                    });
                }
            }

            return polygons;
        }

        // Render the embedded clustering map
        function renderClusteringMap() {
            if (!currentClusteringResult) return;

            const container = document.getElementById('clustering-map-container');
            const mapDiv = document.getElementById('clustering-map');
            if (!container || !mapDiv) return;

            // Show the container
            container.style.display = 'block';

            // Initialize map if not already done
            if (!clusteringMap) {
                clusteringMap = L.map('clustering-map', {
                    center: INDONESIA_CENTER,
                    zoom: INDONESIA_ZOOM,
                    zoomControl: true
                });

                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                    attribution: '¬© OpenStreetMap ¬© CARTO',
                    maxZoom: 18
                }).addTo(clusteringMap);

                clusteringMarkersLayer = L.layerGroup().addTo(clusteringMap);
                voronoiLayer = L.layerGroup().addTo(clusteringMap);
            }

            // Clear existing layers
            clusteringMarkersLayer.clearLayers();
            voronoiLayer.clearLayers();

            const { centroids, assignments } = currentClusteringResult;
            const showVoronoi = document.getElementById('show-voronoi').checked;
            const showDemandPoints = document.getElementById('show-demand-points').checked;
            const showLinks = document.getElementById('show-centroid-links').checked;

            // Calculate bounds for Voronoi
            const allPoints = [...newScenarioDemands, ...centroids];
            const lats = allPoints.map(p => p.lat);
            const lngs = allPoints.map(p => p.lng);
            const bounds = {
                north: Math.max(...lats) + 2,
                south: Math.min(...lats) - 2,
                east: Math.max(...lngs) + 2,
                west: Math.min(...lngs) - 2
            };

            // Draw Voronoi tiles
            if (showVoronoi && centroids.length >= 2) {
                const polygons = createVoronoiPolygons(centroids, bounds);
                polygons.forEach(poly => {
                    const color = clusterColors[poly.centroidIndex];
                    const polygon = L.polygon(poly.latLngs, {
                        color: color,
                        weight: 2,
                        fillColor: color,
                        fillOpacity: 0.15
                    });
                    voronoiLayer.addLayer(polygon);
                });
            }

            // Draw demand points
            if (showDemandPoints) {
                newScenarioDemands.forEach((point, i) => {
                    const clusterIdx = assignments[i];
                    const color = clusterColors[clusterIdx];

                    const circle = L.circleMarker([point.lat, point.lng], {
                        radius: 4,
                        fillColor: color,
                        color: color,
                        weight: 1,
                        opacity: 0.8,
                        fillOpacity: 0.6
                    });

                    circle.bindPopup(`
                        <b>Demand Point</b><br>
                        Demand: ${point.demand.toLocaleString()} pieces<br>
                        Cluster: ${clusterIdx + 1}
                    `);

                    clusteringMarkersLayer.addLayer(circle);

                    // Draw link to centroid if enabled
                    if (showLinks && centroids[clusterIdx]) {
                        const centroid = centroids[clusterIdx];
                        const line = L.polyline(
                            [[point.lat, point.lng], [centroid.lat, centroid.lng]],
                            { color: color, weight: 1, opacity: 0.3 }
                        );
                        clusteringMarkersLayer.addLayer(line);
                    }
                });
            }

            // Draw centroids as triangles
            centroids.forEach((centroid, i) => {
                const color = clusterColors[i];
                const icon = createCentroidIcon(centroid, i, color);
                const marker = L.marker([centroid.lat, centroid.lng], { icon: icon });

                const clusterDemand = newScenarioDemands
                    .filter((_, j) => assignments[j] === i)
                    .reduce((sum, p) => sum + p.demand, 0);
                const clusterSize = newScenarioDemands.filter((_, j) => assignments[j] === i).length;

                marker.bindPopup(`
                    <b>Cluster ${i + 1} Centroid</b><br>
                    Points: ${clusterSize}<br>
                    Total Demand: ${clusterDemand.toLocaleString()} pieces<br>
                    Lat: ${centroid.lat.toFixed(4)}<br>
                    Lng: ${centroid.lng.toFixed(4)}
                `);

                clusteringMarkersLayer.addLayer(marker);
            });

            // Fit map to bounds
            clusteringMap.fitBounds([
                [bounds.south + 2, bounds.west + 2],
                [bounds.north - 2, bounds.east - 2]
            ]);

            // Force map resize
            setTimeout(() => {
                clusteringMap.invalidateSize();
            }, 100);
        }

        // Initialize a Leaflet map
        function initLeafletMap(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return null;

            // Check if map already exists
            if (container._leaflet_id) {
                return null; // Already initialized
            }

            const map = L.map(containerId, {
                center: INDONESIA_CENTER,
                zoom: INDONESIA_ZOOM,
                zoomControl: true
            });

            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap ¬© CARTO',
                maxZoom: 18
            }).addTo(map);

            return map;
        }

        // Initialize all maps (called after DOM ready)
        function initAllMaps() {
            // Analytics maps
            mapAnalytics1 = initLeafletMap('map-analytics-1');
            if (mapAnalytics1) {
                markersAnalytics1 = L.layerGroup().addTo(mapAnalytics1);
            }

            mapAnalytics2 = initLeafletMap('map-analytics-2');
            if (mapAnalytics2) {
                markersAnalytics2 = L.layerGroup().addTo(mapAnalytics2);
            }

            // New Scenario map (main interactive map)
            mapNewScenario = initLeafletMap('new-scenario-map');
            if (mapNewScenario) {
                markersNewScenario = L.layerGroup().addTo(mapNewScenario);
                // Ensure scroll wheel zoom is always enabled
                mapNewScenario.scrollWheelZoom.enable();

                // Click to add DC or Factory - show popup
                mapNewScenario.on('click', function(e) {
                    pendingClickLocation = e.latlng;
                    const popup = document.getElementById('map-click-popup');
                    const mapContainer = document.getElementById('new-scenario-map');
                    const mapRect = mapContainer.getBoundingClientRect();
                    const point = mapNewScenario.latLngToContainerPoint(e.latlng);
                    popup.style.left = (mapRect.left + point.x + 10) + 'px';
                    popup.style.top = (mapRect.top + point.y - 30) + 'px';
                    popup.style.display = 'block';
                });
            }

            // Reference map
            mapReference = initLeafletMap('reference-map');
            if (mapReference) {
                markersReference = L.layerGroup().addTo(mapReference);
            }
        }

        // Find nearest active factory to a DC
        function findNearestActiveFactory(dc) {
            const activeFactories = factories.filter(f => f.active);
            if (activeFactories.length === 0) return null;

            let nearest = null;
            let minDist = Infinity;
            activeFactories.forEach(f => {
                const dist = distance(f, dc);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = f;
                }
            });
            return nearest;
        }

        // Render markers on a map
        function renderMapMarkers(map, markersLayer, dcs, demands, interactive = false, midMileEnabled = false) {
            if (!map || !markersLayer) return;

            markersLayer.clearLayers();

            // Add factory markers
            factories.forEach(f => {
                const icon = createFactoryIcon(f, f.active);
                const marker = L.marker([f.lat, f.lng], {icon: icon});

                // Popup content with action buttons for interactive maps
                const popupContent = `
                    <div>
                        <b>${f.name || 'Factory'}</b><br>
                        Status: ${f.active ? 'Active' : 'Inactive'}
                        ${interactive ? `
                            <div style="margin-top: 10px; display: flex; gap: 8px;">
                                <button onclick="window.toggleFactoryFromPopup('${f.id}')" style="padding: 4px 10px; background: ${f.active ? '#ffc107' : '#28a745'}; color: ${f.active ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    ${f.active ? 'Deactivate' : 'Activate'}
                                </button>
                                <button onclick="window.deleteFactoryFromPopup('${f.id}')" style="padding: 4px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
                marker.bindPopup(popupContent);
                markersLayer.addLayer(marker);
            });

            // Add DC markers (size varies by throughput when showVolumeCircles is on)
            // DCs with zero throughput are displayed as inactive (even if dc.active is true)
            dcs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                // Show as inactive if dc.active is false OR if throughput is 0
                const displayAsActive = dc.active && throughput > 0;

                const icon = createDCIcon(dc, throughput, displayAsActive, showVolumeCircles);
                const marker = L.marker([dc.lat, dc.lng], {icon: icon});

                // Popup content with action buttons for interactive maps
                const popupId = `dc-popup-${dc.id}`;
                const statusText = !dc.active ? 'Inactive' : (throughput > 0 ? 'Active' : 'Active (unused)');
                const popupContent = `
                    <div id="${popupId}">
                        <b>${dc.name}</b><br>
                        Status: ${statusText}<br>
                        Throughput: ${throughput.toLocaleString()} pieces
                        ${interactive ? `
                            <div style="margin-top: 10px; display: flex; gap: 8px;">
                                <button onclick="window.toggleDCFromPopup('${dc.id}')" style="padding: 4px 10px; background: ${dc.active ? '#ffc107' : '#28a745'}; color: ${dc.active ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    ${dc.active ? 'Deactivate' : 'Activate'}
                                </button>
                                <button onclick="window.deleteDCFromPopup('${dc.id}')" style="padding: 4px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
                marker.bindPopup(popupContent);

                markersLayer.addLayer(marker);
            });

            // Add demand points as light orange circle markers (always visible)
            demands.forEach(point => {
                const circle = L.circleMarker([point.lat, point.lng], {
                    radius: 4,
                    fillColor: '#FFB366',
                    color: '#FF8C00',
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.7
                });
                circle.bindPopup(`Demand: ${point.demand.toLocaleString()} pieces<br>Cluster: ${point.cluster}`);
                markersLayer.addLayer(circle);
            });

            // Draw flow lines (first mile and last mile)
            const activeDCs = dcs.filter(dc => dc.active);

            // First mile lines (factory to DCs) - clickable with popup
            // Each DC connects to its nearest active factory (only non-satellite when mid-mile enabled)
            activeDCs.forEach(dc => {
                // Skip satellites when mid-mile is enabled (they get supply from RDC)
                if (midMileEnabled && dc.dcType === 'satellite') return;

                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const nearestFactory = findNearestActiveFactory(dc);
                if (throughput > 0 && nearestFactory) {
                    const line = L.polyline([[nearestFactory.lat, nearestFactory.lng], [dc.lat, dc.lng]], {
                        color: '#385D7F',
                        weight: 3,
                        opacity: 0.6
                    });
                    line.bindPopup(`
                        <b>First Mile</b><br>
                        <b>Origin:</b> ${nearestFactory.name}<br>
                        <b>Destination:</b> ${dc.name}<br>
                        <b>Volume:</b> ${throughput.toLocaleString()} PCS/month
                    `);
                    markersLayer.addLayer(line);
                }
            });

            // Mid-mile lines (RDC/DC Direct to Satellite DCs) - purple dashed
            if (midMileEnabled) {
                activeDCs.filter(dc => dc.dcType === 'satellite' && dc.supplierDC).forEach(sat => {
                    const throughput = demands.filter(p => p.assignedDC === sat || p.assignedDCId === sat.id).reduce((sum, p) => sum + p.demand, 0);
                    if (throughput > 0) {
                        const line = L.polyline([[sat.supplierDC.lat, sat.supplierDC.lng], [sat.lat, sat.lng]], {
                            color: '#6b46c1',
                            weight: 2,
                            opacity: 0.6,
                            dashArray: '5, 5'
                        });
                        line.bindPopup(`
                            <b>Mid Mile</b><br>
                            <b>Origin:</b> ${sat.supplierDC.name} (RDC)<br>
                            <b>Destination:</b> ${sat.name} (Satellite)<br>
                            <b>Volume:</b> ${throughput.toLocaleString()} PCS/month
                        `);
                        markersLayer.addLayer(line);
                    }
                });
            }

            // Last mile lines (DCs to demand points) - clickable with popup
            demands.forEach(point => {
                let assignedDC = point.assignedDC;
                if (!assignedDC || !dcs.includes(assignedDC)) {
                    assignedDC = dcs.find(dc => dc.id === point.assignedDCId);
                }
                if (assignedDC && assignedDC.active) {
                    const line = L.polyline([[assignedDC.lat, assignedDC.lng], [point.lat, point.lng]], {
                        color: '#FE5000',
                        weight: 2,
                        opacity: 0.4
                    });
                    line.bindPopup(`
                        <b>Last Mile</b><br>
                        <b>Origin:</b> ${assignedDC.name}<br>
                        <b>Destination:</b> Cluster ${point.cluster}<br>
                        <b>Volume:</b> ${point.demand.toLocaleString()} PCS/month
                    `);
                    markersLayer.addLayer(line);
                }
            });
        }

        // Legacy function names for compatibility
        // Draw map using Leaflet
        function drawMap() {
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (scenario2 && mapAnalytics2 && markersAnalytics2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        }

        // Initialize maps when DOM is ready
        setTimeout(initAllMaps, 100);

        // Model parameters storage key and loader (needed early for calculations)
        const MODEL_PARAMS_STORAGE_KEY = 'eno_model_params';

        function loadModelParams() {
            const saved = localStorage.getItem(MODEL_PARAMS_STORAGE_KEY);
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    console.error('Error loading saved parameters:', e);
                }
            }
            return {
                firstMileRate: DEFAULT_FIRST_MILE_RATE,
                midMileRate: DEFAULT_MID_MILE_RATE,
                lastMileRate: DEFAULT_LAST_MILE_RATE,
                storageRate: DEFAULT_STORAGE_RATE,
                dio: DEFAULT_DIO,
                wacc: 10,
                truckSpeed: DEFAULT_TRUCK_SPEED,
                openingHours: DEFAULT_OPENING_HOURS,
                nsv: 47000
            };
        }

        let modelParams = loadModelParams();

        // Data structures - Indonesia coordinates (lat/lng)
        let demandPoints = [];
        let dcLocations = [];
        let factories = [
            {id: 'F1', name: 'Jatake, Tangerang', lat: -6.1897, lng: 106.5108, active: true}
        ];
        // For backward compatibility
        const factory = factories[0];

        // Scenario storage
        let scenario1 = {
            demandPoints: [],
            dcLocations: JSON.parse(JSON.stringify(dcLocations)),
            name: '0,5_Baseline_2028'
        };
        let scenario2 = null;

        // No default data - user uploads via Data Input container

        // Parse DC data from CSV (lat, lng only - generates names)
        function parseDCsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');

            if (latIdx === -1 || lngIdx === -1) {
                throw new Error('CSV must have columns: lat, lng');
            }

            const dcs = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',').map(v => v.trim());
                const lat = parseFloat(values[latIdx]);
                const lng = parseFloat(values[lngIdx]);

                if (!isNaN(lat) && !isNaN(lng)) {
                    dcs.push({
                        id: `DC${i}`,
                        name: `DC${i}`,
                        lat: lat,
                        lng: lng,
                        active: false
                    });
                }
            }
            return dcs;
        }

        // Parse demand data from CSV
        function parseDemandsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');
            const demandIdx = header.indexOf('demand');

            if (latIdx === -1 || lngIdx === -1 || demandIdx === -1) {
                throw new Error('CSV must have columns: lat, lng, demand');
            }

            const demands = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines

                // Split by comma and reconstruct demand if it contains commas
                const allValues = line.split(',').map(v => v.trim());

                // If we have more than 3 values, the demand column has commas - rejoin them
                let lat, lng, demandStr;
                if (allValues.length === 3) {
                    // Simple case: no commas in numbers
                    lat = parseFloat(allValues[latIdx]);
                    lng = parseFloat(allValues[lngIdx]);
                    demandStr = allValues[demandIdx];
                } else {
                    // Demand has commas - first two are lat/lng, rest is demand
                    lat = parseFloat(allValues[0]);
                    lng = parseFloat(allValues[1]);
                    // Join all remaining parts and remove commas
                    demandStr = allValues.slice(2).join('');
                }

                // Remove any remaining commas from demand string
                const demand = parseFloat(demandStr.replace(/,/g, ''));

                if (isNaN(lat) || isNaN(lng) || isNaN(demand)) {
                    throw new Error(`Invalid data on row ${i + 1}: lat=${allValues[0]}, lng=${allValues[1]}, demand=${demandStr}`);
                }

                demands.push({ lat, lng, demand: Math.round(demand), cluster: i, assignedDC: null, distance: 0 });
            }

            if (demands.length === 0) {
                throw new Error('No valid demand points found in CSV');
            }

            return demands;
        }

        // Parse factory data from CSV
        function parseFactoriesCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');

            if (latIdx === -1 || lngIdx === -1) {
                throw new Error('CSV must have columns: lat, lng');
            }

            const newFactories = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',').map(v => v.trim());
                if (values.length < 2) continue;

                const lat = parseFloat(values[latIdx]);
                const lng = parseFloat(values[lngIdx]);

                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error(`Invalid data on row ${i + 1}: lat=${values[latIdx]}, lng=${values[lngIdx]}`);
                }

                newFactories.push({
                    id: 'F' + i,
                    name: 'Factory ' + i,
                    lat,
                    lng,
                    active: true
                });
            }

            if (newFactories.length === 0) {
                throw new Error('No valid factory locations found in CSV');
            }

            return newFactories;
        }

        // Parse DC data from CSV
        function parseDCsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');

            if (latIdx === -1 || lngIdx === -1) {
                throw new Error('CSV must have columns: lat, lng');
            }

            const newDCs = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',').map(v => v.trim());
                if (values.length < 2) continue;

                const lat = parseFloat(values[latIdx]);
                const lng = parseFloat(values[lngIdx]);

                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error(`Invalid data on row ${i + 1}: lat=${values[latIdx]}, lng=${values[lngIdx]}`);
                }

                newDCs.push({
                    id: 'DC' + i,
                    name: 'DC ' + i,
                    lat,
                    lng,
                    active: true
                });
            }

            if (newDCs.length === 0) {
                throw new Error('No valid DC locations found in CSV');
            }

            return newDCs;
        }

        // Update demand summary display
        function updateDemandSummary() {
            const countEl = document.getElementById('demand-count');
            const volumeEl = document.getElementById('demand-total-volume');
            if (countEl && volumeEl) {
                countEl.textContent = demandPoints.length;
                const totalVol = demandPoints.reduce((sum, p) => sum + p.demand, 0);
                volumeEl.textContent = totalVol.toLocaleString();
            }
            // Update data table
            updateDemandTable();
        }

        // Update factory summary display
        function updateFactorySummary() {
            const countEl = document.getElementById('factory-count');
            if (countEl) {
                countEl.textContent = factories.length;
            }
        }

        // Update DC summary display
        function updateDCSummary() {
            const countEl = document.getElementById('dc-count');
            if (countEl) {
                countEl.textContent = dcLocations.length;
            }
        }

        // Table sorting state
        let tableSortColumn = 'index';
        let tableSortDirection = 'asc';

        // Update demand data table
        function updateDemandTable() {
            const tbody = document.getElementById('demand-table-body');
            if (!tbody) return;

            // Create indexed copy for sorting
            const indexedData = demandPoints.map((p, i) => ({ ...p, originalIndex: i + 1 }));

            // Sort data
            indexedData.sort((a, b) => {
                let valA, valB;
                switch (tableSortColumn) {
                    case 'index': valA = a.originalIndex; valB = b.originalIndex; break;
                    case 'lat': valA = a.lat; valB = b.lat; break;
                    case 'lng': valA = a.lng; valB = b.lng; break;
                    case 'demand': valA = a.demand; valB = b.demand; break;
                    default: valA = a.originalIndex; valB = b.originalIndex;
                }
                return tableSortDirection === 'asc' ? valA - valB : valB - valA;
            });

            tbody.innerHTML = indexedData.map(p => `
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px 10px; color: #666;">${p.originalIndex}</td>
                    <td style="padding: 8px 10px; text-align: right;">${p.lat.toFixed(4)}</td>
                    <td style="padding: 8px 10px; text-align: right;">${p.lng.toFixed(4)}</td>
                    <td style="padding: 8px 10px; text-align: right; font-weight: 500;">${p.demand.toLocaleString()}</td>
                </tr>
            `).join('');

            // Update sort indicators
            document.querySelectorAll('.sortable-header').forEach(header => {
                const arrows = header.querySelector('.sort-arrows');
                const col = header.getAttribute('data-sort');
                if (col === tableSortColumn) {
                    arrows.textContent = tableSortDirection === 'asc' ? '‚Üë' : '‚Üì';
                    arrows.style.color = 'var(--cel-dark-blue)';
                } else {
                    arrows.textContent = '‚Üï';
                    arrows.style.color = '#aaa';
                }
            });
        }

        // Distance calculation - Haversine formula for lat/lng
        function distance(p1, p2) {
            const R = 6371; // Earth radius in km
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLng = (p2.lng - p1.lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            let dist = R * c; // Distance in km

            // Sea crossing penalty: Sumatra (lng < 106) to Java (lng > 106) via Sunda Strait
            const crossesSea = (p1.lng < 106 && p2.lng > 106) || (p1.lng > 106 && p2.lng < 106);
            if (crossesSea) dist *= 1.3; // 30% penalty for sea crossing

            return dist;
        }

        // ===== CLUSTERING FUNCTIONS =====

        // Generate N distinct colors using golden angle distribution
        function generateClusterColors(n) {
            const colors = [];
            const goldenAngle = 137.508; // Golden angle in degrees

            for (let i = 0; i < n; i++) {
                // Hue: Use golden angle distribution for maximum separation
                const hue = (i * goldenAngle) % 360;
                // Saturation: Vary between 65-90% for vibrancy
                const saturation = 65 + (i % 3) * 12.5;
                // Lightness: Vary between 45-60% for visibility
                const lightness = 45 + (i % 4) * 5;

                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }

            return colors;
        }

        // Calculate demand-weighted centroid (center of gravity)
        function calculateWeightedCentroid(clusterPoints) {
            if (clusterPoints.length === 0) return null;

            let sumWeightedLat = 0;
            let sumWeightedLng = 0;
            let totalDemand = 0;

            clusterPoints.forEach(point => {
                sumWeightedLat += point.lat * point.demand;
                sumWeightedLng += point.lng * point.demand;
                totalDemand += point.demand;
            });

            return {
                lat: sumWeightedLat / totalDemand,
                lng: sumWeightedLng / totalDemand,
                totalDemand: totalDemand
            };
        }

        // K-Means++ initialization for better starting centroids
        function initializeCentroidsKMeansPlusPlus(points, k) {
            const centroids = [];

            // First centroid: weighted random selection (favor high-demand points)
            const totalDemand = points.reduce((sum, p) => sum + p.demand, 0);
            let r = Math.random() * totalDemand;
            for (const point of points) {
                r -= point.demand;
                if (r <= 0) {
                    centroids.push({ lat: point.lat, lng: point.lng });
                    break;
                }
            }

            // Remaining centroids: probability proportional to squared distance * demand
            while (centroids.length < k) {
                const distances = points.map(p => {
                    const minDist = Math.min(...centroids.map(c => distance(p, c)));
                    return minDist * minDist * p.demand; // Weight by demand
                });

                const totalWeight = distances.reduce((a, b) => a + b, 0);
                r = Math.random() * totalWeight;

                for (let i = 0; i < points.length; i++) {
                    r -= distances[i];
                    if (r <= 0) {
                        centroids.push({ lat: points[i].lat, lng: points[i].lng });
                        break;
                    }
                }
            }

            return centroids;
        }

        // Weighted K-Means clustering algorithm
        function weightedKMeans(points, k, maxIterations = 100) {
            if (points.length === 0 || k <= 0) return { centroids: [], assignments: [], iterations: 0 };
            if (k > points.length) k = points.length;

            // Initialize centroids using K-Means++ strategy
            let centroids = initializeCentroidsKMeansPlusPlus(points, k);

            let assignments = new Array(points.length).fill(0);
            let changed = true;
            let iterations = 0;

            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;

                // Assignment step: assign each point to nearest centroid
                points.forEach((point, i) => {
                    let minDist = Infinity;
                    let bestCluster = 0;

                    centroids.forEach((centroid, j) => {
                        const dist = distance(point, centroid);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = j;
                        }
                    });

                    if (assignments[i] !== bestCluster) {
                        assignments[i] = bestCluster;
                        changed = true;
                    }
                });

                // Update step: recalculate weighted centroids
                const newCentroids = [];
                for (let j = 0; j < k; j++) {
                    const clusterPoints = points.filter((_, i) => assignments[i] === j);
                    if (clusterPoints.length > 0) {
                        newCentroids.push(calculateWeightedCentroid(clusterPoints));
                    } else {
                        // Keep old centroid for empty clusters
                        newCentroids.push(centroids[j]);
                    }
                }
                centroids = newCentroids;
            }

            return { centroids, assignments, iterations };
        }

        // Weighted K-Medoids clustering algorithm (PAM-like)
        function weightedKMedoids(points, k, maxIterations = 50) {
            if (points.length === 0 || k <= 0) return { centroids: [], assignments: [], iterations: 0 };
            if (k > points.length) k = points.length;

            // Initialize medoids using demand-weighted random selection
            const medoidIndices = [];
            const totalDemand = points.reduce((sum, p) => sum + p.demand, 0);
            const used = new Set();

            while (medoidIndices.length < k) {
                let r = Math.random() * totalDemand;
                for (let i = 0; i < points.length; i++) {
                    if (used.has(i)) continue;
                    r -= points[i].demand;
                    if (r <= 0) {
                        medoidIndices.push(i);
                        used.add(i);
                        break;
                    }
                }
                // Fallback: add any unused point
                if (medoidIndices.length < k && medoidIndices.length === used.size) {
                    for (let i = 0; i < points.length; i++) {
                        if (!used.has(i)) {
                            medoidIndices.push(i);
                            used.add(i);
                            break;
                        }
                    }
                }
            }

            let assignments = new Array(points.length).fill(0);
            let changed = true;
            let iterations = 0;

            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;

                // Assignment step: assign each point to nearest medoid
                points.forEach((point, i) => {
                    let minDist = Infinity;
                    let bestMedoid = 0;

                    medoidIndices.forEach((mi, j) => {
                        const dist = distance(point, points[mi]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestMedoid = j;
                        }
                    });

                    if (assignments[i] !== bestMedoid) {
                        assignments[i] = bestMedoid;
                        changed = true;
                    }
                });

                // Swap step: try to improve each medoid by finding better point in cluster
                for (let j = 0; j < k; j++) {
                    const clusterIndices = points
                        .map((_, i) => i)
                        .filter(i => assignments[i] === j);

                    if (clusterIndices.length === 0) continue;

                    // Find point with minimum weighted total distance to other cluster points
                    let bestCost = Infinity;
                    let bestIndex = medoidIndices[j];

                    clusterIndices.forEach(candidateIdx => {
                        let cost = 0;
                        clusterIndices.forEach(otherIdx => {
                            cost += distance(points[candidateIdx], points[otherIdx]) * points[otherIdx].demand;
                        });

                        if (cost < bestCost) {
                            bestCost = cost;
                            bestIndex = candidateIdx;
                        }
                    });

                    if (bestIndex !== medoidIndices[j]) {
                        medoidIndices[j] = bestIndex;
                        changed = true;
                    }
                }
            }

            // Convert medoid indices to centroid objects
            const centroids = medoidIndices.map((mi, j) => {
                const clusterPoints = points.filter((_, i) => assignments[i] === j);
                const totalClusterDemand = clusterPoints.reduce((sum, p) => sum + p.demand, 0);
                return {
                    lat: points[mi].lat,
                    lng: points[mi].lng,
                    totalDemand: totalClusterDemand,
                    isMedoid: true,
                    sourcePointIndex: mi
                };
            });

            return { centroids, assignments, iterations };
        }

        // ===== END CLUSTERING FUNCTIONS =====

        // Assign customers to DCs
        function assignCustomers() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            demandPoints.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) { // Assign to nearest DC regardless of distance to fulfill all demand
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null; // Store DC ID for cloning
                point.distance = minDist;
            });
        }

        // Assign customers to DCs (for scenario data with separate DC arrays)
        function assignCustomersToScenario(demands, dcs) {
            const activeDCs = dcs.filter(dc => dc.active);
            demands.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null;
                point.distance = minDist;
            });
        }

        // Classify DCs based on throughput threshold for mid-mile tier
        function classifyDCs(dcs, demands, thresholdEnabled, thresholdValue) {
            if (!thresholdEnabled) {
                // All DCs are "direct" when mid-mile disabled
                dcs.forEach(dc => {
                    dc.dcType = 'direct';
                    dc.supplierDC = null;
                    dc.distanceToSupplier = 0;
                });
                return;
            }

            // Step 1: Calculate throughput for each active DC
            const activeDCs = dcs.filter(dc => dc.active);
            activeDCs.forEach(dc => {
                dc.throughput = demands
                    .filter(p => p.assignedDCId === dc.id)
                    .reduce((sum, p) => sum + p.demand, 0);
            });

            // Step 2: Classify based on threshold
            activeDCs.forEach(dc => {
                if (dc.throughput >= thresholdValue) {
                    dc.dcType = 'rdc_candidate';  // Will be RDC or DC Direct
                    dc.supplierDC = null;
                } else {
                    dc.dcType = 'satellite';
                    dc.supplierDC = null;  // To be assigned
                }
            });

            // Step 3: Assign satellites to nearest RDC candidate
            const rdcCandidates = activeDCs.filter(dc => dc.dcType === 'rdc_candidate');
            const satellites = activeDCs.filter(dc => dc.dcType === 'satellite');

            satellites.forEach(sat => {
                let nearestRDC = null;
                let minDist = Infinity;
                rdcCandidates.forEach(rdc => {
                    const dist = distance(sat, rdc);
                    if (dist < minDist) {
                        minDist = dist;
                        nearestRDC = rdc;
                    }
                });
                sat.supplierDC = nearestRDC;
                sat.distanceToSupplier = nearestRDC ? minDist : 0;
            });

            // Step 4: Finalize RDC vs DC Direct classification
            rdcCandidates.forEach(rdc => {
                const hasSatellites = satellites.some(sat => sat.supplierDC === rdc);
                rdc.dcType = hasSatellites ? 'rdc' : 'direct';
            });

            // Inactive DCs get default classification
            dcs.filter(dc => !dc.active).forEach(dc => {
                dc.dcType = 'direct';
                dc.supplierDC = null;
                dc.distanceToSupplier = 0;
            });
        }

        // Calculate costs
        function calculateCosts() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const firstMileRate = DEFAULT_FIRST_MILE_RATE / 1000;
            const lastMileRate = DEFAULT_LAST_MILE_RATE / 1000;
            const storageRate = DEFAULT_STORAGE_RATE;
            const dio = DEFAULT_DIO;
            const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled')?.checked || false;
            const minDCSize = parseInt(document.getElementById('new-min-dc-size')?.value || 500);

            // First mile (each DC connects to nearest active factory)
            activeDCs.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                if (!nearestFactory) return; // No active factories
                const dist = distance(nearestFactory, dc);
                if (dist > 4000) return; // SLA violation, but for now ignore
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate;
            });

            // Last mile and storage
            activeDCs.forEach(dc => {
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                const avgInventory = throughput * (dio / 365);
                // Apply minimum DC size if enabled
                const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                totalStorage += billableInventory * storageRate * 12;
                demandPoints.filter(p => p.assignedDC === dc).forEach(p => {
                    totalTransport += p.distance * p.demand * lastMileRate;
                });
            });

            return {total: totalTransport + totalStorage, transport: totalTransport, storage: totalStorage, activeDCs: activeDCs.length};
        }

        // Draw map using Leaflet
        function drawMap() {
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (scenario2 && mapAnalytics2 && markersAnalytics2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        }

        // Note: Tooltips are now handled by Leaflet popups on markers

        // Optimization function
        function optimize() {
            // Heuristic optimization
            // Step 1: Activate all feasible DCs (distance from nearest active factory <= 4000 km)
            dcLocations.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                dc.active = nearestFactory ? distance(nearestFactory, dc) <= 4000 : false;
            });
            assignCustomers();
            
            // Step 2: Local search - try closing DCs that don't reduce total cost
            let improved = true;
            let iterations = 0;
            while (improved && iterations < 10) { // Limit iterations
                improved = false;
                iterations++;
                const currentCosts = calculateCosts();
                for (let i = 0; i < dcLocations.length; i++) {
                    if (!dcLocations[i].active) continue;
                    // Try closing this DC
                    dcLocations[i].active = false;
                    assignCustomers();
                    const trialCosts = calculateCosts();
                    if (trialCosts.total < currentCosts.total) {
                        // Keep closed
                        improved = true;
                        break; // Accept first improvement
                    } else {
                        // Reopen
                        dcLocations[i].active = true;
                    }
                }
            }
            assignCustomers();
        }

        // ===== MIP SOLVER IMPLEMENTATIONS =====

        // Global solver instances (initialized lazily)
        let highsInstance = null;
        let glpkInstance = null;

        // Initialize HiGHS solver
        async function initHiGHS() {
            if (highsInstance) return highsInstance;
            try {
                // HiGHS from CDN exposes a global 'highs' factory function
                if (typeof highs === 'undefined') {
                    throw new Error('HiGHS library not loaded');
                }
                highsInstance = await highs({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/highs@1.8.0/build/${file}`
                });
                console.log('HiGHS initialized successfully');
                return highsInstance;
            } catch (e) {
                console.error('Failed to initialize HiGHS:', e);
                throw e;
            }
        }

        // Initialize GLPK solver
        async function initGLPK() {
            if (glpkInstance) return glpkInstance;
            try {
                if (typeof GLPK === 'undefined') {
                    throw new Error('GLPK library not loaded');
                }
                glpkInstance = await GLPK();
                console.log('GLPK initialized successfully');
                return glpkInstance;
            } catch (e) {
                console.error('Failed to initialize GLPK:', e);
                throw e;
            }
        }

        // Optimized greedy solver (better than simple heuristic, faster than MIP)
        function optimizeGreedy(targetDCs, targetDemands, params) {
            const { firstMileRate, lastMileRate, storageRate, dio, minDCSizeEnabled, minDCSize } = params;

            // Calculate cost for a given DC configuration
            function calcTotalCost() {
                const activeDCs = targetDCs.filter(dc => dc.active);
                if (activeDCs.length === 0) return Infinity;

                let total = 0;
                targetDemands.forEach(point => {
                    let minDist = Infinity;
                    let bestDC = null;
                    activeDCs.forEach(dc => {
                        const dist = distance(point, dc);
                        if (dist < minDist) {
                            minDist = dist;
                            bestDC = dc;
                        }
                    });
                    if (bestDC) {
                        // Last mile cost
                        total += minDist * point.demand * lastMileRate * 12;
                        point.assignedDC = bestDC;
                        point.distance = minDist;
                    }
                });

                // First mile and storage costs
                activeDCs.forEach(dc => {
                    const throughput = targetDemands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                    const nearestFactory = findNearestActiveFactory(dc);
                    const distFromFactory = nearestFactory ? distance(nearestFactory, dc) : 0;
                    total += distFromFactory * throughput * firstMileRate * 12;
                    const avgInventory = throughput * (dio / 365);
                    // Apply minimum DC size if enabled
                    const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                    total += billableInventory * storageRate * 12;
                });

                return total;
            }

            // Start with all DCs active
            targetDCs.forEach(dc => dc.active = true);
            let bestCost = calcTotalCost();

            // Greedy removal - keep removing DCs while cost improves
            let improved = true;
            while (improved) {
                improved = false;
                let bestRemoval = -1;
                let bestNewCost = bestCost;

                for (let i = 0; i < targetDCs.length; i++) {
                    if (!targetDCs[i].active) continue;

                    targetDCs[i].active = false;
                    const newCost = calcTotalCost();

                    if (newCost < bestNewCost) {
                        bestNewCost = newCost;
                        bestRemoval = i;
                    }

                    targetDCs[i].active = true;
                }

                if (bestRemoval >= 0) {
                    targetDCs[bestRemoval].active = false;
                    bestCost = bestNewCost;
                    improved = true;
                }
            }

            // Final assignment
            calcTotalCost();
        }

        // HiGHS optimization
        async function optimizeWithHiGHS(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = DEFAULT_FIRST_MILE_RATE / 1000;
            const lastMileRate = DEFAULT_LAST_MILE_RATE / 1000;
            const storageRate = DEFAULT_STORAGE_RATE;
            const dio = DEFAULT_DIO;

            try {
                const solver = await initHiGHS();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate assignment costs for each customer to each DC
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const nearestFactory = findNearestActiveFactory(dc);
                        const firstMileDist = nearestFactory ? distance(nearestFactory, dc) : 0;

                        const unitCost = (lastMileDist * lastMileRate +
                                         firstMileDist * firstMileRate +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build LP string
                let lp = 'Minimize\n obj:';
                const terms = [];

                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        terms.push(` ${costs[c][d].toFixed(2)} x${c}_${d}`);
                    }
                }
                lp += terms.join(' +') + '\n';

                lp += 'Subject To\n';

                // Each customer assigned to exactly one DC
                for (let c = 0; c < numCustomers; c++) {
                    const assignTerms = [];
                    for (let d = 0; d < numDCs; d++) {
                        assignTerms.push(`x${c}_${d}`);
                    }
                    lp += ` c${c}: ${assignTerms.join(' + ')} = 1\n`;
                }

                // Linking: x[c,d] <= y[d]
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` l${c}_${d}: x${c}_${d} - y${d} <= 0\n`;
                    }
                }

                lp += 'Binary\n';
                for (let d = 0; d < numDCs; d++) {
                    lp += ` y${d}\n`;
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` x${c}_${d}\n`;
                    }
                }
                lp += 'End\n';

                console.log('Solving with HiGHS...');
                const result = solver.solve(lp);
                console.log('HiGHS result:', result);

                if (result.Status === 'Optimal') {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.Columns[`y${d}`]?.Primal || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.ObjectiveValue };
                } else {
                    throw new Error('HiGHS status: ' + result.Status);
                }
            } catch (e) {
                console.error('HiGHS failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled')?.checked || false;
                const minDCSize = parseInt(document.getElementById('new-min-dc-size')?.value || 500);
                const params = { firstMileRate, lastMileRate, storageRate, dio, minDCSizeEnabled, minDCSize };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // GLPK optimization
        async function optimizeWithGLPK(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = DEFAULT_FIRST_MILE_RATE / 1000;
            const lastMileRate = DEFAULT_LAST_MILE_RATE / 1000;
            const storageRate = DEFAULT_STORAGE_RATE;
            const dio = DEFAULT_DIO;

            try {
                const glpk = await initGLPK();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate costs
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const nearestFactory = findNearestActiveFactory(dc);
                        const firstMileDist = nearestFactory ? distance(nearestFactory, dc) : 0;

                        const unitCost = (lastMileDist * lastMileRate +
                                         firstMileDist * firstMileRate +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build objective
                const objective = [];
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        objective.push({ name: `x${c}_${d}`, coef: costs[c][d] });
                    }
                }

                // Build constraints
                const subjectTo = [];

                // Assignment constraints
                for (let c = 0; c < numCustomers; c++) {
                    const vars = [];
                    for (let d = 0; d < numDCs; d++) {
                        vars.push({ name: `x${c}_${d}`, coef: 1 });
                    }
                    subjectTo.push({
                        name: `assign${c}`,
                        vars: vars,
                        bnds: { type: glpk.GLP_FX, lb: 1, ub: 1 }
                    });
                }

                // Linking constraints
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        subjectTo.push({
                            name: `link${c}_${d}`,
                            vars: [
                                { name: `x${c}_${d}`, coef: 1 },
                                { name: `y${d}`, coef: -1 }
                            ],
                            bnds: { type: glpk.GLP_UP, lb: 0, ub: 0 }
                        });
                    }
                }

                // Binary variables list
                const binaries = [];
                for (let d = 0; d < numDCs; d++) {
                    binaries.push(`y${d}`);
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        binaries.push(`x${c}_${d}`);
                    }
                }

                const model = {
                    name: 'FacilityLocation',
                    objective: {
                        direction: glpk.GLP_MIN,
                        name: 'cost',
                        vars: objective
                    },
                    subjectTo: subjectTo,
                    binaries: binaries
                };

                console.log('Solving with GLPK...');
                const result = await glpk.solve(model, { msglev: glpk.GLP_MSG_OFF });
                console.log('GLPK result:', result);

                if (result.result.status === glpk.GLP_OPT) {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.result.vars[`y${d}`] || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.result.z };
                } else {
                    throw new Error('GLPK status: ' + result.result.status);
                }
            } catch (e) {
                console.error('GLPK failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled')?.checked || false;
                const minDCSize = parseInt(document.getElementById('new-min-dc-size')?.value || 500);
                const params = { firstMileRate, lastMileRate, storageRate, dio, minDCSizeEnabled, minDCSize };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // Unified optimization function that uses selected solver
        async function runOptimization(solver = 'heuristic') {
            const startTime = performance.now();
            let result;

            try {
                if (solver === 'heuristic') {
                    optimize();
                    result = { success: true };
                } else if (solver === 'highs') {
                    result = await optimizeWithHiGHS();
                } else if (solver === 'glpk') {
                    result = await optimizeWithGLPK();
                }
            } catch (e) {
                console.error('Optimization error:', e);
                alert('Optimization failed: ' + e.message);
                result = { success: false };
            }

            const endTime = performance.now();
            const solveTime = Math.round(endTime - startTime);

            return { ...result, solveTime, solver };
        }

        // Update results
        let comparisonScenario = null;

        // Helper function to generate metrics HTML
        function generateMetricsHTML(dcs, demands, scenarioName, params = null) {
            // Calculate costs for this scenario
            const activeDCs = dcs.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;

            // Use provided params or get from settings inputs (rates in IDR/PCS/1000km, divide by 1000)
            const firstMileRate = (params?.firstMile || DEFAULT_FIRST_MILE_RATE) / 1000;
            const lastMileRate = (params?.lastMile || DEFAULT_LAST_MILE_RATE) / 1000;
            const storageRate = params?.storage || DEFAULT_STORAGE_RATE;
            const dio = params?.dio || DEFAULT_DIO;
            const minDCSizeEnabled = params?.minDCSizeEnabled !== undefined ? params.minDCSizeEnabled : document.getElementById('new-min-dc-size-enabled')?.checked;
            const minDCSize = params?.minDCSize !== undefined ? params.minDCSize : parseInt(document.getElementById('new-min-dc-size')?.value || 500);

            // First mile (each DC connects to nearest active factory)
            activeDCs.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                const dist = nearestFactory ? distance(nearestFactory, dc) : 0;
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate * 12;
            });

            // Last mile & storage
            demands.forEach(point => {
                if (point.assignedDC || point.assignedDCId) {
                    totalTransport += point.distance * point.demand * lastMileRate * 12;
                }
            });

            activeDCs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const avgInventory = throughput * (dio / 365);
                // Apply minimum DC size if enabled
                const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                totalStorage += billableInventory * storageRate * 12;
            });

            const costs = {
                total: totalTransport + totalStorage,
                transport: totalTransport,
                storage: totalStorage,
                activeDCs: activeDCs.length
            };

            // Calculate total demand (monthly)
            const totalDemand = demands.reduce((sum, p) => sum + p.demand, 0);

            // FMCG Product Structure:
            // NSV per piece from model params (demand is already annual)
            const nsvPerPiece = modelParams.nsv || 47000;
            const nsv = totalDemand * nsvPerPiece;
            const costPerNSV = costs.total / nsv;

            // Calculate unit cost to serve
            const unitCostToServe = costs.total / totalDemand;

            // Calculate lead time: distance / truckSpeed / openingHours (in days)
            const truckSpeed = modelParams.truckSpeed || DEFAULT_TRUCK_SPEED;
            const openingHours = modelParams.openingHours || DEFAULT_OPENING_HOURS;
            const avgLeadTime = demands.reduce((sum, p) => sum + ((p.distance || 0) / truckSpeed / openingHours), 0) / demands.length;

            // Calculate total stock: sum for each DC of (DOS * annual throughput)/365
            let totalStock = 0;
            activeDCs.forEach(dc => {
                const monthlyThroughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const annualThroughput = monthlyThroughput * 12;
                totalStock += (dio * annualThroughput) / 365;
            });

            // Calculate DOS - should equal the input DOS parameter
            const calculatedDOS = dio;

            // Calculate IOC: average inventory value * WACC (10%)
            // Average inventory value = total stock (pieces) * NSV per piece
            const avgInventoryValue = totalStock * nsvPerPallet;
            const ioc = avgInventoryValue * 0.10;

            return `
                <div class="metric-card">
                    <div class="metric-label">Number DCs</div>
                    <div class="metric-sublabel">-</div>
                    <div class="metric-value">${costs.activeDCs}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost per NSV</div>
                    <div class="metric-sublabel">Ratio</div>
                    <div class="metric-value">${(costPerNSV * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales Value</div>
                    <div class="metric-sublabel">(B IDR)</div>
                    <div class="metric-value">${(nsv / 1000000000).toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales</div>
                    <div class="metric-sublabel">Volume</div>
                    <div class="metric-value">${Math.round(totalDemand / 1000)}</div>
                    <div class="metric-sublabel" style="margin-top:5px">(k Pallets)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost-to-Serve</div>
                    <div class="metric-sublabel">(B IDR)</div>
                    <div class="metric-value">${(costs.total / 1000000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Unit CTS</div>
                    <div class="metric-sublabel">(IDR/PCS)</div>
                    <div class="metric-value">${Math.round(unitCostToServe).toLocaleString()}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">IOC</div>
                    <div class="metric-sublabel">(B IDR)</div>
                    <div class="metric-value">${(ioc / 1000000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">DOS</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${calculatedDOS.toFixed(0)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Lead Time</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${avgLeadTime.toFixed(2)}</div>
                </div>
            `;
        }

        function updateResults() {
            const costs = calculateCosts();

            // Update scenario 1
            document.getElementById('scenario-label-1').textContent = scenario1.name;
            document.getElementById('metrics-grid-1').innerHTML = generateMetricsHTML(
                scenario1.dcLocations,
                scenario1.demandPoints,
                scenario1.name
            );

            // Update scenario 2 if exists
            if (scenario2) {
                document.getElementById('scenario-2-section').style.display = 'block';
                document.getElementById('map-container-analytics-2').style.display = 'block';
                document.getElementById('map-comparison-container').classList.add('two-scenarios');
                document.getElementById('scenario-label-2').textContent = scenario2.name;
                document.getElementById('metrics-grid-2').innerHTML = generateMetricsHTML(
                    scenario2.dcLocations,
                    scenario2.demandPoints,
                    scenario2.name
                );

                // Invalidate Leaflet map sizes after making them visible
                setTimeout(() => {
                    if (mapAnalytics1) mapAnalytics1.invalidateSize();
                    if (mapAnalytics2) mapAnalytics2.invalidateSize();
                    // Force redraw of both maps
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }
                    if (mapAnalytics2 && markersAnalytics2) {
                        renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
                    }
                }, 50);
            } else {
                document.getElementById('scenario-2-section').style.display = 'none';
                document.getElementById('map-container-analytics-2').style.display = 'none';
                document.getElementById('map-comparison-container').classList.remove('two-scenarios');
                // Clear the second map markers
                if (markersAnalytics2) markersAnalytics2.clearLayers();
            }

            // Update charts
            updateCharts(costs);
        }

        // Draw charts
        function updateCharts(costs) {
            // Sample data for waterfall chart effect
            const firstMileCost = costs.transport * 0.52; // Estimate
            const storageCost = costs.storage;
            const lastMileCost = costs.transport * 0.48;

            // Absolute chart
            const absoluteCanvas = document.getElementById('absolute-chart');
            const absCtx = absoluteCanvas.getContext('2d');
            absCtx.clearRect(0, 0, absoluteCanvas.width, absoluteCanvas.height);

            // Draw bars for absolute cost
            const maxCost = costs.total;
            const barWidth = 80;
            const spacing = 50;
            const chartHeight = 250;
            const baseY = 270;

            // First mile
            const fm_height = (firstMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50, baseY - fm_height, barWidth, fm_height);
            absCtx.fillStyle = '#2D3748';
            absCtx.font = '14px Arial';
            absCtx.textAlign = 'center';
            absCtx.fillText(Math.round(firstMileCost / 1000) + 'M', 90, baseY - fm_height - 5);

            // Storage (stacked on first mile)
            const st_height = (storageCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + barWidth + spacing, baseY - fm_height - st_height, barWidth, fm_height + st_height);
            absCtx.fillText(Math.round((firstMileCost + storageCost) / 1000) + 'M', 90 + barWidth + spacing, baseY - fm_height - st_height - 5);

            // Last mile (stacked on storage)
            const lm_height = (lastMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight, barWidth, costs.total / maxCost * chartHeight);
            absCtx.fillText(Math.round(costs.total / 1000) + 'M', 90 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight - 5);

            // Relative chart (cost per piece)
            const relativeCanvas = document.getElementById('relative-chart');
            const relCtx = relativeCanvas.getContext('2d');
            relCtx.clearRect(0, 0, relativeCanvas.width, relativeCanvas.height);

            const totalDemand = demandPoints.reduce((sum, p) => sum + p.demand, 0);
            const fm_per_pallet = firstMileCost / totalDemand;
            const st_per_pallet = storageCost / totalDemand;
            const lm_per_pallet = lastMileCost / totalDemand;
            const total_per_pallet = costs.total / totalDemand;

            const maxPerPallet = total_per_pallet;

            // First mile
            const fm_height_rel = (fm_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50, baseY - fm_height_rel, barWidth, fm_height_rel);
            relCtx.fillStyle = '#2D3748';
            relCtx.font = '14px Arial';
            relCtx.textAlign = 'center';
            relCtx.fillText(Math.round(fm_per_pallet), 90, baseY - fm_height_rel - 5);

            // Storage (stacked)
            const st_height_rel = (st_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + barWidth + spacing, baseY - fm_height_rel - st_height_rel, barWidth, fm_height_rel + st_height_rel);
            relCtx.fillText(Math.round(fm_per_pallet + st_per_pallet), 90 + barWidth + spacing, baseY - fm_height_rel - st_height_rel - 5);

            // Last mile (stacked)
            const total_height_rel = (total_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - total_height_rel, barWidth, total_height_rel);
            relCtx.fillText(Math.round(total_per_pallet), 90 + (barWidth + spacing) * 2, baseY - total_height_rel - 5);
        }

        // Initialize - set up the app (no default data, user uploads via Data Input)
        function initializeApp() {
            // Start with empty data - user will upload via Data Input container
            updateDemandSummary();
            updateFactorySummary();
            updateDCSummary();

            drawMap();
        }
        initializeApp();

        // Load saved scenarios into all dropdowns
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('dno-scenario-')) {
                const name = key.replace('dno-scenario-', '');
                ['scenario-select-1', 'scenario-select-2', 'scenario-select-3'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    }
                });
            }
        }

        // DC list and Parameters removed (now managed in New Scenario tab)

        // Solver and run mode handling
        let selectedSolver = 'highs';
        let runMode = 'auto';
        let autoRunTimeout = null;
        let isOptimizing = false;

        const solverNames = {
            'heuristic': 'Heuristic',
            'highs': 'HiGHS',
            'glpk': 'GLPK'
        };

        // Run mode selector handler
        document.getElementById('run-mode-select').addEventListener('change', function() {
            runMode = this.value;
            const runBtn = document.getElementById('run-new-optimization');
            if (runMode === 'manual') {
                runBtn.style.display = 'inline-block';
            } else {
                runBtn.style.display = 'none';
                // Trigger auto-run when switching to auto mode
                triggerAutoRun();
            }
        });

        // Solver selector handler
        document.getElementById('solver-select').addEventListener('change', function() {
            selectedSolver = this.value;
            if (runMode === 'auto') {
                triggerAutoRun();
            }
        });

        // Auto-run trigger (debounced)
        function triggerAutoRun() {
            if (runMode !== 'auto') return;
            if (autoRunTimeout) clearTimeout(autoRunTimeout);
            autoRunTimeout = setTimeout(() => {
                runOptimization(false); // false = don't add to feed
            }, 300);
        }

        // Update live indicators
        function updateLiveIndicators(costs, demandPoints, dcLocations) {
            // Calculate additional metrics
            // Demand in data is annual volume, NSV per piece from model params
            const totalDemand = demandPoints.reduce((sum, p) => sum + p.demand, 0);
            const nsvPerPiece = (typeof modelParams !== 'undefined' && modelParams.nsv) ? modelParams.nsv : 47000;
            const nsv = totalDemand * nsvPerPiece;
            const costPerNSV = costs.total / nsv;
            const unitCostToServe = costs.total / totalDemand;
            const dio = parseFloat(document.getElementById('new-dio').value) || 30;
            // Lead time = distance / truckSpeed / openingHours (in days)
            const truckSpeed = modelParams.truckSpeed || DEFAULT_TRUCK_SPEED;
            const openingHours = modelParams.openingHours || DEFAULT_OPENING_HOURS;
            const avgLeadTime = demandPoints.reduce((sum, p) => sum + ((p.distance || 0) / truckSpeed / openingHours), 0) / demandPoints.length;

            // Update metric card values (costs are in IDR, display in billions)
            document.getElementById('live-total-cost').textContent = (costs.total / 1000000000).toFixed(1);
            document.getElementById('live-transport-cost').textContent = (costs.transport / 1000000000).toFixed(1);
            document.getElementById('live-storage-cost').textContent = (costs.storage / 1000000000).toFixed(1);
            document.getElementById('live-active-dcs').textContent = costs.activeDCs;
            // Show more precision for small percentages
            const costPerNSVPercent = costPerNSV * 100;
            document.getElementById('live-cost-per-nsv').textContent = costPerNSVPercent < 0.01 ? costPerNSVPercent.toFixed(4) + '%' : costPerNSVPercent.toFixed(2) + '%';
            document.getElementById('live-unit-cost').textContent = Math.round(unitCostToServe).toLocaleString();
            document.getElementById('live-dio').textContent = dio;
            document.getElementById('live-lead-time').textContent = avgLeadTime.toFixed(2);
        }

        // Run optimization and Save scenario buttons removed (now in New Scenario tab)

        // Helper function to load a scenario
        function loadScenario(scenarioValue, scenarioName) {
            const tempDcLocations = JSON.parse(JSON.stringify(dcLocations));
            const tempDemandPoints = JSON.parse(JSON.stringify(demandPoints));

            if (scenarioValue === 'baseline') {
                tempDcLocations.forEach((dc, i) => dc.active = [0,2,4,6,8].includes(i));
            } else {
                // Load saved scenario
                const savedScenario = JSON.parse(localStorage.getItem('dno-scenario-' + scenarioValue));
                if (savedScenario) {
                    tempDcLocations.forEach((dc, i) => dc.active = savedScenario.dcActive[i]);
                    savedScenario.demands.forEach((d, i) => {
                        if (tempDemandPoints[i]) tempDemandPoints[i].demand = d.demand;
                    });
                }
            }

            // Assign customers for temp data using the scenario-specific function
            assignCustomersToScenario(tempDemandPoints, tempDcLocations);

            return {
                demandPoints: tempDemandPoints,
                dcLocations: tempDcLocations,
                name: scenarioName
            };
        }

        // Scenario select handlers
        const select1 = document.getElementById('scenario-select-1');
        const select2 = document.getElementById('scenario-select-2');

        select1.addEventListener('change', (e) => {
            if (e.target.value === '') return;
            const scenarioName = select1.options[select1.selectedIndex].text;
            scenario1 = loadScenario(e.target.value, scenarioName);

            // Update current working state
            dcLocations = JSON.parse(JSON.stringify(scenario1.dcLocations));
            demandPoints = JSON.parse(JSON.stringify(scenario1.demandPoints));

            // Update DC checkboxes
            dcLocations.forEach(dc => {
                const checkbox = document.getElementById(dc.id);
                if (checkbox) checkbox.checked = dc.active;
            });

            drawMap();
            updateResults();
        });

        select2.addEventListener('change', (e) => {
            if (e.target.value === '') {
                scenario2 = null;
            } else {
                const scenarioName = select2.options[select2.selectedIndex].text;
                scenario2 = loadScenario(e.target.value, scenarioName);
            }

            drawMap();
            updateResults();
        });

        // ===== NEW SCENARIO TAB IMPLEMENTATION =====

        // New working state for scenario creator (will be initialized after data loads)
        let newScenarioDCs = [];
        let newScenarioDemands = [];
        let scenarioFeedCounter = 0;

        // Clustering state
        let currentClusteringResult = null;  // { centroids, assignments, iterations }
        let clusterColors = [];              // Array of HSL color strings
        let isClusteredViewActive = false;   // Toggle state

        // Initialize DC list for new scenario creator
        const newDCList = document.getElementById('new-dc-list');

        // Function to update the DC list UI
        function updateNewScenarioDCList() {
            reinitializeNewScenarioCheckboxes();
        }

        // Function to reinitialize DC checkboxes with current newScenarioDCs array
        function reinitializeNewScenarioCheckboxes() {
            // Clear existing checkboxes
            newDCList.innerHTML = '';

            // Create new checkboxes linked to current newScenarioDCs
            newScenarioDCs.forEach(dc => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; font-size: 13px;';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'new-' + dc.id;
                checkbox.checked = dc.active;
                checkbox.style.marginRight = '8px';
                checkbox.addEventListener('change', () => {
                    dc.active = checkbox.checked;
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    triggerAutoRun();
                });
                const label = document.createElement('label');
                label.htmlFor = 'new-' + dc.id;
                label.textContent = dc.name;
                div.appendChild(checkbox);
                div.appendChild(label);
                newDCList.appendChild(div);
            });
        }

        // Initial checkbox setup
        reinitializeNewScenarioCheckboxes();

        // Select All button handler
        document.getElementById('select-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = true);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        });

        // Clear All button handler
        document.getElementById('clear-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = false);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        });

        // Min DC Size checkbox handler
        document.getElementById('new-min-dc-size-enabled').addEventListener('change', function() {
            const minDCSizeInput = document.getElementById('new-min-dc-size');
            if (this.checked) {
                minDCSizeInput.disabled = false;
                minDCSizeInput.style.background = 'white';
            } else {
                minDCSizeInput.disabled = true;
                minDCSizeInput.style.background = '#f5f5f5';
            }
            triggerAutoRun();
        });

        // Mid-Mile checkbox handler
        document.getElementById('new-mid-mile-enabled').addEventListener('change', function() {
            const thresholdInput = document.getElementById('new-min-volume-threshold');
            const rateInput = document.getElementById('new-mid-mile-rate');
            const legend = document.getElementById('dc-type-legend');
            if (this.checked) {
                thresholdInput.disabled = false;
                thresholdInput.style.background = 'white';
                rateInput.disabled = false;
                rateInput.style.background = 'white';
                if (legend) legend.style.display = 'block';
            } else {
                thresholdInput.disabled = true;
                thresholdInput.style.background = '#f5f5f5';
                rateInput.disabled = true;
                rateInput.style.background = '#f5f5f5';
                if (legend) legend.style.display = 'none';
            }
            triggerAutoRun();
        });

        // Parameter input change handlers for auto-run
        ['new-first-mile-rate', 'new-last-mile-rate', 'new-storage-rate', 'new-dio', 'new-min-dc-size', 'new-min-volume-threshold', 'new-mid-mile-rate'].forEach(id => {
            document.getElementById(id).addEventListener('change', triggerAutoRun);
        });

        // Global function to toggle DC active state from popup
        window.toggleDCFromPopup = function(dcId) {
            // Find DC in newScenarioDCs and toggle
            const dc = newScenarioDCs.find(d => d.id === dcId);
            if (dc) {
                dc.active = !dc.active;
                // Also update in dcLocations if present
                const mainDC = dcLocations.find(d => d.id === dcId);
                if (mainDC) mainDC.active = dc.active;
                // Close popup and refresh
                mapNewScenario.closePopup();
                updateNewScenarioDCList();
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                triggerAutoRun();
            }
        };

        // Global function to delete DC from popup
        window.deleteDCFromPopup = function(dcId) {
            // Remove from dcLocations
            const idx = dcLocations.findIndex(d => d.id === dcId);
            if (idx > -1) {
                dcLocations.splice(idx, 1);
            }
            // Remove from newScenarioDCs
            const nsIdx = newScenarioDCs.findIndex(d => d.id === dcId);
            if (nsIdx > -1) {
                newScenarioDCs.splice(nsIdx, 1);
            }
            // Close popup and refresh
            mapNewScenario.closePopup();
            updateNewScenarioDCList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        };

        // Helper function to add a new DC
        function addNewDC(lat, lng) {
            const newId = 'DC' + (dcLocations.length + 1);
            const newDC = {
                id: newId,
                name: 'New DC ' + (dcLocations.length + 1),
                lat: lat,
                lng: lng,
                active: true
            };
            dcLocations.push(newDC);
            newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
            updateNewScenarioDCList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        }

        // Helper function to add a new Factory
        function addNewFactory(lat, lng) {
            const newId = 'F' + (factories.length + 1);
            const newFactory = {
                id: newId,
                name: 'Factory ' + (factories.length + 1),
                lat: lat,
                lng: lng,
                active: true
            };
            factories.push(newFactory);
            updateFactoryList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        }

        // Global function to toggle Factory active state from popup
        window.toggleFactoryFromPopup = function(factoryId) {
            const f = factories.find(f => f.id === factoryId);
            if (f) {
                f.active = !f.active;
                mapNewScenario.closePopup();
                updateFactoryList();
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                triggerAutoRun();
            }
        };

        // Global function to delete Factory from popup
        window.deleteFactoryFromPopup = function(factoryId) {
            const idx = factories.findIndex(f => f.id === factoryId);
            if (idx > -1) {
                factories.splice(idx, 1);
            }
            mapNewScenario.closePopup();
            updateFactoryList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        };

        // Update Factory list in UI
        function updateFactoryList() {
            const list = document.getElementById('new-factory-list');
            if (!list) return;
            list.innerHTML = '';
            factories.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 4px 0;';
                item.innerHTML = `
                    <input type="checkbox" id="factory-${f.id}" ${f.active ? 'checked' : ''} style="cursor: pointer;">
                    <label for="factory-${f.id}" style="cursor: pointer; font-size: 13px; ${f.active ? '' : 'color: #999;'}">${f.name}</label>
                `;
                const checkbox = item.querySelector('input');
                checkbox.addEventListener('change', () => {
                    f.active = checkbox.checked;
                    updateFactoryList();
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    triggerAutoRun();
                });
                list.appendChild(item);
            });
        }

        // Map click popup handlers
        document.getElementById('popup-add-dc').addEventListener('click', function() {
            if (pendingClickLocation) {
                addNewDC(pendingClickLocation.lat, pendingClickLocation.lng);
                pendingClickLocation = null;
            }
            document.getElementById('map-click-popup').style.display = 'none';
        });

        document.getElementById('popup-add-factory').addEventListener('click', function() {
            if (pendingClickLocation) {
                addNewFactory(pendingClickLocation.lat, pendingClickLocation.lng);
                pendingClickLocation = null;
            }
            document.getElementById('map-click-popup').style.display = 'none';
        });

        document.getElementById('popup-cancel').addEventListener('click', function() {
            pendingClickLocation = null;
            document.getElementById('map-click-popup').style.display = 'none';
        });

        // Close popup when clicking elsewhere
        document.addEventListener('click', function(e) {
            const popup = document.getElementById('map-click-popup');
            if (popup.style.display === 'block' && !popup.contains(e.target)) {
                // Check if click is on the map
                const mapContainer = document.getElementById('new-scenario-map');
                if (!mapContainer.contains(e.target)) {
                    popup.style.display = 'none';
                    pendingClickLocation = null;
                }
            }
        });

        // Initialize factory list
        updateFactoryList();

        // Volume circles toggle handler
        document.getElementById('show-volume-circles').addEventListener('change', function() {
            showVolumeCircles = this.checked;
            // Re-render all visible maps
            if (mapNewScenario && markersNewScenario) {
                // Check if clustered view is active - if so, use clustered rendering
                if (isClusteredViewActive && currentClusteringResult) {
                    const showLinks = document.getElementById('show-centroid-links').checked;
                    renderClusteredView(mapNewScenario, markersNewScenario, newScenarioDemands,
                                       currentClusteringResult, showLinks);
                } else {
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                }
            }
            if (mapAnalytics1 && markersAnalytics1 && scenario1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (mapAnalytics2 && markersAnalytics2 && scenario2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        });

        // Initial assignment and draw for new scenario
        assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
        setTimeout(() => {
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            // Initial auto-run
            triggerAutoRun();
        }, 200);

        // Store preloaded scenario state for reset functionality
        let preloadedState = null;

        // Preload scenario handler
        document.getElementById('preload-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                preloadedState = null;
                document.getElementById('reset-to-preloaded').style.display = 'none';
                return;
            }

            const preloadScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Update DCs
            newScenarioDCs = JSON.parse(JSON.stringify(preloadScenario.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadScenario.demandPoints));

            // Store preloaded state for reset
            preloadedState = {
                dcLocations: JSON.parse(JSON.stringify(preloadScenario.dcLocations)),
                demandPoints: JSON.parse(JSON.stringify(preloadScenario.demandPoints)),
                firstMileRate: DEFAULT_FIRST_MILE_RATE,
                lastMileRate: DEFAULT_LAST_MILE_RATE,
                storageRate: DEFAULT_STORAGE_RATE,
                dio: DEFAULT_DIO,
                minDCSizeEnabled: document.getElementById('new-min-dc-size-enabled').checked,
                minDCSize: document.getElementById('new-min-dc-size').value
            };

            // Reinitialize checkboxes with new DC array
            reinitializeNewScenarioCheckboxes();

            // Update parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;
            document.getElementById('new-min-dc-size-enabled').checked = preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').value = preloadedState.minDCSize;
            document.getElementById('new-min-dc-size').disabled = !preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').style.background = preloadedState.minDCSizeEnabled ? 'white' : '#f5f5f5';

            // Show reset button
            document.getElementById('reset-to-preloaded').style.display = 'block';

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Reset to preloaded handler
        document.getElementById('reset-to-preloaded').addEventListener('click', () => {
            if (!preloadedState) return;

            // Restore preloaded state
            newScenarioDCs = JSON.parse(JSON.stringify(preloadedState.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadedState.demandPoints));

            // Reinitialize checkboxes with restored DC array
            reinitializeNewScenarioCheckboxes();

            // Restore parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;
            document.getElementById('new-min-dc-size-enabled').checked = preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').value = preloadedState.minDCSize;
            document.getElementById('new-min-dc-size').disabled = !preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').style.background = preloadedState.minDCSizeEnabled ? 'white' : '#f5f5f5';

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Store last optimization result for Quick Save
        let lastOptimizationResult = null;

        // Main optimization function
        async function runOptimization(addToFeed = true) {
            if (isOptimizing) return;
            isOptimizing = true;

            const btn = document.getElementById('run-new-optimization');
            const runTimeIndicator = document.getElementById('run-time-indicator');
            if (btn) {
                btn.disabled = true;
            }
            // Show spinner in the indicator area
            if (runTimeIndicator) {
                runTimeIndicator.innerHTML = '<span class="spinner" style="border-color: rgba(56,93,127,0.3); border-top-color: var(--cel-blue);"></span>Optimizing...';
                runTimeIndicator.style.display = 'inline-flex';
                runTimeIndicator.style.alignItems = 'center';
            }

            // Small delay to allow UI to render the spinner before heavy computation
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const solver = selectedSolver;

                // Get parameters
                const firstMile = parseFloat(document.getElementById('new-first-mile-rate').value);
                const lastMile = parseFloat(document.getElementById('new-last-mile-rate').value);
                const storage = parseFloat(document.getElementById('new-storage-rate').value);
                const dio = parseInt(document.getElementById('new-dio').value);
                const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled').checked;
                const minDCSize = parseInt(document.getElementById('new-min-dc-size').value || 500);
                const midMileEnabled = document.getElementById('new-mid-mile-enabled').checked;
                const minVolumeThreshold = parseFloat(document.getElementById('new-min-volume-threshold').value || 10) * 1000000; // Convert M to actual
                const midMileRate = parseFloat(document.getElementById('new-mid-mile-rate').value || 100);

                // Clone current state
                const runDCs = JSON.parse(JSON.stringify(newScenarioDCs));
                const runDemands = JSON.parse(JSON.stringify(newScenarioDemands));

                const startTime = performance.now();

                if (solver === 'heuristic') {
                    // Run heuristic optimization on runDCs
                    function calculateScenarioCost(dcs, demands) {
                        const activeDCs = dcs.filter(dc => dc.active);
                        let total = 0;
                        const fm = firstMile / 1000;
                        const lm = lastMile / 1000;

                        activeDCs.forEach(dc => {
                            const nearestFactory = findNearestActiveFactory(dc);
                            const dist = nearestFactory ? distance(nearestFactory, dc) : 0;
                            const throughput = demands.filter(p => p.assignedDCId === dc.id || p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                            total += dist * throughput * fm * 12;
                            const avgInventory = throughput * (dio / 365);
                            const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                            total += billableInventory * storage * 12;
                        });
                        demands.forEach(point => {
                            if (point.assignedDC || point.assignedDCId) {
                                total += point.distance * point.demand * lm * 12;
                            }
                        });
                        return total;
                    }

                    // Start with all DCs active that are within range of a factory
                    runDCs.forEach(dc => {
                        const nearestFactory = findNearestActiveFactory(dc);
                        dc.active = nearestFactory ? distance(nearestFactory, dc) <= 4000 : false;
                    });
                    assignCustomersToScenario(runDemands, runDCs);
                    let currentCost = calculateScenarioCost(runDCs, runDemands);

                    let improved = true;
                    let iterations = 0;
                    while (improved && iterations < 10) {
                        improved = false;
                        iterations++;
                        let bestSavings = 0;
                        let bestDCToClose = -1;

                        for (let i = 0; i < runDCs.length; i++) {
                            if (!runDCs[i].active) continue;
                            runDCs[i].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            const allAssigned = runDemands.every(p => p.assignedDC !== null);
                            if (allAssigned) {
                                const newCost = calculateScenarioCost(runDCs, runDemands);
                                const savings = currentCost - newCost;
                                if (savings > bestSavings) {
                                    bestSavings = savings;
                                    bestDCToClose = i;
                                }
                            }
                            runDCs[i].active = true;
                        }

                        if (bestDCToClose >= 0) {
                            runDCs[bestDCToClose].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            currentCost = calculateScenarioCost(runDCs, runDemands);
                            improved = true;
                        }
                    }
                    assignCustomersToScenario(runDemands, runDCs);

                } else if (solver === 'highs' || solver === 'glpk') {
                    try {
                        if (solver === 'highs') {
                            await optimizeWithHiGHS(runDCs, runDemands);
                        } else {
                            await optimizeWithGLPK(runDCs, runDemands);
                        }
                    } catch (e) {
                        console.error('Solver error:', e);
                    }
                    assignCustomersToScenario(runDemands, runDCs);
                }

                const endTime = performance.now();
                const solveTime = Math.round(endTime - startTime);

                // Classify DCs based on mid-mile threshold (after assignment)
                classifyDCs(runDCs, runDemands, midMileEnabled, minVolumeThreshold);

                // Calculate costs for display
                const costs = calculateCostsForScenario(runDCs, runDemands, {firstMile, lastMile, storage, dio, minDCSizeEnabled, minDCSize, midMileEnabled, midMileRate});

                // Update live indicators
                updateLiveIndicators(costs, runDemands, runDCs);

                // Show run time result (replace spinner)
                runTimeIndicator.textContent = solverNames[solver] + ' - ' + solveTime + 'ms';

                // Update map with optimized network
                newScenarioDCs.forEach((dc, i) => {
                    dc.active = runDCs[i].active;
                    dc.dcType = runDCs[i].dcType;
                    dc.supplierDC = runDCs[i].supplierDC;
                    dc.distanceToSupplier = runDCs[i].distanceToSupplier;
                    dc.throughput = runDCs[i].throughput;
                });
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                // Re-run classification for the main array (to re-link supplierDC references)
                classifyDCs(newScenarioDCs, newScenarioDemands, midMileEnabled, minVolumeThreshold);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true, midMileEnabled);
                updateNewScenarioDCList();

                // Store result for Quick Save
                lastOptimizationResult = {
                    dcs: runDCs,
                    demands: runDemands,
                    params: {firstMile, lastMile, storage, dio, minDCSizeEnabled, minDCSize, midMileEnabled, minVolumeThreshold, midMileRate, solver: solverNames[solver], solveTime}
                };

                // Add to feed if requested (manual run or save)
                if (addToFeed) {
                    scenarioFeedCounter++;
                    const scenarioName = 'Run_' + scenarioFeedCounter + '_' + solverNames[solver] + '_' + new Date().toLocaleTimeString();
                    addScenarioToFeed(scenarioName, runDCs, runDemands, lastOptimizationResult.params);
                }

            } finally {
                isOptimizing = false;
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Run Optimization';
                }
            }
        }

        // Helper function to calculate costs for a scenario
        function calculateCostsForScenario(dcs, demands, params) {
            const activeDCs = dcs.filter(dc => dc.active);
            let totalFirstMile = 0;
            let totalMidMile = 0;
            let totalLastMile = 0;
            let totalStorage = 0;
            // Rates are in IDR/PCS/1000km, divide by 1000 for per-km rate
            const fm = params.firstMile / 1000;
            const lm = params.lastMile / 1000;
            const mm = (params.midMileRate || DEFAULT_MID_MILE_RATE) / 1000;

            activeDCs.forEach(dc => {
                // Use assignedDCId for comparison (works after JSON serialization)
                const throughput = demands.filter(p => p.assignedDCId === dc.id || p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);

                // First mile: only for DCs receiving directly from factory (RDC or Direct, not Satellite)
                if (!params.midMileEnabled || dc.dcType !== 'satellite') {
                    const nearestFactory = findNearestActiveFactory(dc);
                    const dist = nearestFactory ? distance(nearestFactory, dc) : 0;
                    // Annual cost: distance * demand * rate * 12 months
                    totalFirstMile += dist * throughput * fm * 12;
                }

                // Mid-mile: satellite throughput √ó distance to supplier RDC √ó rate
                if (params.midMileEnabled && dc.dcType === 'satellite' && dc.supplierDC) {
                    totalMidMile += dc.distanceToSupplier * throughput * mm * 12;
                }

                // Storage calculation
                const avgInventory = throughput * (params.dio / 365);
                const billableInventory = params.minDCSizeEnabled ? Math.max(avgInventory, params.minDCSize) : avgInventory;
                totalStorage += billableInventory * params.storage * 12;
            });

            // Last mile (customer deliveries)
            demands.forEach(point => {
                if (point.assignedDC || point.assignedDCId) {
                    // Annual cost: distance * demand * rate * 12 months
                    totalLastMile += point.distance * point.demand * lm * 12;
                }
            });

            const totalTransport = totalFirstMile + totalMidMile + totalLastMile;
            return {
                total: totalTransport + totalStorage,
                transport: totalTransport,
                firstMile: totalFirstMile,
                midMile: totalMidMile,
                lastMile: totalLastMile,
                storage: totalStorage,
                activeDCs: activeDCs.length
            };
        }

        // Run Optimization button handler (for manual mode)
        document.getElementById('run-new-optimization').addEventListener('click', async () => {
            await runOptimization(true);
        });

        // Quick Save handler - adds to feed without saving to localStorage
        document.getElementById('quick-save-scenario').addEventListener('click', async () => {
            if (!lastOptimizationResult) {
                // Run optimization first if no result exists
                await runOptimization(false);
            }
            if (lastOptimizationResult) {
                scenarioFeedCounter++;
                const scenarioName = 'Run_' + scenarioFeedCounter + '_' + lastOptimizationResult.params.solver + '_' + new Date().toLocaleTimeString();
                addScenarioToFeed(scenarioName, lastOptimizationResult.dcs, lastOptimizationResult.demands, lastOptimizationResult.params);
            }
        });

        // Save Scenario handler - saves to localStorage and adds to dropdowns
        document.getElementById('save-new-scenario').addEventListener('click', async () => {
            const name = prompt('Enter scenario name:');
            if (!name) return;

            // Run optimization if needed
            if (!lastOptimizationResult) {
                await runOptimization(false);
            }

            const scenario = {
                name,
                dcActive: newScenarioDCs.map(dc => dc.active),
                parameters: {
                    firstMileRate: document.getElementById('new-first-mile-rate').value,
                    lastMileRate: document.getElementById('new-last-mile-rate').value,
                    storageRate: document.getElementById('new-storage-rate').value,
                    dio: document.getElementById('new-dio').value,
                    minDCSizeEnabled: document.getElementById('new-min-dc-size-enabled').checked,
                    minDCSize: document.getElementById('new-min-dc-size').value
                },
                demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
            };
            localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));

            // Add to all dropdowns
            const option1 = document.createElement('option');
            option1.value = name;
            option1.textContent = name;
            document.getElementById('scenario-select-1').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-2').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-3').appendChild(option1.cloneNode(true));
            document.getElementById('reference-scenario-select').appendChild(option1.cloneNode(true));
            document.getElementById('preload-scenario-select').appendChild(option1);

            // Also add to scenario feed
            if (lastOptimizationResult) {
                scenarioFeedCounter++;
                addScenarioToFeed(name, lastOptimizationResult.dcs, lastOptimizationResult.demands, lastOptimizationResult.params);
            }

            alert('Scenario "' + name + '" saved!');
        });

        // Data Admin: Load CSV handler
        document.getElementById('load-demand-btn').addEventListener('click', function() {
            const fileInput = document.getElementById('demand-csv-input');
            const errorDiv = document.getElementById('csv-error');
            const successDiv = document.getElementById('csv-success');
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            if (!fileInput.files || fileInput.files.length === 0) {
                errorDiv.textContent = 'Please select a CSV file first';
                errorDiv.style.display = 'block';
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const newDemands = parseDemandsCSV(e.target.result);
                    demandPoints = newDemands;

                    // Reassign to DCs and update displays
                    assignCustomers();
                    updateDemandSummary();

                    // Update new scenario data
                    newScenarioDemands = JSON.parse(JSON.stringify(demandPoints));
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

                    // Update New Scenario map if it exists
                    if (mapNewScenario && markersNewScenario) {
                        mapNewScenario.invalidateSize();
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                        // Fit map to show all demand points
                        if (newScenarioDemands.length > 0) {
                            const bounds = L.latLngBounds(newScenarioDemands.map(p => [p.lat, p.lng]));
                            mapNewScenario.fitBounds(bounds, { padding: [20, 20] });
                        }
                    }

                    // Update Analytics maps if they exist
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }

                    // Clear file input
                    fileInput.value = '';

                    successDiv.textContent = `Successfully loaded ${newDemands.length} demand points (${demandPoints.reduce((sum, p) => sum + p.demand, 0).toLocaleString()} PCS/month)`;
                    successDiv.style.display = 'block';
                } catch (err) {
                    errorDiv.textContent = err.message;
                    errorDiv.style.display = 'block';
                }
            };

            reader.readAsText(file);
        });

        // Data Admin: Reset to default handler (clears data)
        document.getElementById('reset-demand-btn').addEventListener('click', function() {
            demandPoints = [];
            assignCustomers();
            updateDemandSummary();

            // Update new scenario data
            newScenarioDemands = [];

            // Update New Scenario map if it exists
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Update Analytics maps if they exist
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }

            const successDiv = document.getElementById('csv-success');
            const errorDiv = document.getElementById('csv-error');
            errorDiv.style.display = 'none';
            successDiv.textContent = 'Demand data cleared';
            successDiv.style.display = 'block';
        });

        // Data Admin: Table toggle handler
        document.getElementById('demand-table-toggle').addEventListener('click', function() {
            const container = document.getElementById('demand-table-container');
            const icon = document.getElementById('demand-table-icon');
            const isHidden = container.style.display === 'none';
            container.style.display = isHidden ? 'block' : 'none';
            icon.textContent = isHidden ? '‚ñº' : '‚ñ∂';
        });

        // Data Admin: Sortable table headers
        document.querySelectorAll('.sortable-header').forEach(header => {
            header.addEventListener('click', function() {
                const col = this.getAttribute('data-sort');
                if (tableSortColumn === col) {
                    // Toggle direction if same column
                    tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    // New column, default to ascending
                    tableSortColumn = col;
                    tableSortDirection = 'asc';
                }
                updateDemandTable();
            });
        });

        // Data Admin: Load Factory CSV handler
        document.getElementById('load-factory-btn').addEventListener('click', function() {
            const fileInput = document.getElementById('factory-csv-input');
            const errorDiv = document.getElementById('factory-csv-error');
            const successDiv = document.getElementById('factory-csv-success');
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            if (!fileInput.files || fileInput.files.length === 0) {
                errorDiv.textContent = 'Please select a CSV file first';
                errorDiv.style.display = 'block';
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const newFactories = parseFactoriesCSV(e.target.result);
                    factories = newFactories;

                    // Update displays
                    updateFactorySummary();
                    updateFactoryList();

                    // Reassign customers to account for new factories
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

                    // Update New Scenario map if it exists
                    if (mapNewScenario && markersNewScenario) {
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    }

                    // Update Analytics maps if they exist
                    assignCustomers();
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }

                    // Clear file input
                    fileInput.value = '';

                    successDiv.textContent = `Successfully loaded ${newFactories.length} factories`;
                    successDiv.style.display = 'block';
                } catch (err) {
                    errorDiv.textContent = 'Error: ' + err.message;
                    errorDiv.style.display = 'block';
                }
            };

            reader.readAsText(file);
        });

        // Data Admin: Reset Factory to default handler
        document.getElementById('reset-factory-btn').addEventListener('click', function() {
            factories = [
                {id: 'F1', name: 'Jatake, Tangerang', lat: -6.1897, lng: 106.5108, active: true}
            ];

            updateFactorySummary();
            updateFactoryList();

            // Reassign customers
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            assignCustomers();

            // Update New Scenario map if it exists
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Update Analytics maps if they exist
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }

            const successDiv = document.getElementById('factory-csv-success');
            const errorDiv = document.getElementById('factory-csv-error');
            errorDiv.style.display = 'none';
            successDiv.textContent = 'Reset to default factory data';
            successDiv.style.display = 'block';
        });

        // Data Admin: Load DC CSV handler
        document.getElementById('load-dc-btn').addEventListener('click', function() {
            const fileInput = document.getElementById('dc-csv-input');
            const errorDiv = document.getElementById('dc-csv-error');
            const successDiv = document.getElementById('dc-csv-success');
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            if (!fileInput.files || fileInput.files.length === 0) {
                errorDiv.textContent = 'Please select a CSV file first';
                errorDiv.style.display = 'block';
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const newDCs = parseDCsCSV(e.target.result);
                    dcLocations = newDCs;
                    newScenarioDCs = JSON.parse(JSON.stringify(newDCs));

                    // Update displays
                    updateDCSummary();
                    reinitializeDCCheckboxes();
                    reinitializeNewScenarioCheckboxes();

                    // Reassign customers to new DCs
                    assignCustomers();
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

                    // Update New Scenario map if it exists
                    if (mapNewScenario && markersNewScenario) {
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    }

                    // Update Analytics scenario 1 with new DCs
                    scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
                    assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }

                    // Clear file input
                    fileInput.value = '';

                    successDiv.textContent = `Successfully loaded ${newDCs.length} distribution centers`;
                    successDiv.style.display = 'block';
                } catch (err) {
                    errorDiv.textContent = 'Error: ' + err.message;
                    errorDiv.style.display = 'block';
                }
            };

            reader.readAsText(file);
        });

        // Data Admin: Reset DC to default handler (clears data)
        document.getElementById('reset-dc-btn').addEventListener('click', function() {
            dcLocations = [];
            newScenarioDCs = [];

            updateDCSummary();
            reinitializeDCCheckboxes();
            reinitializeNewScenarioCheckboxes();

            // Reassign customers
            assignCustomers();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

            // Update New Scenario map if it exists
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Update Analytics scenario 1
            scenario1.dcLocations = [];
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }

            const successDiv = document.getElementById('dc-csv-success');
            const errorDiv = document.getElementById('dc-csv-error');
            errorDiv.style.display = 'none';
            successDiv.textContent = 'DC data cleared';
            successDiv.style.display = 'block';
        });

        // ===== INFO TAB - DEFAULT PARAMETERS EDIT =====

        // Save parameters to localStorage
        function saveModelParams(params) {
            localStorage.setItem(MODEL_PARAMS_STORAGE_KEY, JSON.stringify(params));
        }

        // Update display with current values on page load
        function updateParamsDisplay() {
            document.getElementById('display-first-mile').textContent = modelParams.firstMileRate;
            document.getElementById('display-mid-mile').textContent = modelParams.midMileRate || DEFAULT_MID_MILE_RATE;
            document.getElementById('display-last-mile').textContent = modelParams.lastMileRate;
            document.getElementById('display-storage').textContent = modelParams.storageRate;
            document.getElementById('display-dio').textContent = modelParams.dio;
            document.getElementById('display-wacc').textContent = modelParams.wacc;
            document.getElementById('display-truck-speed').textContent = modelParams.truckSpeed;
            document.getElementById('display-opening-hours').textContent = modelParams.openingHours;
            document.getElementById('display-nsv').textContent = modelParams.nsv;

            // Also update the New Scenario parameter inputs
            document.getElementById('new-first-mile-rate').value = modelParams.firstMileRate;
            document.getElementById('new-last-mile-rate').value = modelParams.lastMileRate;
            document.getElementById('new-storage-rate').value = modelParams.storageRate;
            document.getElementById('new-dio').value = modelParams.dio;
            document.getElementById('new-mid-mile-rate').value = modelParams.midMileRate || DEFAULT_MID_MILE_RATE;
        }

        // Initialize display on page load
        updateParamsDisplay();

        // Edit button handler
        document.getElementById('edit-default-params-btn').addEventListener('click', function() {
            // Populate edit fields with current values
            document.getElementById('edit-first-mile').value = modelParams.firstMileRate;
            document.getElementById('edit-mid-mile').value = modelParams.midMileRate || DEFAULT_MID_MILE_RATE;
            document.getElementById('edit-last-mile').value = modelParams.lastMileRate;
            document.getElementById('edit-storage').value = modelParams.storageRate;
            document.getElementById('edit-dio').value = modelParams.dio;
            document.getElementById('edit-wacc').value = modelParams.wacc;
            document.getElementById('edit-truck-speed').value = modelParams.truckSpeed;
            document.getElementById('edit-opening-hours').value = modelParams.openingHours;
            document.getElementById('edit-nsv').value = modelParams.nsv;

            // Switch to edit mode
            document.getElementById('params-display-mode').style.display = 'none';
            document.getElementById('params-edit-mode').style.display = 'block';
            this.style.display = 'none';
        });

        // Cancel button handler
        document.getElementById('cancel-params-btn').addEventListener('click', function() {
            document.getElementById('params-display-mode').style.display = 'block';
            document.getElementById('params-edit-mode').style.display = 'none';
            document.getElementById('edit-default-params-btn').style.display = 'block';
        });

        // Save button handler
        document.getElementById('save-params-btn').addEventListener('click', function() {
            // Update model parameters
            modelParams.firstMileRate = parseFloat(document.getElementById('edit-first-mile').value) || DEFAULT_FIRST_MILE_RATE;
            modelParams.midMileRate = parseFloat(document.getElementById('edit-mid-mile').value) || DEFAULT_MID_MILE_RATE;
            modelParams.lastMileRate = parseFloat(document.getElementById('edit-last-mile').value) || DEFAULT_LAST_MILE_RATE;
            modelParams.storageRate = parseFloat(document.getElementById('edit-storage').value) || DEFAULT_STORAGE_RATE;
            modelParams.dio = parseInt(document.getElementById('edit-dio').value) || DEFAULT_DIO;
            modelParams.wacc = parseFloat(document.getElementById('edit-wacc').value) || 10;
            modelParams.truckSpeed = parseInt(document.getElementById('edit-truck-speed').value) || DEFAULT_TRUCK_SPEED;
            modelParams.openingHours = parseInt(document.getElementById('edit-opening-hours').value) || DEFAULT_OPENING_HOURS;
            modelParams.nsv = parseInt(document.getElementById('edit-nsv').value) || 47000;

            // Save to localStorage for persistence
            saveModelParams(modelParams);

            // Update display values
            updateParamsDisplay();

            // Switch back to display mode
            document.getElementById('params-display-mode').style.display = 'block';
            document.getElementById('params-edit-mode').style.display = 'none';
            document.getElementById('edit-default-params-btn').style.display = 'block';

            // Trigger recalculation if auto-run is enabled
            triggerAutoRun();

            alert('Default parameters saved successfully!');
        });

        // ===== DATA INPUT EVENT HANDLERS =====

        // LocalStorage keys for data files
        const DATA_STORAGE_KEYS = {
            demand: 'eno_demand_files',
            factories: 'eno_factories_files',
            dcs: 'eno_dcs_files'
        };

        // Load saved files list from localStorage
        function loadSavedFilesList(dataType) {
            const key = DATA_STORAGE_KEYS[dataType];
            const stored = localStorage.getItem(key);
            return stored ? JSON.parse(stored) : {};
        }

        // Save files list to localStorage
        function saveFilesList(dataType, files) {
            const key = DATA_STORAGE_KEYS[dataType];
            localStorage.setItem(key, JSON.stringify(files));
        }

        // Populate dropdown with saved files
        function populateFileDropdown(dataType) {
            const select = document.getElementById(`${dataType}-file-select`);
            const files = loadSavedFilesList(dataType);

            // Clear existing options except the first one
            select.innerHTML = '<option value="">-- Select a file --</option>';

            // Add saved files
            Object.keys(files).sort().forEach(fileName => {
                const option = document.createElement('option');
                option.value = fileName;
                option.textContent = fileName;
                select.appendChild(option);
            });
        }

        // Parse CSV data based on type
        function parseCSVData(csvText, dataType) {
            const lines = csvText.trim().split('\n');
            const data = [];

            // Skip header if present (check if first line contains non-numeric values)
            let startIndex = 0;
            const firstLine = lines[0].split(',');
            if (isNaN(parseFloat(firstLine[0]))) {
                startIndex = 1;
            }

            let dcIndex = 1;
            for (let i = startIndex; i < lines.length; i++) {
                const parts = lines[i].split(',').map(p => p.trim());
                if (parts.length >= 2) {
                    const lat = parseFloat(parts[0]);
                    const lng = parseFloat(parts[1]);

                    if (!isNaN(lat) && !isNaN(lng)) {
                        if (dataType === 'demand' && parts.length >= 3) {
                            const demand = parseFloat(parts[2]) || 1;
                            data.push({ lat, lng, demand });
                        } else if (dataType === 'dcs') {
                            // DCs need id, name, and active properties
                            data.push({
                                id: `DC${dcIndex}`,
                                name: `DC${dcIndex}`,
                                lat,
                                lng,
                                active: true
                            });
                            dcIndex++;
                        } else {
                            data.push({ lat, lng });
                        }
                    }
                }
            }
            return data;
        }

        // Update status display
        function updateDataStatus(dataType, count) {
            const countEl = document.getElementById(`${dataType}-point-count`);
            if (countEl) {
                countEl.textContent = count;
            }
        }

        // Update data table
        function updateDataTable(dataType, data) {
            const tbody = document.getElementById(`${dataType}-table-body-input`);
            if (!tbody) return;

            tbody.innerHTML = '';
            data.forEach((item, index) => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #f0f0f0';

                if (dataType === 'demand') {
                    row.innerHTML = `
                        <td style="padding: 6px 8px;">${index + 1}</td>
                        <td style="padding: 6px 8px; text-align: right;">${item.lat.toFixed(4)}</td>
                        <td style="padding: 6px 8px; text-align: right;">${item.lng.toFixed(4)}</td>
                        <td style="padding: 6px 8px; text-align: right;">${item.demand.toLocaleString()}</td>
                    `;
                } else {
                    row.innerHTML = `
                        <td style="padding: 6px 8px;">${index + 1}</td>
                        <td style="padding: 6px 8px; text-align: right;">${item.lat.toFixed(4)}</td>
                        <td style="padding: 6px 8px; text-align: right;">${item.lng.toFixed(4)}</td>
                    `;
                }
                tbody.appendChild(row);
            });
        }

        // Load data into the application
        function loadDataIntoApp(dataType, data) {
            if (dataType === 'demand') {
                newScenarioDemands = data;
                updateDataStatus('demand', data.length);
                updateDataTable('demand', data);
                // Assign customers to DCs if DCs exist
                if (typeof assignCustomersToScenario === 'function' && newScenarioDCs.length > 0) {
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                }
                // Refresh map if exists
                if (mapNewScenario && markersNewScenario) {
                    mapNewScenario.invalidateSize();
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    // Fit bounds to show all points
                    const allPoints = [...newScenarioDCs, ...newScenarioDemands].filter(p => p && p.lat && p.lng);
                    if (allPoints.length > 0) {
                        const bounds = L.latLngBounds(allPoints.map(p => [p.lat, p.lng]));
                        mapNewScenario.fitBounds(bounds, { padding: [20, 20] });
                    }
                }
            } else if (dataType === 'factories') {
                factories = data;
                updateDataStatus('factories', data.length);
                updateDataTable('factories', data);
            } else if (dataType === 'dcs') {
                // Ensure DC data has required properties (id, name, active)
                const processedData = data.map((dc, index) => ({
                    id: dc.id || `DC${index + 1}`,
                    name: dc.name || `DC${index + 1}`,
                    lat: dc.lat,
                    lng: dc.lng,
                    active: dc.active !== undefined ? dc.active : true
                }));
                newScenarioDCs = processedData;
                // Also update global dcLocations
                dcLocations = JSON.parse(JSON.stringify(processedData));
                updateDataStatus('dcs', processedData.length);
                updateDataTable('dcs', processedData);
                // Update DC list UI if exists
                if (typeof updateNewScenarioDCList === 'function') {
                    updateNewScenarioDCList();
                }
                // Re-assign customers to new DCs
                if (typeof assignCustomersToScenario === 'function' && newScenarioDemands.length > 0) {
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                }
                // Refresh map if exists
                if (mapNewScenario && markersNewScenario) {
                    mapNewScenario.invalidateSize();
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    // Fit bounds to show all points (DCs and demands)
                    const allPoints = [...newScenarioDCs, ...newScenarioDemands].filter(p => p && p.lat && p.lng);
                    if (allPoints.length > 0) {
                        const bounds = L.latLngBounds(allPoints.map(p => [p.lat, p.lng]));
                        mapNewScenario.fitBounds(bounds, { padding: [20, 20] });
                    }
                }
            }
        }

        // Handle file upload
        function handleFileUpload(file, dataType) {
            if (!file || !file.name.endsWith('.csv')) {
                alert('Please upload a CSV file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                const data = parseCSVData(csvText, dataType);

                if (data.length === 0) {
                    alert('No valid data found in the CSV file.');
                    return;
                }

                // Save to localStorage
                const files = loadSavedFilesList(dataType);
                files[file.name] = {
                    data: data,
                    uploadedAt: new Date().toISOString()
                };
                saveFilesList(dataType, files);

                // Refresh dropdown and select the new file
                populateFileDropdown(dataType);
                document.getElementById(`${dataType}-file-select`).value = file.name;

                // Load data into app
                loadDataIntoApp(dataType, data);

                alert(`Successfully loaded ${data.length} ${dataType} points from ${file.name}`);
            };
            reader.readAsText(file);
        }

        // Data Input section toggle (collapsible)
        document.getElementById('data-input-toggle').addEventListener('click', function(e) {
            const content = document.getElementById('data-input-content');
            const icon = document.getElementById('data-input-toggle-icon');
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            icon.innerHTML = isHidden ? '&#9660;' : '&#9654;';
        });

        // Setup event handlers for each data type
        ['demand', 'factories', 'dcs'].forEach(dataType => {
            // Table toggle
            const tableToggle = document.getElementById(`${dataType}-table-toggle-input`);
            if (tableToggle) {
                tableToggle.addEventListener('click', function() {
                    const container = document.getElementById(`${dataType}-table-container-input`);
                    const icon = document.getElementById(`${dataType}-table-icon-input`);
                    const isHidden = container.style.display === 'none';
                    container.style.display = isHidden ? 'block' : 'none';
                    icon.innerHTML = isHidden ? '&#9660;' : '&#9654;';
                });
            }

            // File selection dropdown
            const fileSelect = document.getElementById(`${dataType}-file-select`);
            if (fileSelect) {
                fileSelect.addEventListener('change', function() {
                    const fileName = this.value;
                    if (!fileName) return;

                    const files = loadSavedFilesList(dataType);
                    if (files[fileName] && Array.isArray(files[fileName].data)) {
                        loadDataIntoApp(dataType, files[fileName].data);
                    }
                });
            }

            // Drop zone
            const dropZone = document.getElementById(`${dataType}-drop-zone`);
            const fileInput = document.getElementById(`${dataType}-file-upload`);

            if (dropZone && fileInput) {
                // Click to browse
                dropZone.addEventListener('click', function() {
                    fileInput.click();
                });

                // File input change
                fileInput.addEventListener('change', function() {
                    if (this.files.length > 0) {
                        handleFileUpload(this.files[0], dataType);
                    }
                });

                // Drag and drop
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#007bff';
                    this.style.background = '#f0f7ff';
                });

                dropZone.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#ccc';
                    this.style.background = 'transparent';
                });

                dropZone.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.borderColor = '#ccc';
                    this.style.background = 'transparent';

                    if (e.dataTransfer.files.length > 0) {
                        handleFileUpload(e.dataTransfer.files[0], dataType);
                    }
                });
            }

            // Save button
            const saveBtn = document.getElementById(`${dataType}-file-save`);
            if (saveBtn) {
                saveBtn.addEventListener('click', function() {
                    let currentData;
                    if (dataType === 'demand') currentData = newScenarioDemands;
                    else if (dataType === 'factories') currentData = factories;
                    else if (dataType === 'dcs') currentData = newScenarioDCs;

                    if (!currentData || currentData.length === 0) {
                        alert('No data to save.');
                        return;
                    }

                    const fileName = prompt('Enter a filename for this data:', `${dataType}_data.csv`);
                    if (!fileName) return;

                    const files = loadSavedFilesList(dataType);
                    files[fileName] = {
                        data: currentData,
                        uploadedAt: new Date().toISOString()
                    };
                    saveFilesList(dataType, files);

                    populateFileDropdown(dataType);
                    document.getElementById(`${dataType}-file-select`).value = fileName;

                    alert(`Data saved as "${fileName}"`);
                });
            }

            // Rename button
            const renameBtn = document.getElementById(`${dataType}-file-rename`);
            if (renameBtn) {
                renameBtn.addEventListener('click', function() {
                    const select = document.getElementById(`${dataType}-file-select`);
                    const oldName = select.value;

                    if (!oldName) {
                        alert('Please select a file to rename.');
                        return;
                    }

                    const newName = prompt('Enter new filename:', oldName);
                    if (!newName || newName === oldName) return;

                    const files = loadSavedFilesList(dataType);
                    if (files[oldName]) {
                        files[newName] = files[oldName];
                        delete files[oldName];
                        saveFilesList(dataType, files);

                        populateFileDropdown(dataType);
                        select.value = newName;

                        alert(`File renamed to "${newName}"`);
                    }
                });
            }

            // Delete button
            const deleteBtn = document.getElementById(`${dataType}-file-delete`);
            if (deleteBtn) {
                deleteBtn.addEventListener('click', function() {
                    const select = document.getElementById(`${dataType}-file-select`);
                    const fileName = select.value;

                    if (!fileName) {
                        alert('Please select a file to delete.');
                        return;
                    }

                    if (!confirm(`Are you sure you want to delete "${fileName}"?`)) return;

                    const files = loadSavedFilesList(dataType);
                    delete files[fileName];
                    saveFilesList(dataType, files);

                    populateFileDropdown(dataType);
                    select.value = '';

                    alert(`File "${fileName}" deleted.`);
                });
            }

            // Initialize dropdown with saved files
            populateFileDropdown(dataType);
        });

        // Initialize data tables with current data
        if (newScenarioDemands && newScenarioDemands.length > 0) {
            updateDataStatus('demand', newScenarioDemands.length);
            updateDataTable('demand', newScenarioDemands);
        }
        if (factories && factories.length > 0) {
            updateDataStatus('factories', factories.length);
            updateDataTable('factories', factories);
        }
        if (newScenarioDCs && newScenarioDCs.length > 0) {
            updateDataStatus('dcs', newScenarioDCs.length);
            updateDataTable('dcs', newScenarioDCs);
        }

        // ===== CLUSTERING EVENT HANDLERS =====

        // Clustering section toggle (collapsible)
        document.getElementById('clustering-toggle').addEventListener('click', function(e) {
            // Don't toggle if clicking on buttons
            if (e.target.tagName === 'BUTTON') return;

            const content = document.getElementById('clustering-content');
            const icon = document.getElementById('clustering-toggle-icon');
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            icon.innerHTML = isHidden ? '&#9660;' : '&#9654;';
        });

        // Create New Scenario section toggle (collapsible)
        document.getElementById('scenario-toggle').addEventListener('click', function(e) {
            // Don't toggle if clicking on buttons or select
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT') return;

            const content = document.getElementById('scenario-content');
            const icon = document.getElementById('scenario-toggle-icon');
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            icon.innerHTML = isHidden ? '&#9660;' : '&#9654;';

            // Fix map display issue when section becomes visible
            if (isHidden && mapNewScenario) {
                setTimeout(() => {
                    mapNewScenario.invalidateSize();
                    // Re-render markers if we have data
                    if (newScenarioDemands.length > 0 || newScenarioDCs.length > 0) {
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                        // Fit bounds to show all points
                        const allPoints = [...newScenarioDemands, ...newScenarioDCs].filter(p => p && p.lat && p.lng);
                        if (allPoints.length > 0) {
                            const bounds = L.latLngBounds(allPoints.map(p => [p.lat, p.lng]));
                            mapNewScenario.fitBounds(bounds, { padding: [20, 20] });
                        }
                    }
                }, 100);
            }
        });

        // Run Clustering button
        document.getElementById('run-clustering').addEventListener('click', function() {
            const k = parseInt(document.getElementById('cluster-count').value);
            const algorithm = document.getElementById('clustering-algorithm').value;

            // Validate input
            if (isNaN(k) || k < 1 || k > 200) {
                alert('Please enter a valid number of clusters (1-200).');
                return;
            }

            // Show loading indicator
            const infoDiv = document.getElementById('clustering-info');
            infoDiv.innerHTML = '<strong>Running clustering...</strong> Please wait.';
            infoDiv.style.display = 'block';

            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                // Run selected algorithm
                if (algorithm === 'kmeans') {
                    currentClusteringResult = weightedKMeans(newScenarioDemands, k);
                } else {
                    currentClusteringResult = weightedKMedoids(newScenarioDemands, k);
                }

                clusterColors = generateClusterColors(k);

                // Update info display
                const totalDemand = newScenarioDemands.reduce((sum, p) => sum + p.demand, 0);
                const avgDemand = Math.round(totalDemand / k);
                infoDiv.innerHTML =
                    `<strong>${k} clusters</strong> created in ${currentClusteringResult.iterations} iterations. ` +
                    `Total demand: ${totalDemand.toLocaleString()} pieces. ` +
                    `Avg per cluster: ${avgDemand.toLocaleString()} pieces.`;

                // Show action buttons
                document.getElementById('clustering-action-buttons').style.display = 'flex';

                // Auto-enable clustered view
                isClusteredViewActive = true;

                // Render clustered view
                const showLinks = document.getElementById('show-centroid-links').checked;
                renderClusteredView(mapNewScenario, markersNewScenario, newScenarioDemands,
                                   currentClusteringResult, showLinks);

                // Render the embedded clustering map with Voronoi
                renderClusteringMap();
            }, 0);
        });

        // Visualization checkboxes for clustering map
        ['show-voronoi', 'show-demand-points', 'show-centroid-links'].forEach(id => {
            const checkbox = document.getElementById(id);
            if (checkbox) {
                checkbox.addEventListener('change', function() {
                    if (currentClusteringResult) {
                        renderClusteringMap();
                    }
                });
            }
        });

        // Reset clustering button
        document.getElementById('reset-clustering').addEventListener('click', function() {
            currentClusteringResult = null;
            clusterColors = [];
            isClusteredViewActive = false;

            document.getElementById('clustering-action-buttons').style.display = 'none';
            document.getElementById('clustering-info').style.display = 'none';

            // Hide the clustering map
            document.getElementById('clustering-map-container').style.display = 'none';

            // Restore normal map view
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Add centroids as DCs button
        document.getElementById('add-centroids-as-dcs').addEventListener('click', function() {
            if (!currentClusteringResult || !currentClusteringResult.centroids) {
                alert('Please run clustering first.');
                return;
            }

            const { centroids } = currentClusteringResult;
            const startId = dcLocations.length + 1;

            centroids.forEach((centroid, i) => {
                const newId = 'DC' + (startId + i);
                const newDC = {
                    id: newId,
                    name: `Cluster ${i + 1} Centroid`,
                    lat: centroid.lat,
                    lng: centroid.lng,
                    active: true
                };

                // Add to both global and scenario DC arrays
                dcLocations.push(newDC);
                newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
            });

            // Update UI
            updateNewScenarioDCList();
            reinitializeNewScenarioCheckboxes();
            reinitializeDCCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

            // Turn off clustered view and show normal map with new DCs
            isClusteredViewActive = false;
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);

            triggerAutoRun();

            alert(`${centroids.length} centroids added as new DCs.`);
        });

        // Replace DCs with centroids button
        document.getElementById('replace-dcs-with-centroids').addEventListener('click', function() {
            if (!currentClusteringResult || !currentClusteringResult.centroids) {
                alert('Please run clustering first.');
                return;
            }

            if (!confirm('This will replace all existing DCs with cluster centroids. Continue?')) {
                return;
            }

            const { centroids } = currentClusteringResult;

            // Clear existing DCs
            dcLocations.length = 0;
            newScenarioDCs.length = 0;

            // Add centroids as new DCs
            centroids.forEach((centroid, i) => {
                const newDC = {
                    id: 'DC' + (i + 1),
                    name: `Cluster ${i + 1} Centroid`,
                    lat: centroid.lat,
                    lng: centroid.lng,
                    active: true
                };

                dcLocations.push(newDC);
                newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
            });

            // Update UI
            updateNewScenarioDCList();
            reinitializeNewScenarioCheckboxes();
            reinitializeDCCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            updateDCSummary();

            // Turn off clustered view and show normal map with new DCs
            isClusteredViewActive = false;
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);

            triggerAutoRun();

            alert(`Replaced all DCs with ${centroids.length} cluster centroids.`);
        });

        // ===== END CLUSTERING EVENT HANDLERS =====

        // Expand All / Collapse All scenario handlers
        document.getElementById('expand-all-scenarios').addEventListener('click', function() {
            const feed = document.getElementById('scenario-feed');
            feed.querySelectorAll('.scenario-details').forEach(details => {
                details.style.display = 'block';
            });
            feed.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.textContent = 'Collapse';
            });
        });

        document.getElementById('collapse-all-scenarios').addEventListener('click', function() {
            const feed = document.getElementById('scenario-feed');
            feed.querySelectorAll('.scenario-details').forEach(details => {
                details.style.display = 'none';
            });
            feed.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.textContent = 'Expand';
            });
        });

        // Function to add scenario to feed
        function addScenarioToFeed(name, dcs, demands, params) {
            const feed = document.getElementById('scenario-feed');
            const scenarioId = 'scenario-' + Date.now();

            const scenarioBlock = document.createElement('div');
            scenarioBlock.id = scenarioId;
            scenarioBlock.style.cssText = 'background: white; padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px;';

            const solverInfo = params.solver ? `<span style="margin-left: 10px; padding: 4px 10px; background: var(--cel-blue); color: white; border-radius: 12px; font-size: 12px;">${params.solver}${params.solveTime ? ' - ' + params.solveTime + 'ms' : ''}</span>` : '';

            scenarioBlock.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center;">
                        <h3 style="font-size: 18px; font-weight: 600; color: var(--text-dark); margin: 0;">${name}</h3>
                        ${solverInfo}
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="toggle-btn" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Expand</button>
                        <button class="hide-btn" style="padding: 6px 14px; background: #ffc107; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Hide</button>
                        <button class="save-btn" style="padding: 6px 14px; background: var(--cel-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Save</button>
                        <button class="delete-btn" style="padding: 6px 14px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Delete</button>
                    </div>
                </div>
                <div class="metrics-grid scenario-metrics" style="margin-bottom: 0;"></div>
                <div class="scenario-details" style="margin-top: 15px; display: none;">
                    <div>
                        <div class="scenario-map" id="${scenarioId}-map" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 8px;"></div>
                    </div>
                    <div style="margin-top: 20px; display: grid; grid-template-columns: repeat(6, 1fr); gap: 15px;">
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>First Mile Rate:</strong><br>${params.firstMile} IDR/PCS/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Last Mile Rate:</strong><br>${params.lastMile} IDR/PCS/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Storage Rate:</strong><br>${params.storage} IDR/PCS/month</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>DOS:</strong><br>${params.dio} days</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Min DC Size:</strong><br>${params.minDCSizeEnabled ? params.minDCSize + ' PCS' : 'Disabled'}</div>
                        <div style="padding: 15px; background: #e8f4fd; border-radius: 4px;"><strong>Solver:</strong><br>${params.solver || 'Heuristic'}${params.solveTime ? ' (' + params.solveTime + 'ms)' : ''}</div>
                    </div>
                </div>
            `;

            feed.appendChild(scenarioBlock);

            // Show the scenario feed controls when first scenario is added
            document.getElementById('scenario-feed-controls').style.display = 'block';

            // Generate metrics (pass params for minDCSize support)
            const metricsGrid = scenarioBlock.querySelector('.scenario-metrics');
            const metricsParams = params ? {
                firstMile: params.firstMile,
                lastMile: params.lastMile,
                storage: params.storage,
                dio: params.dio,
                minDCSizeEnabled: params.minDCSizeEnabled,
                minDCSize: params.minDCSize
            } : null;
            metricsGrid.innerHTML = generateMetricsHTML(dcs, demands, name, metricsParams);

            // Initialize mini Leaflet map for scenario
            setTimeout(() => {
                const mapContainer = document.getElementById(scenarioId + '-map');
                if (mapContainer && !mapContainer._leaflet_id) {
                    const miniMap = L.map(mapContainer, {
                        center: INDONESIA_CENTER,
                        zoom: INDONESIA_ZOOM,
                        zoomControl: true,
                        scrollWheelZoom: false
                    });
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                        attribution: '¬© CARTO',
                        maxZoom: 18
                    }).addTo(miniMap);

                    const markersLayer = L.layerGroup().addTo(miniMap);
                    renderMapMarkers(miniMap, markersLayer, dcs, demands, false);

                    // Store map reference for cleanup
                    mapContainer._leafletMap = miniMap;
                }
            }, 100);

            // Add event listeners
            scenarioBlock.querySelector('.toggle-btn').addEventListener('click', function() {
                const details = scenarioBlock.querySelector('.scenario-details');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    this.textContent = 'Collapse';
                } else {
                    details.style.display = 'none';
                    this.textContent = 'Expand';
                }
            });

            scenarioBlock.querySelector('.hide-btn').addEventListener('click', () => {
                scenarioBlock.style.display = 'none';
            });

            scenarioBlock.querySelector('.save-btn').addEventListener('click', () => {
                const saveName = prompt('Enter scenario name:', name);
                if (!saveName) return;

                const scenario = {
                    name: saveName,
                    dcActive: dcs.map(dc => dc.active),
                    parameters: {
                        firstMileRate: params.firstMile,
                        lastMileRate: params.lastMile,
                        storageRate: params.storage,
                        dio: params.dio,
                        minDCSizeEnabled: params.minDCSizeEnabled || false,
                        minDCSize: params.minDCSize || 500
                    },
                    demands: demands.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + saveName, JSON.stringify(scenario));

                // Update the scenario block heading to reflect the saved name
                const heading = scenarioBlock.querySelector('h3');
                if (heading) {
                    heading.textContent = saveName;
                }

                // Update the internal name variable for future operations
                name = saveName;

                // Add to all dropdowns if not already there
                const existingOption = document.querySelector(`option[value="${saveName}"]`);
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = saveName;
                    option.textContent = saveName;
                    document.getElementById('scenario-select-1').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-2').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-3').appendChild(option.cloneNode(true));
                    document.getElementById('reference-scenario-select').appendChild(option.cloneNode(true));
                    document.getElementById('preload-scenario-select').appendChild(option);
                }

                alert('Scenario saved as "' + saveName + '"!');
            });

            scenarioBlock.querySelector('.delete-btn').addEventListener('click', () => {
                scenarioBlock.remove();
                // Remove from localStorage if it was saved
                localStorage.removeItem('dno-scenario-' + name);
                // Remove from dropdowns
                document.querySelectorAll('option').forEach(opt => {
                    if (opt.value === name) opt.remove();
                });
            });
        }

        // Function to restore saved scenarios from localStorage on page load
        function restoreSavedScenarios() {
            // Find all saved scenarios in localStorage
            const savedScenarios = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('dno-scenario-')) {
                    const scenarioName = key.replace('dno-scenario-', '');
                    const scenarioData = JSON.parse(localStorage.getItem(key));
                    savedScenarios.push({ name: scenarioName, data: scenarioData });
                }
            }

            // Restore each scenario to the feed
            savedScenarios.forEach(({ name, data }) => {
                // Reconstruct DC locations with active states
                const dcs = JSON.parse(JSON.stringify(dcLocations));
                dcs.forEach((dc, index) => {
                    if (data.dcActive && data.dcActive[index] !== undefined) {
                        dc.active = data.dcActive[index];
                    }
                });

                // Use current demand points (they're generated with a fixed seed)
                const demands = JSON.parse(JSON.stringify(demandPoints));

                // Assign customers to DCs
                assignCustomersToScenario(demands, dcs);

                // Extract parameters
                const params = {
                    firstMile: parseFloat(data.parameters.firstMileRate),
                    lastMile: parseFloat(data.parameters.lastMileRate),
                    storage: parseFloat(data.parameters.storageRate),
                    dio: parseInt(data.parameters.dio)
                };

                // Add to scenario feed
                addScenarioToFeed(name, dcs, demands, params);
            });
        }

        // Restore saved scenarios when page loads
        restoreSavedScenarios();
    </script>
</body>
</html>