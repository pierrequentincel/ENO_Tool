<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOM - Distribution Network Design</title>
    <link rel="icon" type="image/png" href="pictures/ATOM_logo_crop.png">
    <!-- Solver Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/highs@1.8.0/build/highs.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/glpk.js@4.0.1/dist/glpk.min.js"></script>
    <!-- Leaflet.js for interactive maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- D3-Delaunay for Voronoi diagrams -->
    <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script>
    <style>
        :root {
            --cel-red: #CB333B;
            --cel-blue: #385D7F;
            --cel-dark-blue: #2c4a5f;
            --cel-orange: #FE5000;
            --cel-green: #30B700;
            --cel-yellow: #FFD100;
            --bg-light: #F5F7FA;
            --text-dark: #2D3748;
            --sidebar-bg: #4A6883;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-light);
            color: var(--text-dark);
        }
        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background-color: var(--sidebar-bg);
            color: white;
            padding: 30px 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .logo-section {
            text-align: center;
            margin-bottom: 30px;
        }
        .logo-section img {
            width: 200px;
            margin-bottom: 20px;
        }
        .company-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .project-name {
            font-size: 14px;
            opacity: 0.9;
            border-top: 2px solid rgba(255,255,255,0.3);
            padding-top: 15px;
            margin-top: 15px;
        }

        .sidebar-section {
            margin-bottom: 30px;
        }
        .sidebar-section h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .scenario-select, .unit-select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background-color: white;
            color: var(--text-dark);
            font-size: 14px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .sidebar-button {
            background-color: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .sidebar-button:hover {
            background-color: rgba(255,255,255,0.3);
        }
        .sidebar-button.primary {
            background-color: var(--cel-blue);
            border-color: var(--cel-blue);
        }
        .sidebar-button.primary:hover {
            background-color: var(--cel-dark-blue);
        }

        /* Main Content */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background-color: white;
            border-bottom: 2px solid #e2e8f0;
        }
        .tab {
            padding: 15px 30px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #64748b;
        }
        .tab.active {
            color: var(--cel-blue);
            border-bottom-color: var(--cel-blue);
        }
        .tab:hover {
            background-color: #f8fafc;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Key Metrics */
        .section-title {
            font-size: 28px;
            font-weight: 600;
            color: var(--cel-blue);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--cel-blue);
        }
        .scenario-label {
            font-size: 18px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 20px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 40px;
        }
        .metric-card {
            background: white;
            padding: 12px 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
        }
        .metric-label {
            font-size: 11px;
            color: #64748b;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .metric-sublabel {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 8px;
            min-height: 12px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--cel-blue);
        }
        .metric-tag {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 12px;
            background-color: #e2e8f0;
            color: #64748b;
            font-size: 11px;
            border-radius: 12px;
        }

        /* Cost Breakdown */
        .cost-breakdown {
            margin-top: 40px;
        }
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        .chart-wrapper {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 20px;
        }

        /* Map Container */
        #map-container, #map-container-analytics {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #map, #map-analytics {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .network-map-section {
            margin-top: 40px;
            margin-bottom: 40px;
        }

        /* Map Comparison Container */
        #map-comparison-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        #map-comparison-container.two-scenarios {
            grid-template-columns: 1fr;
        }
        .map-container-single {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .map-container-single canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .map-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(74, 104, 131, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            z-index: 5;
        }
        #tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            display: none;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
        }

        /* Settings Expander */
        .settings-expander {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        .settings-toggle {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 14px;
            font-weight: 600;
        }
        .settings-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .settings-content.expanded {
            max-height: 800px;
        }
        .parameter-input {
            margin-bottom: 15px;
        }
        .parameter-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            opacity: 0.9;
        }
        .parameter-input input {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
        }
        .dc-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .dc-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .dc-checkbox input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="logo-section">
                <img src="pictures/ATOM_logo.png" alt="ATOM Logo">
                <div class="company-name">Acme Milk Corporate (AMC)</div>
                <div class="project-name">Distribution Network Design</div>
            </div>

            <button class="sidebar-button primary">
                ‚ÑπÔ∏è Scenario Comparison
            </button>

            <div class="sidebar-section">
                <h3>Scenario Selection</h3>
                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px;">First Scenario:</label>
                <select class="scenario-select" id="scenario-select-1">
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>

                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px; margin-top: 15px;">Second Scenario:</label>
                <select class="scenario-select" id="scenario-select-2">
                    <option value="">Choose an option</option>
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>

                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px; margin-top: 15px;">Third Scenario:</label>
                <select class="scenario-select" id="scenario-select-3">
                    <option value="">Choose an option</option>
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>
            </div>

            <div class="sidebar-section">
                <h3>Unit Selection</h3>
                <select class="unit-select" id="unit-select">
                    <option value="usd">US Dollar (USD)</option>
                    <option value="eur">Euro (EUR)</option>
                </select>
            </div>

            <button class="sidebar-button" id="run-optimization">
                üîÑ Run Optimization
            </button>
            <button class="sidebar-button" id="save-scenario">
                üíæ Save Scenario
            </button>

            <div class="settings-expander">
                <div class="settings-toggle" id="settings-toggle">
                    <span>‚öôÔ∏è Advanced Settings</span>
                    <span id="toggle-icon">‚ñº</span>
                </div>
                <div class="settings-content" id="settings-content">
                    <div class="sidebar-section">
                        <h3>Parameters</h3>
                        <div class="parameter-input">
                            <label>First Mile Rate ($/pallet/1,000km):</label>
                            <input type="number" id="first-mile-rate" value="5.60" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>Last Mile Rate ($/pallet/1,000km):</label>
                            <input type="number" id="last-mile-rate" value="9.60" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>Storage Rate ($/pallet/month):</label>
                            <input type="number" id="storage-rate" value="0.30" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>DIO (days):</label>
                            <input type="number" id="dio" value="30">
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <h3>DC Selection</h3>
                        <div class="dc-list" id="dc-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <div class="tabs">
                <div class="tab active" data-tab="new-scenario">New Scenario</div>
                <div class="tab" data-tab="analytics">Analytics</div>
                <div class="tab" data-tab="data-admin">Data Admin</div>
            </div>

            <div class="content-area">
                <!-- Analytics Tab -->
                <div class="tab-content" id="analytics-tab">
                    <h2 class="section-title">Key Metrics</h2>

                    <!-- Scenario 1 -->
                    <div class="scenario-label" id="scenario-label-1">0,5_Baseline_2028</div>
                    <div class="metrics-grid" id="metrics-grid-1">
                        <!-- Metrics will be populated by JavaScript -->
                    </div>

                    <!-- Scenario 2 (hidden by default) -->
                    <div id="scenario-2-section" style="display: none;">
                        <div class="scenario-label" id="scenario-label-2">Scenario 2</div>
                        <div class="metrics-grid" id="metrics-grid-2">
                            <!-- Metrics will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="network-map-section">
                        <h2 class="section-title">Network Map</h2>
                        <div id="map-comparison-container">
                            <!-- Scenario 1 Map -->
                            <div id="map-container-analytics-1" class="map-container-single">
                                <div class="map-label">Scenario 1</div>
                                <div id="map-analytics-1" style="width: 100%; height: 500px; z-index: 1;"></div>
                            </div>

                            <!-- Scenario 2 Map (hidden by default) -->
                            <div id="map-container-analytics-2" class="map-container-single" style="display: none;">
                                <div class="map-label">Scenario 2</div>
                                <div id="map-analytics-2" style="width: 100%; height: 500px; z-index: 1;"></div>
                            </div>
                        </div>
                    </div>

                    <div class="cost-breakdown">
                        <h2 class="section-title">Cost Breakdown</h2>
                        <div class="charts-container">
                            <div class="chart-wrapper">
                                <div class="chart-title">Absolute Logistics Cost Breakdown</div>
                                <canvas id="absolute-chart" width="400" height="300"></canvas>
                            </div>
                            <div class="chart-wrapper">
                                <div class="chart-title">Relative Logistics Cost Breakdown</div>
                                <canvas id="relative-chart" width="400" height="300"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- New Scenario Tab -->
                <div class="tab-content active" id="new-scenario-tab">
                    <h2 class="section-title">New Scenario</h2>

                    <!-- Reference Scenario Section - inline layout -->
                    <div style="margin-bottom: 20px; display: flex; align-items: center; gap: 15px;">
                        <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Reference Scenario</h3>
                        <select id="reference-scenario-select" style="width: 250px; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                            <option value="">Select a scenario...</option>
                            <option value="baseline">0,5_Baseline_2028</option>
                        </select>
                    </div>
                    <div id="reference-scenario-display" style="display: none; margin-bottom: 20px;">
                        <div class="metrics-grid" id="reference-metrics"></div>
                        <div style="margin-top: 20px;">
                            <div id="reference-map" style="width: 100%; height: 400px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                        </div>
                        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;" id="reference-parameters"></div>
                    </div>

                    <!-- Demand Clustering Tool (Collapsible) -->
                    <div style="margin-top: 30px; margin-bottom: 30px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <!-- Collapsible Header -->
                        <div id="clustering-toggle" style="display: flex; align-items: center; justify-content: space-between; padding: 15px 20px; cursor: pointer; user-select: none;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="clustering-toggle-icon" style="font-size: 12px; color: #666;">&#9654;</span>
                                <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Demand Clustering Tool</h3>
                            </div>
                            <div id="clustering-header-buttons" style="display: flex; gap: 10px;">
                                <button id="reset-clustering" style="padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Reset</button>
                                <button id="add-centroids-as-dcs" style="padding: 6px 12px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Add Centroids</button>
                                <button id="replace-dcs-with-centroids" style="padding: 6px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">Replace DCs</button>
                            </div>
                        </div>

                        <!-- Collapsible Content -->
                        <div id="clustering-content" style="display: none; padding: 0 20px 20px 20px;">
                            <!-- Controls Row -->
                            <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                                <!-- Number of Clusters (using number input for performance) -->
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-size: 13px; color: #64748b;">Clusters:</label>
                                    <input type="number" id="cluster-count" min="1" max="200" value="50" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px; width: 80px;">
                                </div>

                                <!-- Algorithm Selection -->
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <label style="font-size: 13px; color: #64748b;">Algorithm:</label>
                                    <select id="clustering-algorithm" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                        <option value="kmeans">Weighted K-Means</option>
                                        <option value="kmedoids">Weighted K-Medoids</option>
                                    </select>
                                </div>

                                <!-- Run Clustering Button -->
                                <button id="run-clustering" style="padding: 8px 16px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;">
                                    Run Clustering
                                </button>

                                <!-- Divider -->
                                <div style="width: 1px; height: 24px; background: #ddd;"></div>

                                <!-- Toggle Clustered View -->
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; color: #64748b;">
                                    <input type="checkbox" id="show-clustered-view" checked>
                                    <span>Show Clustered View</span>
                                </label>

                                <!-- Show Centroid Lines -->
                                <label id="centroid-lines-label" style="display: none; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; color: #64748b;">
                                    <input type="checkbox" id="show-centroid-lines">
                                    <span>Show Centroid Lines</span>
                                </label>
                            </div>

                            <!-- Clustering Status/Info -->
                            <div id="clustering-info" style="display: none; padding: 10px 15px; background: #e8f4fd; border-radius: 4px; font-size: 12px; color: var(--cel-dark-blue);">
                                <!-- Will show clustering results info -->
                            </div>

                            <!-- Clustering Map Section (hidden until Run Clustering) -->
                            <div id="clustering-map-section" style="display: none; margin-top: 15px;">
                                <!-- Map Display Toggles -->
                                <div style="display: flex; gap: 20px; align-items: center; margin-bottom: 10px;">
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #64748b;">
                                        <input type="checkbox" id="show-voronoi-tiles" checked>
                                        <span>Voronoi Tiles</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #64748b;">
                                        <input type="checkbox" id="show-demand-points" checked>
                                        <span>Demand Points</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #64748b;">
                                        <input type="checkbox" id="show-cluster-links">
                                        <span>Links to Centroids</span>
                                    </label>
                                </div>
                                <!-- Clustering Map -->
                                <div id="clustering-map" style="width: 100%; height: 520px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- New Scenario Creator -->
                    <div style="background: white; padding: 20px 25px 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); min-height: 850px;">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <h3 style="font-size: 18px; font-weight: 600; margin: 0; color: var(--text-dark);">Create New Scenario</h3>
                            <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; color: #64748b;">
                                <span>Preload:</span>
                                <select id="preload-scenario-select" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                    <option value="">None</option>
                                    <option value="baseline">0,5_Baseline_2028</option>
                                </select>
                            </label>
                            <button id="reset-to-preloaded" style="display: none; padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset</button>
                        </div>

                        <!-- Run Controls -->
                        <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                            <!-- Run Mode Selector -->
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 13px; color: #64748b;">Mode:</span>
                                <select id="run-mode-select" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                    <option value="auto">Auto Run</option>
                                    <option value="manual">Manual</option>
                                </select>
                            </div>

                            <!-- Solver Selector -->
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 13px; color: #64748b;">Solver:</span>
                                <select id="solver-select" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                    <option value="highs">HiGHS</option>
                                    <option value="heuristic">Heuristic</option>
                                    <option value="glpk">GLPK</option>
                                </select>
                            </div>

                            <!-- Run Button (only shown in Manual mode) -->
                            <button id="run-new-optimization" style="display: none; padding: 10px 20px; background: var(--cel-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 13px;">Run Optimization</button>

                            <!-- Divider -->
                            <div style="width: 1px; height: 30px; background: #ddd;"></div>

                            <!-- Quick Save Button -->
                            <button id="quick-save-scenario" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 500; cursor: pointer; font-size: 13px;">Quick Save</button>

                            <!-- Save Button -->
                            <button id="save-new-scenario" style="padding: 10px 20px; background: var(--cel-green); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer; font-size: 13px;">Save Scenario</button>

                            <!-- Run Time Indicator -->
                            <span id="run-time-indicator" style="display: none; margin-left: 15px; padding: 6px 12px; background: #e8f4fd; color: var(--cel-blue); border-radius: 4px; font-size: 12px; font-weight: 500;"></span>
                        </div>

                        <!-- Key Indicators -->
                        <div id="live-indicators" class="metrics-grid" style="grid-template-columns: repeat(8, 1fr); margin-bottom: 15px;">
                            <div class="metric-card">
                                <div class="metric-label">Total Cost</div>
                                <div class="metric-sublabel">(M USD)</div>
                                <div class="metric-value" id="live-total-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Transport</div>
                                <div class="metric-sublabel">(M USD)</div>
                                <div class="metric-value" id="live-transport-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Storage</div>
                                <div class="metric-sublabel">(M USD)</div>
                                <div class="metric-value" id="live-storage-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Active DCs</div>
                                <div class="metric-sublabel">-</div>
                                <div class="metric-value" id="live-active-dcs">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Cost per NSV</div>
                                <div class="metric-sublabel">Ratio</div>
                                <div class="metric-value" id="live-cost-per-nsv">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Unit CTS</div>
                                <div class="metric-sublabel">(USD/Pallet)</div>
                                <div class="metric-value" id="live-unit-cost">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">DIO</div>
                                <div class="metric-sublabel">(days)</div>
                                <div class="metric-value" id="live-dio">-</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">Lead Time</div>
                                <div class="metric-sublabel">(days)</div>
                                <div class="metric-value" id="live-lead-time">-</div>
                            </div>
                        </div>

                        <!-- Full width map -->
                        <div style="margin-bottom: 20px;">
                            <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 10px;">Network Preview</h4>
                            <div id="new-scenario-map" style="width: 100%; height: 450px; border: 1px solid #ccc; border-radius: 8px; z-index: 1;"></div>
                            <div style="margin-top: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <p style="margin: 0; font-size: 12px; color: #888; font-style: italic;">Click on an empty space to add a DC or factory. Click on a facility to deactivate or delete it.</p>
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; color: #64748b; white-space: nowrap;">
                                    <input type="checkbox" id="show-volume-circles">
                                    <span>Show DC volume</span>
                                </label>
                            </div>
                            <p style="margin-top: 4px; font-size: 12px; color: #888; font-style: italic;">Note: On manual run, links between facilities are based on distance only and may change after running the optimization.</p>
                            <div id="map-click-popup" style="display: none; position: fixed; background: white; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px; z-index: 1000;">
                                <p style="margin: 0 0 10px 0; font-size: 13px; font-weight: 600;">Add at this location:</p>
                                <div style="display: flex; gap: 8px;">
                                    <button id="popup-add-dc" style="padding: 8px 16px; background: #385D7F; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">DC</button>
                                    <button id="popup-add-factory" style="padding: 8px 16px; background: #CB333B; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Factory</button>
                                    <button id="popup-cancel" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Cancel</button>
                                </div>
                            </div>
                        </div>

                        <!-- Parameters (left) and DC Selection (right) below map -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px;">
                            <!-- Left: Parameters -->
                            <div>
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">Parameters</h4>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">First Mile Rate ($/pallet/1,000km)</label>
                                        <input type="number" id="new-first-mile-rate" value="5.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">Last Mile Rate ($/pallet/1,000km)</label>
                                        <input type="number" id="new-last-mile-rate" value="9.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">Storage Rate ($/pallet/month)</label>
                                        <input type="number" id="new-storage-rate" value="0.30" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-size: 12px; margin-bottom: 4px; color: #64748b;">DIO (days)</label>
                                        <input type="number" id="new-dio" value="30" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    <div style="grid-column: span 2;">
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #64748b; cursor: pointer;">
                                                <input type="checkbox" id="new-min-dc-size-enabled">
                                                Min DC Size
                                            </label>
                                            <input type="number" id="new-min-dc-size" value="500" min="0" style="width: 90px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5;" disabled>
                                            <span style="font-size: 12px; color: #64748b;">pallets</span>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Right: Factory & DC Selection -->
                            <div>
                                <!-- Factory Selection -->
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">Factory Selection</h4>
                                <div id="new-factory-list" style="max-height: 100px; overflow-y: auto; margin-bottom: 15px;"></div>

                                <!-- DC Selection -->
                                <h4 style="font-size: 15px; font-weight: 600; margin-bottom: 12px;">DC Selection</h4>
                                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <button id="select-all-dcs" style="flex: 1; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Select All</button>
                                    <button id="clear-all-dcs" style="flex: 1; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear All</button>
                                </div>
                                <div id="new-dc-list" style="max-height: 180px; overflow-y: auto;"></div>
                            </div>
                        </div>

                    </div>

                    <!-- Scenario Feed (dynamically populated) -->
                    <div id="scenario-feed-controls" style="margin-top: 40px; display: none;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="font-size: 16px; font-weight: 600; color: var(--text-dark); margin: 0;">Scenario Results</h3>
                            <div style="display: flex; gap: 10px;">
                                <button id="expand-all-scenarios" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Expand All</button>
                                <button id="collapse-all-scenarios" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Collapse All</button>
                            </div>
                        </div>
                    </div>
                    <div id="scenario-feed"></div>
                </div>

                <!-- Data Admin Tab -->
                <div class="tab-content" id="data-admin-tab">
                    <h2 class="section-title">Data Admin</h2>

                    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 18px; color: var(--text-dark);">Demand Data</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            Upload a CSV file with columns: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">lat,lng,demand</code>
                        </p>

                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap;">
                            <input type="file" id="demand-csv-input" accept=".csv" style="flex: 1; min-width: 200px;">
                            <button id="load-demand-btn" class="btn" style="padding: 10px 20px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Load CSV</button>
                            <button id="reset-demand-btn" class="btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Reset to Default</button>
                        </div>

                        <div id="demand-data-summary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                <span style="color: #666;">Current Data:</span>
                                <strong><span id="demand-count">0</span> demand points</strong>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Total Volume:</span>
                                <strong><span id="demand-total-volume">0</span> pallets/month</strong>
                            </div>
                        </div>

                        <div id="csv-error" style="color: #d32f2f; margin-top: 15px; padding: 10px; background: #ffebee; border-radius: 4px; display: none;"></div>
                        <div id="csv-success" style="color: #2e7d32; margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;"></div>

                        <!-- Data Table Section -->
                        <div style="margin-top: 20px; border-top: 1px solid #e9ecef; padding-top: 15px;">
                            <div id="demand-table-toggle" style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                                <span id="demand-table-icon" style="font-size: 12px; color: #666;">‚ñ∂</span>
                                <span style="font-weight: 600; color: var(--text-dark);">View Data Table</span>
                            </div>
                            <div id="demand-table-container" style="display: none; margin-top: 15px; max-height: 400px; overflow-y: auto; border: 1px solid #e9ecef; border-radius: 4px;">
                                <table id="demand-data-table" style="width: 100%; border-collapse: collapse; font-size: 13px;">
                                    <thead style="position: sticky; top: 0; background: #f8f9fa;">
                                        <tr>
                                            <th class="sortable-header" data-sort="index" style="padding: 10px; text-align: left; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                # <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                            <th class="sortable-header" data-sort="lat" style="padding: 10px; text-align: right; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                Latitude <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                            <th class="sortable-header" data-sort="lng" style="padding: 10px; text-align: right; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                Longitude <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                            <th class="sortable-header" data-sort="demand" style="padding: 10px; text-align: right; border-bottom: 2px solid #dee2e6; cursor: pointer; user-select: none;">
                                                Demand (pallets) <span class="sort-arrows" style="margin-left: 4px; color: #aaa;">‚Üï</span>
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody id="demand-table-body">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Factory Data Section -->
                    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px; margin-top: 30px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 18px; color: var(--text-dark);">Factory Data</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            Upload a CSV file with columns: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">lat,lng</code>
                        </p>

                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap;">
                            <input type="file" id="factory-csv-input" accept=".csv" style="flex: 1; min-width: 200px;">
                            <button id="load-factory-btn" class="btn" style="padding: 10px 20px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Load CSV</button>
                            <button id="reset-factory-btn" class="btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Reset to Default</button>
                        </div>

                        <div id="factory-data-summary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Current Data:</span>
                                <strong><span id="factory-count">0</span> factories</strong>
                            </div>
                        </div>

                        <div id="factory-csv-error" style="color: #d32f2f; margin-top: 15px; padding: 10px; background: #ffebee; border-radius: 4px; display: none;"></div>
                        <div id="factory-csv-success" style="color: #2e7d32; margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;"></div>
                    </div>

                    <!-- DC Data Section -->
                    <div style="background: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); max-width: 600px; margin-top: 30px;">
                        <h3 style="margin: 0 0 10px 0; font-size: 18px; color: var(--text-dark);">Distribution Center Data</h3>
                        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">
                            Upload a CSV file with columns: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">lat,lng</code>
                        </p>

                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px; flex-wrap: wrap;">
                            <input type="file" id="dc-csv-input" accept=".csv" style="flex: 1; min-width: 200px;">
                            <button id="load-dc-btn" class="btn" style="padding: 10px 20px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Load CSV</button>
                            <button id="reset-dc-btn" class="btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Reset to Default</button>
                        </div>

                        <div id="dc-data-summary" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between;">
                                <span style="color: #666;">Current Data:</span>
                                <strong><span id="dc-count">0</span> distribution centers</strong>
                            </div>
                        </div>

                        <div id="dc-csv-error" style="color: #d32f2f; margin-top: 15px; padding: 10px; background: #ffebee; border-radius: 4px; display: none;"></div>
                        <div id="dc-csv-success" style="color: #2e7d32; margin-top: 15px; padding: 10px; background: #e8f5e9; border-radius: 4px; display: none;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                tab.classList.add('active');
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(tabName + '-tab').classList.add('active');

                // Redraw maps when switching tabs
                if (tabName === 'new-scenario') {
                    setTimeout(() => {
                        if (mapNewScenario) {
                            mapNewScenario.invalidateSize();
                            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                        }
                    }, 100);
                } else if (tabName === 'analytics') {
                    setTimeout(() => {
                        if (mapAnalytics1) {
                            mapAnalytics1.invalidateSize();
                            renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                        }
                        if (mapAnalytics2 && scenario2) {
                            mapAnalytics2.invalidateSize();
                            renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
                        }
                    }, 100);
                }
            });
        });

        // Settings toggle
        document.getElementById('settings-toggle').addEventListener('click', () => {
            const content = document.getElementById('settings-content');
            const icon = document.getElementById('toggle-icon');
            content.classList.toggle('expanded');
            icon.textContent = content.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
        });

        // JavaScript code here
        // ===== LEAFLET MAP INFRASTRUCTURE =====

        // Indonesia map center and bounds
        const INDONESIA_CENTER = [-2.5, 106.0];
        const INDONESIA_ZOOM = 5;

        // Map instances
        let mapAnalytics1 = null;
        let mapAnalytics2 = null;
        let mapNewScenario = null;
        let mapReference = null;
        let mapClustering = null;

        // Marker layer groups (for easy clearing/updating)
        let markersAnalytics1 = null;
        let markersAnalytics2 = null;
        let markersNewScenario = null;
        let markersReference = null;
        let markersClustering = null;
        let voronoiLayer = null;

        // Pending click location for popup
        let pendingClickLocation = null;

        // Volume circle visibility
        let showVolumeCircles = false;

        // Custom icon functions
        // Factory icon: Red square when active, gray dashed outline when inactive
        function createFactoryIcon(factory, isActive = true) {
            const size = 24;
            const bgColor = isActive ? '#CB333B' : '#f5f5f5';
            const textColor = isActive ? 'white' : '#999';
            const border = isActive ? '2px solid white' : '2px dashed #999';
            return L.divIcon({
                className: 'factory-icon',
                html: `<div style="background: ${bgColor}; color: ${textColor}; width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: ${border}; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${factory.id ? factory.id.replace('F','') : 'F'}</div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // DC icon: Blue triangle when active, gray dashed outline when inactive
        function createDCIcon(dc, throughput = 0, isActive = true, showVolume = true) {
            // If showVolume is true, size varies by throughput; otherwise fixed size
            const size = isActive
                ? (showVolume ? Math.max(20, Math.min(40, Math.sqrt(throughput) / 8)) : 20)
                : 18;
            const bgColor = isActive ? '#385D7F' : '#f5f5f5';
            const labelColor = isActive ? '#385D7F' : '#999';
            // Triangle using CSS borders - outer container includes space for label
            return L.divIcon({
                className: 'dc-icon',
                html: `<div style="position: relative; width: ${size}px; height: ${size + 14}px; display: flex; flex-direction: column; align-items: center;">
                    <div style="position: relative; width: ${size}px; height: ${size}px;">
                        <div style="width: 0; height: 0; border-left: ${size/2}px solid transparent; border-right: ${size/2}px solid transparent; border-bottom: ${size}px solid ${isActive ? 'white' : '#999'}; position: absolute; top: 0; left: 0; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.2));"></div>
                        <div style="width: 0; height: 0; border-left: ${(size-4)/2}px solid transparent; border-right: ${(size-4)/2}px solid transparent; border-bottom: ${size-4}px solid ${bgColor}; position: absolute; top: 3px; left: 2px;"></div>
                    </div>
                    <span style="color: ${labelColor}; font-size: 9px; font-weight: bold; white-space: nowrap; text-shadow: 0 0 2px white, 0 0 2px white; margin-top: 2px;">${dc.id.replace('DC','')}</span>
                </div>`,
                iconSize: [size, size + 14],
                iconAnchor: [size/2, size]
            });
        }

        // Demand point icon: Light orange circle
        function createDemandIcon(point) {
            const size = 8;
            return L.divIcon({
                className: 'demand-icon',
                html: `<div style="background: #FFB366; width: ${size}px; height: ${size}px; border-radius: 50%; border: 1px solid #FF8C00; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // Clustered demand point icon with cluster color
        function createClusteredDemandIcon(point, clusterColor) {
            const size = 8;
            return L.divIcon({
                className: 'clustered-demand-icon',
                html: `<div style="background: ${clusterColor}; width: ${size}px; height: ${size}px; border-radius: 50%; border: 1px solid rgba(0,0,0,0.3); box-shadow: 0 1px 2px rgba(0,0,0,0.2);"></div>`,
                iconSize: [size, size],
                iconAnchor: [size/2, size/2]
            });
        }

        // Centroid icon (triangle) with cluster color
        function createCentroidIcon(centroid, clusterIndex, clusterColor) {
            const size = 16;
            return L.divIcon({
                className: 'centroid-icon',
                html: `<div style="position: relative; width: ${size}px; height: ${size + 14}px; display: flex; flex-direction: column; align-items: center;">
                    <div style="width: 0; height: 0; border-left: ${size/2}px solid transparent; border-right: ${size/2}px solid transparent; border-bottom: ${size}px solid ${clusterColor}; filter: drop-shadow(0 2px 2px rgba(0,0,0,0.3));"></div>
                    <span style="color: ${clusterColor}; font-size: 9px; font-weight: bold; white-space: nowrap; text-shadow: 0 0 2px white, 0 0 2px white; margin-top: 2px;">C${clusterIndex + 1}</span>
                </div>`,
                iconSize: [size, size + 14],
                iconAnchor: [size/2, size]
            });
        }

        // Render clustered view on map
        function renderClusteredView(map, markersLayer, demands, clusteringResult, showLines) {
            if (!map || !markersLayer) return;
            markersLayer.clearLayers();

            const { centroids, assignments } = clusteringResult;

            // Add clustered demand points
            demands.forEach((point, i) => {
                const clusterIdx = assignments[i];
                const color = clusterColors[clusterIdx];
                const icon = createClusteredDemandIcon(point, color);
                const marker = L.marker([point.lat, point.lng], { icon: icon });
                marker.bindPopup(`
                    <b>Demand Point</b><br>
                    Demand: ${point.demand.toLocaleString()} pallets<br>
                    Cluster: ${clusterIdx + 1}
                `);
                markersLayer.addLayer(marker);

                // Draw line to centroid if enabled
                if (showLines && centroids[clusterIdx]) {
                    const centroid = centroids[clusterIdx];
                    const line = L.polyline(
                        [[point.lat, point.lng], [centroid.lat, centroid.lng]],
                        { color: color, weight: 1, opacity: 0.4 }
                    );
                    markersLayer.addLayer(line);
                }
            });

            // Add centroids as triangles
            centroids.forEach((centroid, i) => {
                const color = clusterColors[i];
                const icon = createCentroidIcon(centroid, i, color);
                const marker = L.marker([centroid.lat, centroid.lng], { icon: icon });

                const clusterDemand = demands
                    .filter((_, j) => assignments[j] === i)
                    .reduce((sum, p) => sum + p.demand, 0);
                const clusterSize = demands.filter((_, j) => assignments[j] === i).length;

                marker.bindPopup(`
                    <b>Cluster ${i + 1} Centroid</b><br>
                    Points: ${clusterSize}<br>
                    Total Demand: ${clusterDemand.toLocaleString()} pallets<br>
                    Lat: ${centroid.lat.toFixed(4)}<br>
                    Lng: ${centroid.lng.toFixed(4)}
                    ${centroid.isMedoid ? '<br><i>(Medoid - actual demand location)</i>' : ''}
                `);
                markersLayer.addLayer(marker);
            });

            // Still show factories
            factories.forEach(f => {
                const icon = createFactoryIcon(f, f.active);
                const marker = L.marker([f.lat, f.lng], { icon: icon });
                marker.bindPopup(`<b>${f.name || 'Factory'}</b><br>Status: ${f.active ? 'Active' : 'Inactive'}`);
                markersLayer.addLayer(marker);
            });
        }

        // Create Voronoi polygons from centroids
        function createVoronoiPolygons(centroids, bounds) {
            if (!centroids || centroids.length < 2) return [];

            // Convert centroids to points array [lng, lat] for d3-delaunay
            const points = centroids.map(c => [c.lng, c.lat]);

            // Create Delaunay triangulation and Voronoi diagram
            const delaunay = d3.Delaunay.from(points);
            const voronoi = delaunay.voronoi([bounds.west, bounds.south, bounds.east, bounds.north]);

            // Extract polygons for each centroid
            const polygons = [];
            for (let i = 0; i < centroids.length; i++) {
                const cellPolygon = voronoi.cellPolygon(i);
                if (cellPolygon) {
                    // Convert [lng, lat] back to [lat, lng] for Leaflet
                    const latLngs = cellPolygon.map(p => [p[1], p[0]]);
                    polygons.push({
                        index: i,
                        latLngs: latLngs,
                        centroid: centroids[i]
                    });
                }
            }
            return polygons;
        }

        // Render clustering map with Voronoi tiles, demand points, and links
        function renderClusteringMap(options = {}) {
            if (!mapClustering || !markersClustering || !currentClusteringResult) return;

            const { showVoronoi = true, showDemandPoints = true, showLinks = false } = options;
            const { centroids, assignments } = currentClusteringResult;

            // Clear existing layers
            markersClustering.clearLayers();
            if (voronoiLayer) {
                mapClustering.removeLayer(voronoiLayer);
                voronoiLayer = null;
            }

            // Add Voronoi tiles
            if (showVoronoi && centroids.length >= 2) {
                const bounds = {
                    west: 90,
                    east: 145,
                    south: -15,
                    north: 10
                };
                const voronoiPolygons = createVoronoiPolygons(centroids, bounds);
                voronoiLayer = L.layerGroup();

                voronoiPolygons.forEach(poly => {
                    const color = clusterColors[poly.index];
                    const polygon = L.polygon(poly.latLngs, {
                        color: color,
                        weight: 2,
                        fillColor: color,
                        fillOpacity: 0.15,
                        opacity: 0.6
                    });

                    const clusterDemand = newScenarioDemands
                        .filter((_, j) => assignments[j] === poly.index)
                        .reduce((sum, p) => sum + p.demand, 0);
                    const clusterSize = newScenarioDemands.filter((_, j) => assignments[j] === poly.index).length;

                    polygon.bindPopup(`
                        <b>Cluster ${poly.index + 1}</b><br>
                        Points: ${clusterSize}<br>
                        Total Demand: ${clusterDemand.toLocaleString()} pallets
                    `);
                    voronoiLayer.addLayer(polygon);
                });

                voronoiLayer.addTo(mapClustering);
            }

            // Add demand points
            if (showDemandPoints) {
                newScenarioDemands.forEach((point, i) => {
                    const clusterIdx = assignments[i];
                    const color = clusterColors[clusterIdx];
                    const icon = createClusteredDemandIcon(point, color);
                    const marker = L.marker([point.lat, point.lng], { icon: icon });
                    marker.bindPopup(`
                        <b>Demand Point</b><br>
                        Demand: ${point.demand.toLocaleString()} pallets<br>
                        Cluster: ${clusterIdx + 1}
                    `);
                    markersClustering.addLayer(marker);

                    // Draw line to centroid if enabled
                    if (showLinks && centroids[clusterIdx]) {
                        const centroid = centroids[clusterIdx];
                        const line = L.polyline(
                            [[point.lat, point.lng], [centroid.lat, centroid.lng]],
                            { color: color, weight: 1, opacity: 0.4 }
                        );
                        markersClustering.addLayer(line);
                    }
                });
            }

            // Add centroids as triangles
            centroids.forEach((centroid, i) => {
                const color = clusterColors[i];
                const icon = createCentroidIcon(centroid, i, color);
                const marker = L.marker([centroid.lat, centroid.lng], { icon: icon });

                const clusterDemand = newScenarioDemands
                    .filter((_, j) => assignments[j] === i)
                    .reduce((sum, p) => sum + p.demand, 0);
                const clusterSize = newScenarioDemands.filter((_, j) => assignments[j] === i).length;

                marker.bindPopup(`
                    <b>Cluster ${i + 1} Centroid</b><br>
                    Points: ${clusterSize}<br>
                    Total Demand: ${clusterDemand.toLocaleString()} pallets<br>
                    Lat: ${centroid.lat.toFixed(4)}<br>
                    Lng: ${centroid.lng.toFixed(4)}
                    ${centroid.isMedoid ? '<br><i>(Medoid - actual demand location)</i>' : ''}
                `);
                markersClustering.addLayer(marker);
            });

            // Show factories
            factories.forEach(f => {
                const icon = createFactoryIcon(f, f.active);
                const marker = L.marker([f.lat, f.lng], { icon: icon });
                marker.bindPopup(`<b>${f.name || 'Factory'}</b><br>Status: ${f.active ? 'Active' : 'Inactive'}`);
                markersClustering.addLayer(marker);
            });
        }

        // Initialize a Leaflet map
        function initLeafletMap(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return null;

            // Check if map already exists
            if (container._leaflet_id) {
                return null; // Already initialized
            }

            const map = L.map(containerId, {
                center: INDONESIA_CENTER,
                zoom: INDONESIA_ZOOM,
                zoomControl: true
            });

            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                attribution: '¬© OpenStreetMap ¬© CARTO',
                maxZoom: 18
            }).addTo(map);

            return map;
        }

        // Initialize all maps (called after DOM ready)
        function initAllMaps() {
            // Analytics maps
            mapAnalytics1 = initLeafletMap('map-analytics-1');
            if (mapAnalytics1) {
                markersAnalytics1 = L.layerGroup().addTo(mapAnalytics1);
            }

            mapAnalytics2 = initLeafletMap('map-analytics-2');
            if (mapAnalytics2) {
                markersAnalytics2 = L.layerGroup().addTo(mapAnalytics2);
            }

            // New Scenario map (main interactive map)
            mapNewScenario = initLeafletMap('new-scenario-map');
            if (mapNewScenario) {
                markersNewScenario = L.layerGroup().addTo(mapNewScenario);
                // Ensure scroll wheel zoom is always enabled
                mapNewScenario.scrollWheelZoom.enable();

                // Click to add DC or Factory - show popup
                mapNewScenario.on('click', function(e) {
                    pendingClickLocation = e.latlng;
                    const popup = document.getElementById('map-click-popup');
                    const mapContainer = document.getElementById('new-scenario-map');
                    const mapRect = mapContainer.getBoundingClientRect();
                    const point = mapNewScenario.latLngToContainerPoint(e.latlng);
                    popup.style.left = (mapRect.left + point.x + 10) + 'px';
                    popup.style.top = (mapRect.top + point.y - 30) + 'px';
                    popup.style.display = 'block';
                });
            }

            // Reference map
            mapReference = initLeafletMap('reference-map');
            if (mapReference) {
                markersReference = L.layerGroup().addTo(mapReference);
            }
        }

        // Find nearest active factory to a DC
        function findNearestActiveFactory(dc) {
            const activeFactories = factories.filter(f => f.active);
            if (activeFactories.length === 0) return null;

            let nearest = null;
            let minDist = Infinity;
            activeFactories.forEach(f => {
                const dist = distance(f, dc);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = f;
                }
            });
            return nearest;
        }

        // Render markers on a map
        function renderMapMarkers(map, markersLayer, dcs, demands, interactive = false) {
            if (!map || !markersLayer) return;

            markersLayer.clearLayers();

            // Add factory markers
            factories.forEach(f => {
                const icon = createFactoryIcon(f, f.active);
                const marker = L.marker([f.lat, f.lng], {icon: icon});

                // Popup content with action buttons for interactive maps
                const popupContent = `
                    <div>
                        <b>${f.name || 'Factory'}</b><br>
                        Status: ${f.active ? 'Active' : 'Inactive'}
                        ${interactive ? `
                            <div style="margin-top: 10px; display: flex; gap: 8px;">
                                <button onclick="window.toggleFactoryFromPopup('${f.id}')" style="padding: 4px 10px; background: ${f.active ? '#ffc107' : '#28a745'}; color: ${f.active ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    ${f.active ? 'Deactivate' : 'Activate'}
                                </button>
                                <button onclick="window.deleteFactoryFromPopup('${f.id}')" style="padding: 4px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
                marker.bindPopup(popupContent);
                markersLayer.addLayer(marker);
            });

            // Add DC markers (size varies by throughput when showVolumeCircles is on)
            // DCs with zero throughput are displayed as inactive (even if dc.active is true)
            dcs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                // Show as inactive if dc.active is false OR if throughput is 0
                const displayAsActive = dc.active && throughput > 0;

                const icon = createDCIcon(dc, throughput, displayAsActive, showVolumeCircles);
                const marker = L.marker([dc.lat, dc.lng], {icon: icon});

                // Popup content with action buttons for interactive maps
                const popupId = `dc-popup-${dc.id}`;
                const statusText = !dc.active ? 'Inactive' : (throughput > 0 ? 'Active' : 'Active (unused)');
                const popupContent = `
                    <div id="${popupId}">
                        <b>${dc.name}</b><br>
                        Status: ${statusText}<br>
                        Throughput: ${throughput.toLocaleString()} pallets
                        ${interactive ? `
                            <div style="margin-top: 10px; display: flex; gap: 8px;">
                                <button onclick="window.toggleDCFromPopup('${dc.id}')" style="padding: 4px 10px; background: ${dc.active ? '#ffc107' : '#28a745'}; color: ${dc.active ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    ${dc.active ? 'Deactivate' : 'Activate'}
                                </button>
                                <button onclick="window.deleteDCFromPopup('${dc.id}')" style="padding: 4px 10px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        ` : ''}
                    </div>
                `;
                marker.bindPopup(popupContent);

                markersLayer.addLayer(marker);
            });

            // Add demand points as light orange circle markers (always visible)
            demands.forEach(point => {
                const circle = L.circleMarker([point.lat, point.lng], {
                    radius: 4,
                    fillColor: '#FFB366',
                    color: '#FF8C00',
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.7
                });
                circle.bindPopup(`Demand: ${point.demand.toLocaleString()} pallets<br>Cluster: ${point.cluster}`);
                markersLayer.addLayer(circle);
            });

            // Draw flow lines (first mile and last mile)
            const activeDCs = dcs.filter(dc => dc.active);

            // First mile lines (factory to DCs) - clickable with popup
            // Each DC connects to its nearest active factory
            activeDCs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const nearestFactory = findNearestActiveFactory(dc);
                if (throughput > 0 && nearestFactory) {
                    const line = L.polyline([[nearestFactory.lat, nearestFactory.lng], [dc.lat, dc.lng]], {
                        color: '#385D7F',
                        weight: 3,
                        opacity: 0.6
                    });
                    line.bindPopup(`
                        <b>First Mile</b><br>
                        <b>Origin:</b> ${nearestFactory.name}<br>
                        <b>Destination:</b> ${dc.name}<br>
                        <b>Volume:</b> ${throughput.toLocaleString()} pallets/month
                    `);
                    markersLayer.addLayer(line);
                }
            });

            // Last mile lines (DCs to demand points) - clickable with popup
            demands.forEach(point => {
                let assignedDC = point.assignedDC;
                if (!assignedDC || !dcs.includes(assignedDC)) {
                    assignedDC = dcs.find(dc => dc.id === point.assignedDCId);
                }
                if (assignedDC && assignedDC.active) {
                    const line = L.polyline([[assignedDC.lat, assignedDC.lng], [point.lat, point.lng]], {
                        color: '#FE5000',
                        weight: 2,
                        opacity: 0.4
                    });
                    line.bindPopup(`
                        <b>Last Mile</b><br>
                        <b>Origin:</b> ${assignedDC.name}<br>
                        <b>Destination:</b> Cluster ${point.cluster}<br>
                        <b>Volume:</b> ${point.demand.toLocaleString()} pallets/month
                    `);
                    markersLayer.addLayer(line);
                }
            });
        }

        // Legacy function names for compatibility
        // Draw map using Leaflet
        function drawMap() {
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (scenario2 && mapAnalytics2 && markersAnalytics2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        }

        // Initialize maps when DOM is ready
        setTimeout(initAllMaps, 100);

        // Data structures - Indonesia coordinates (lat/lng)
        let demandPoints = [];
        let dcLocations = [
            {id: 'DC1', name: 'Medan Hub', lat: 3.5952, lng: 98.6722, active: true},
            {id: 'DC2', name: 'Pekanbaru Hub', lat: 0.5071, lng: 101.4478, active: false},
            {id: 'DC3', name: 'Palembang Hub', lat: -2.9761, lng: 104.7754, active: true},
            {id: 'DC4', name: 'Lampung Hub', lat: -5.4294, lng: 105.2610, active: false},
            {id: 'DC5', name: 'Jakarta Hub', lat: -6.2088, lng: 106.8456, active: true},
            {id: 'DC6', name: 'Bandung Hub', lat: -6.9175, lng: 107.6191, active: false},
            {id: 'DC7', name: 'Semarang Hub', lat: -6.9666, lng: 110.4196, active: true},
            {id: 'DC8', name: 'Yogyakarta Hub', lat: -7.7956, lng: 110.3695, active: false},
            {id: 'DC9', name: 'Surabaya Hub', lat: -7.2575, lng: 112.7521, active: true},
            {id: 'DC10', name: 'Malang Hub', lat: -7.9666, lng: 112.6326, active: false},
            {id: 'DC11', name: 'Padang Hub', lat: -0.9471, lng: 100.4172, active: false},
            {id: 'DC12', name: 'Jambi Hub', lat: -1.6101, lng: 103.6131, active: false}
        ];
        let factories = [
            {id: 'F1', name: 'Jatake, Tangerang', lat: -6.1897, lng: 106.5108, active: true}
        ];
        // For backward compatibility
        const factory = factories[0];

        // Scenario storage
        let scenario1 = {
            demandPoints: [],
            dcLocations: JSON.parse(JSON.stringify(dcLocations)),
            name: '0,5_Baseline_2028'
        };
        let scenario2 = null;

        // Seeded random number generator for consistent demand generation
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        // Generate demand points - Indonesia coordinates
        // Target: ~350k pallets/month (50x scale for realistic unit costs)
        function generateDemandPoints() {
            demandPoints = [];
            const random = seededRandom(12345); // Fixed seed for consistent results
            // Clusters around major Indonesian cities
            const clusters = [
                // Cluster A: Greater Jakarta area (West Java)
                {center: {lat: -6.2088, lng: 106.8456}, spread: 0.5, count: 25, demandRange: [1600, 4500], id: 'A'},
                // Cluster B: Surabaya / East Java
                {center: {lat: -7.2575, lng: 112.7521}, spread: 0.6, count: 20, demandRange: [3650, 7700], id: 'B'},
                // Cluster C: Bandung / West Java
                {center: {lat: -6.9175, lng: 107.6191}, spread: 0.4, count: 20, demandRange: [1600, 3650], id: 'C'},
                // Cluster D: Medan / North Sumatra
                {center: {lat: 3.5952, lng: 98.6722}, spread: 0.5, count: 15, demandRange: [2000, 4650], id: 'D'},
                // Cluster E: Semarang / Central Java
                {center: {lat: -6.9666, lng: 110.4196}, spread: 0.4, count: 12, demandRange: [2650, 6300], id: 'E'}
            ];
            clusters.forEach(cluster => {
                for (let i = 0; i < cluster.count; i++) {
                    const lat = cluster.center.lat + (random() - 0.5) * cluster.spread;
                    const lng = cluster.center.lng + (random() - 0.5) * cluster.spread;
                    const demand = Math.floor(random() * (cluster.demandRange[1] - cluster.demandRange[0]) + cluster.demandRange[0]);
                    demandPoints.push({lat, lng, demand, cluster: cluster.id, assignedDC: null, distance: 0});
                }
            });
            // Scattered points across Sumatra and Java
            const scatteredAreas = [
                {latMin: -8, latMax: -6, lngMin: 105, lngMax: 114}, // Java
                {latMin: -3, latMax: 4, lngMin: 98, lngMax: 105}    // Sumatra
            ];
            for (let i = 0; i < 12; i++) {
                const area = scatteredAreas[i < 8 ? 0 : 1]; // More in Java
                const lat = area.latMin + random() * (area.latMax - area.latMin);
                const lng = area.lngMin + random() * (area.lngMax - area.lngMin);
                const demand = Math.floor(random() * 1600 + 800);
                demandPoints.push({lat, lng, demand, cluster: 'scattered', assignedDC: null, distance: 0});
            }
        }

        // Parse demand data from CSV
        function parseDemandsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');
            const demandIdx = header.indexOf('demand');

            if (latIdx === -1 || lngIdx === -1 || demandIdx === -1) {
                throw new Error('CSV must have columns: lat, lng, demand');
            }

            const demands = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines

                // Split by comma and reconstruct demand if it contains commas
                const allValues = line.split(',').map(v => v.trim());

                // If we have more than 3 values, the demand column has commas - rejoin them
                let lat, lng, demandStr;
                if (allValues.length === 3) {
                    // Simple case: no commas in numbers
                    lat = parseFloat(allValues[latIdx]);
                    lng = parseFloat(allValues[lngIdx]);
                    demandStr = allValues[demandIdx];
                } else {
                    // Demand has commas - first two are lat/lng, rest is demand
                    lat = parseFloat(allValues[0]);
                    lng = parseFloat(allValues[1]);
                    // Join all remaining parts and remove commas
                    demandStr = allValues.slice(2).join('');
                }

                // Remove any remaining commas from demand string
                const demand = parseFloat(demandStr.replace(/,/g, ''));

                if (isNaN(lat) || isNaN(lng) || isNaN(demand)) {
                    throw new Error(`Invalid data on row ${i + 1}: lat=${allValues[0]}, lng=${allValues[1]}, demand=${demandStr}`);
                }

                demands.push({ lat, lng, demand: Math.round(demand), cluster: i, assignedDC: null, distance: 0 });
            }

            if (demands.length === 0) {
                throw new Error('No valid demand points found in CSV');
            }

            return demands;
        }

        // Parse factory data from CSV
        function parseFactoriesCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');

            if (latIdx === -1 || lngIdx === -1) {
                throw new Error('CSV must have columns: lat, lng');
            }

            const newFactories = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',').map(v => v.trim());
                if (values.length < 2) continue;

                const lat = parseFloat(values[latIdx]);
                const lng = parseFloat(values[lngIdx]);

                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error(`Invalid data on row ${i + 1}: lat=${values[latIdx]}, lng=${values[lngIdx]}`);
                }

                newFactories.push({
                    id: 'F' + i,
                    name: 'Factory ' + i,
                    lat,
                    lng,
                    active: true
                });
            }

            if (newFactories.length === 0) {
                throw new Error('No valid factory locations found in CSV');
            }

            return newFactories;
        }

        // Parse DC data from CSV
        function parseDCsCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV must have header row and at least one data row');
            }

            const header = lines[0].toLowerCase().split(',').map(h => h.trim());
            const latIdx = header.indexOf('lat');
            const lngIdx = header.indexOf('lng');

            if (latIdx === -1 || lngIdx === -1) {
                throw new Error('CSV must have columns: lat, lng');
            }

            const newDCs = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const values = line.split(',').map(v => v.trim());
                if (values.length < 2) continue;

                const lat = parseFloat(values[latIdx]);
                const lng = parseFloat(values[lngIdx]);

                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error(`Invalid data on row ${i + 1}: lat=${values[latIdx]}, lng=${values[lngIdx]}`);
                }

                newDCs.push({
                    id: 'DC' + i,
                    name: 'DC ' + i,
                    lat,
                    lng,
                    active: true
                });
            }

            if (newDCs.length === 0) {
                throw new Error('No valid DC locations found in CSV');
            }

            return newDCs;
        }

        // Update demand summary display
        function updateDemandSummary() {
            const countEl = document.getElementById('demand-count');
            const volumeEl = document.getElementById('demand-total-volume');
            if (countEl && volumeEl) {
                countEl.textContent = demandPoints.length;
                const totalVol = demandPoints.reduce((sum, p) => sum + p.demand, 0);
                volumeEl.textContent = totalVol.toLocaleString();
            }
            // Update data table
            updateDemandTable();
        }

        // Update factory summary display
        function updateFactorySummary() {
            const countEl = document.getElementById('factory-count');
            if (countEl) {
                countEl.textContent = factories.length;
            }
        }

        // Update DC summary display
        function updateDCSummary() {
            const countEl = document.getElementById('dc-count');
            if (countEl) {
                countEl.textContent = dcLocations.length;
            }
        }

        // Table sorting state
        let tableSortColumn = 'index';
        let tableSortDirection = 'asc';

        // Update demand data table
        function updateDemandTable() {
            const tbody = document.getElementById('demand-table-body');
            if (!tbody) return;

            // Create indexed copy for sorting
            const indexedData = demandPoints.map((p, i) => ({ ...p, originalIndex: i + 1 }));

            // Sort data
            indexedData.sort((a, b) => {
                let valA, valB;
                switch (tableSortColumn) {
                    case 'index': valA = a.originalIndex; valB = b.originalIndex; break;
                    case 'lat': valA = a.lat; valB = b.lat; break;
                    case 'lng': valA = a.lng; valB = b.lng; break;
                    case 'demand': valA = a.demand; valB = b.demand; break;
                    default: valA = a.originalIndex; valB = b.originalIndex;
                }
                return tableSortDirection === 'asc' ? valA - valB : valB - valA;
            });

            tbody.innerHTML = indexedData.map(p => `
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px 10px; color: #666;">${p.originalIndex}</td>
                    <td style="padding: 8px 10px; text-align: right;">${p.lat.toFixed(4)}</td>
                    <td style="padding: 8px 10px; text-align: right;">${p.lng.toFixed(4)}</td>
                    <td style="padding: 8px 10px; text-align: right; font-weight: 500;">${p.demand.toLocaleString()}</td>
                </tr>
            `).join('');

            // Update sort indicators
            document.querySelectorAll('.sortable-header').forEach(header => {
                const arrows = header.querySelector('.sort-arrows');
                const col = header.getAttribute('data-sort');
                if (col === tableSortColumn) {
                    arrows.textContent = tableSortDirection === 'asc' ? '‚Üë' : '‚Üì';
                    arrows.style.color = 'var(--cel-dark-blue)';
                } else {
                    arrows.textContent = '‚Üï';
                    arrows.style.color = '#aaa';
                }
            });
        }

        // Distance calculation - Haversine formula for lat/lng
        function distance(p1, p2) {
            const R = 6371; // Earth radius in km
            const dLat = (p2.lat - p1.lat) * Math.PI / 180;
            const dLng = (p2.lng - p1.lng) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) *
                      Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            let dist = R * c; // Distance in km

            // Sea crossing penalty: Sumatra (lng < 106) to Java (lng > 106) via Sunda Strait
            const crossesSea = (p1.lng < 106 && p2.lng > 106) || (p1.lng > 106 && p2.lng < 106);
            if (crossesSea) dist *= 1.3; // 30% penalty for sea crossing

            return dist;
        }

        // ===== CLUSTERING FUNCTIONS =====

        // Generate N distinct colors using golden angle distribution
        function generateClusterColors(n) {
            const colors = [];
            const goldenAngle = 137.508; // Golden angle in degrees

            for (let i = 0; i < n; i++) {
                // Hue: Use golden angle distribution for maximum separation
                const hue = (i * goldenAngle) % 360;
                // Saturation: Vary between 65-90% for vibrancy
                const saturation = 65 + (i % 3) * 12.5;
                // Lightness: Vary between 45-60% for visibility
                const lightness = 45 + (i % 4) * 5;

                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }

            return colors;
        }

        // Calculate demand-weighted centroid (center of gravity)
        function calculateWeightedCentroid(clusterPoints) {
            if (clusterPoints.length === 0) return null;

            let sumWeightedLat = 0;
            let sumWeightedLng = 0;
            let totalDemand = 0;

            clusterPoints.forEach(point => {
                sumWeightedLat += point.lat * point.demand;
                sumWeightedLng += point.lng * point.demand;
                totalDemand += point.demand;
            });

            return {
                lat: sumWeightedLat / totalDemand,
                lng: sumWeightedLng / totalDemand,
                totalDemand: totalDemand
            };
        }

        // K-Means++ initialization for better starting centroids
        function initializeCentroidsKMeansPlusPlus(points, k) {
            const centroids = [];

            // First centroid: weighted random selection (favor high-demand points)
            const totalDemand = points.reduce((sum, p) => sum + p.demand, 0);
            let r = Math.random() * totalDemand;
            for (const point of points) {
                r -= point.demand;
                if (r <= 0) {
                    centroids.push({ lat: point.lat, lng: point.lng });
                    break;
                }
            }

            // Remaining centroids: probability proportional to squared distance * demand
            while (centroids.length < k) {
                const distances = points.map(p => {
                    const minDist = Math.min(...centroids.map(c => distance(p, c)));
                    return minDist * minDist * p.demand; // Weight by demand
                });

                const totalWeight = distances.reduce((a, b) => a + b, 0);
                r = Math.random() * totalWeight;

                for (let i = 0; i < points.length; i++) {
                    r -= distances[i];
                    if (r <= 0) {
                        centroids.push({ lat: points[i].lat, lng: points[i].lng });
                        break;
                    }
                }
            }

            return centroids;
        }

        // Weighted K-Means clustering algorithm
        function weightedKMeans(points, k, maxIterations = 100) {
            if (points.length === 0 || k <= 0) return { centroids: [], assignments: [], iterations: 0 };
            if (k > points.length) k = points.length;

            // Initialize centroids using K-Means++ strategy
            let centroids = initializeCentroidsKMeansPlusPlus(points, k);

            let assignments = new Array(points.length).fill(0);
            let changed = true;
            let iterations = 0;

            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;

                // Assignment step: assign each point to nearest centroid
                points.forEach((point, i) => {
                    let minDist = Infinity;
                    let bestCluster = 0;

                    centroids.forEach((centroid, j) => {
                        const dist = distance(point, centroid);
                        if (dist < minDist) {
                            minDist = dist;
                            bestCluster = j;
                        }
                    });

                    if (assignments[i] !== bestCluster) {
                        assignments[i] = bestCluster;
                        changed = true;
                    }
                });

                // Update step: recalculate weighted centroids
                const newCentroids = [];
                for (let j = 0; j < k; j++) {
                    const clusterPoints = points.filter((_, i) => assignments[i] === j);
                    if (clusterPoints.length > 0) {
                        newCentroids.push(calculateWeightedCentroid(clusterPoints));
                    } else {
                        // Keep old centroid for empty clusters
                        newCentroids.push(centroids[j]);
                    }
                }
                centroids = newCentroids;
            }

            return { centroids, assignments, iterations };
        }

        // Weighted K-Medoids clustering algorithm (PAM-like)
        function weightedKMedoids(points, k, maxIterations = 50) {
            if (points.length === 0 || k <= 0) return { centroids: [], assignments: [], iterations: 0 };
            if (k > points.length) k = points.length;

            // Initialize medoids using demand-weighted random selection
            const medoidIndices = [];
            const totalDemand = points.reduce((sum, p) => sum + p.demand, 0);
            const used = new Set();

            while (medoidIndices.length < k) {
                let r = Math.random() * totalDemand;
                for (let i = 0; i < points.length; i++) {
                    if (used.has(i)) continue;
                    r -= points[i].demand;
                    if (r <= 0) {
                        medoidIndices.push(i);
                        used.add(i);
                        break;
                    }
                }
                // Fallback: add any unused point
                if (medoidIndices.length < k && medoidIndices.length === used.size) {
                    for (let i = 0; i < points.length; i++) {
                        if (!used.has(i)) {
                            medoidIndices.push(i);
                            used.add(i);
                            break;
                        }
                    }
                }
            }

            let assignments = new Array(points.length).fill(0);
            let changed = true;
            let iterations = 0;

            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;

                // Assignment step: assign each point to nearest medoid
                points.forEach((point, i) => {
                    let minDist = Infinity;
                    let bestMedoid = 0;

                    medoidIndices.forEach((mi, j) => {
                        const dist = distance(point, points[mi]);
                        if (dist < minDist) {
                            minDist = dist;
                            bestMedoid = j;
                        }
                    });

                    if (assignments[i] !== bestMedoid) {
                        assignments[i] = bestMedoid;
                        changed = true;
                    }
                });

                // Swap step: try to improve each medoid by finding better point in cluster
                for (let j = 0; j < k; j++) {
                    const clusterIndices = points
                        .map((_, i) => i)
                        .filter(i => assignments[i] === j);

                    if (clusterIndices.length === 0) continue;

                    // Find point with minimum weighted total distance to other cluster points
                    let bestCost = Infinity;
                    let bestIndex = medoidIndices[j];

                    clusterIndices.forEach(candidateIdx => {
                        let cost = 0;
                        clusterIndices.forEach(otherIdx => {
                            cost += distance(points[candidateIdx], points[otherIdx]) * points[otherIdx].demand;
                        });

                        if (cost < bestCost) {
                            bestCost = cost;
                            bestIndex = candidateIdx;
                        }
                    });

                    if (bestIndex !== medoidIndices[j]) {
                        medoidIndices[j] = bestIndex;
                        changed = true;
                    }
                }
            }

            // Convert medoid indices to centroid objects
            const centroids = medoidIndices.map((mi, j) => {
                const clusterPoints = points.filter((_, i) => assignments[i] === j);
                const totalClusterDemand = clusterPoints.reduce((sum, p) => sum + p.demand, 0);
                return {
                    lat: points[mi].lat,
                    lng: points[mi].lng,
                    totalDemand: totalClusterDemand,
                    isMedoid: true,
                    sourcePointIndex: mi
                };
            });

            return { centroids, assignments, iterations };
        }

        // ===== END CLUSTERING FUNCTIONS =====

        // Assign customers to DCs
        function assignCustomers() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            demandPoints.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) { // Assign to nearest DC regardless of distance to fulfill all demand
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null; // Store DC ID for cloning
                point.distance = minDist;
            });
        }

        // Assign customers to DCs (for scenario data with separate DC arrays)
        function assignCustomersToScenario(demands, dcs) {
            const activeDCs = dcs.filter(dc => dc.active);
            demands.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null;
                point.distance = minDist;
            });
        }

        // Calculate costs
        function calculateCosts() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value) / 1000;
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value) / 1000;
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);
            const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled')?.checked || false;
            const minDCSize = parseInt(document.getElementById('new-min-dc-size')?.value || 500);

            // First mile (each DC connects to nearest active factory)
            activeDCs.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                if (!nearestFactory) return; // No active factories
                const dist = distance(nearestFactory, dc);
                if (dist > 4000) return; // SLA violation, but for now ignore
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate;
            });

            // Last mile and storage
            activeDCs.forEach(dc => {
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                const avgInventory = throughput * (dio / 365);
                // Apply minimum DC size if enabled
                const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                totalStorage += billableInventory * storageRate * 12;
                demandPoints.filter(p => p.assignedDC === dc).forEach(p => {
                    totalTransport += p.distance * p.demand * lastMileRate;
                });
            });

            return {total: totalTransport + totalStorage, transport: totalTransport, storage: totalStorage, activeDCs: activeDCs.length};
        }

        // Draw map using Leaflet
        function drawMap() {
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (scenario2 && mapAnalytics2 && markersAnalytics2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        }

        // Note: Tooltips are now handled by Leaflet popups on markers

        // Optimization function
        function optimize() {
            // Heuristic optimization
            // Step 1: Activate all feasible DCs (distance from nearest active factory <= 4000 km)
            dcLocations.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                dc.active = nearestFactory ? distance(nearestFactory, dc) <= 4000 : false;
            });
            assignCustomers();
            
            // Step 2: Local search - try closing DCs that don't reduce total cost
            let improved = true;
            let iterations = 0;
            while (improved && iterations < 10) { // Limit iterations
                improved = false;
                iterations++;
                const currentCosts = calculateCosts();
                for (let i = 0; i < dcLocations.length; i++) {
                    if (!dcLocations[i].active) continue;
                    // Try closing this DC
                    dcLocations[i].active = false;
                    assignCustomers();
                    const trialCosts = calculateCosts();
                    if (trialCosts.total < currentCosts.total) {
                        // Keep closed
                        improved = true;
                        break; // Accept first improvement
                    } else {
                        // Reopen
                        dcLocations[i].active = true;
                    }
                }
            }
            assignCustomers();
        }

        // ===== MIP SOLVER IMPLEMENTATIONS =====

        // Global solver instances (initialized lazily)
        let highsInstance = null;
        let glpkInstance = null;

        // Initialize HiGHS solver
        async function initHiGHS() {
            if (highsInstance) return highsInstance;
            try {
                // HiGHS from CDN exposes a global 'highs' factory function
                if (typeof highs === 'undefined') {
                    throw new Error('HiGHS library not loaded');
                }
                highsInstance = await highs({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/highs@1.8.0/build/${file}`
                });
                console.log('HiGHS initialized successfully');
                return highsInstance;
            } catch (e) {
                console.error('Failed to initialize HiGHS:', e);
                throw e;
            }
        }

        // Initialize GLPK solver
        async function initGLPK() {
            if (glpkInstance) return glpkInstance;
            try {
                if (typeof GLPK === 'undefined') {
                    throw new Error('GLPK library not loaded');
                }
                glpkInstance = await GLPK();
                console.log('GLPK initialized successfully');
                return glpkInstance;
            } catch (e) {
                console.error('Failed to initialize GLPK:', e);
                throw e;
            }
        }

        // Optimized greedy solver (better than simple heuristic, faster than MIP)
        function optimizeGreedy(targetDCs, targetDemands, params) {
            const { firstMileRate, lastMileRate, storageRate, dio, minDCSizeEnabled, minDCSize } = params;

            // Calculate cost for a given DC configuration
            function calcTotalCost() {
                const activeDCs = targetDCs.filter(dc => dc.active);
                if (activeDCs.length === 0) return Infinity;

                let total = 0;
                targetDemands.forEach(point => {
                    let minDist = Infinity;
                    let bestDC = null;
                    activeDCs.forEach(dc => {
                        const dist = distance(point, dc);
                        if (dist < minDist) {
                            minDist = dist;
                            bestDC = dc;
                        }
                    });
                    if (bestDC) {
                        // Last mile cost
                        total += minDist * point.demand * lastMileRate / 1000 * 12;
                        point.assignedDC = bestDC;
                        point.distance = minDist;
                    }
                });

                // First mile and storage costs
                activeDCs.forEach(dc => {
                    const throughput = targetDemands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                    const nearestFactory = findNearestActiveFactory(dc);
                    const distFromFactory = nearestFactory ? distance(nearestFactory, dc) : 0;
                    total += distFromFactory * throughput * firstMileRate / 1000 * 12;
                    const avgInventory = throughput * (dio / 365);
                    // Apply minimum DC size if enabled
                    const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                    total += billableInventory * storageRate * 12;
                });

                return total;
            }

            // Start with all DCs active
            targetDCs.forEach(dc => dc.active = true);
            let bestCost = calcTotalCost();

            // Greedy removal - keep removing DCs while cost improves
            let improved = true;
            while (improved) {
                improved = false;
                let bestRemoval = -1;
                let bestNewCost = bestCost;

                for (let i = 0; i < targetDCs.length; i++) {
                    if (!targetDCs[i].active) continue;

                    targetDCs[i].active = false;
                    const newCost = calcTotalCost();

                    if (newCost < bestNewCost) {
                        bestNewCost = newCost;
                        bestRemoval = i;
                    }

                    targetDCs[i].active = true;
                }

                if (bestRemoval >= 0) {
                    targetDCs[bestRemoval].active = false;
                    bestCost = bestNewCost;
                    improved = true;
                }
            }

            // Final assignment
            calcTotalCost();
        }

        // HiGHS optimization
        async function optimizeWithHiGHS(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value);
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value);
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            try {
                const solver = await initHiGHS();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate assignment costs for each customer to each DC
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const nearestFactory = findNearestActiveFactory(dc);
                        const firstMileDist = nearestFactory ? distance(nearestFactory, dc) : 0;

                        const unitCost = (lastMileDist * lastMileRate / 1000 +
                                         firstMileDist * firstMileRate / 1000 +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build LP string
                let lp = 'Minimize\n obj:';
                const terms = [];

                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        terms.push(` ${costs[c][d].toFixed(2)} x${c}_${d}`);
                    }
                }
                lp += terms.join(' +') + '\n';

                lp += 'Subject To\n';

                // Each customer assigned to exactly one DC
                for (let c = 0; c < numCustomers; c++) {
                    const assignTerms = [];
                    for (let d = 0; d < numDCs; d++) {
                        assignTerms.push(`x${c}_${d}`);
                    }
                    lp += ` c${c}: ${assignTerms.join(' + ')} = 1\n`;
                }

                // Linking: x[c,d] <= y[d]
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` l${c}_${d}: x${c}_${d} - y${d} <= 0\n`;
                    }
                }

                lp += 'Binary\n';
                for (let d = 0; d < numDCs; d++) {
                    lp += ` y${d}\n`;
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` x${c}_${d}\n`;
                    }
                }
                lp += 'End\n';

                console.log('Solving with HiGHS...');
                const result = solver.solve(lp);
                console.log('HiGHS result:', result);

                if (result.Status === 'Optimal') {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.Columns[`y${d}`]?.Primal || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.ObjectiveValue };
                } else {
                    throw new Error('HiGHS status: ' + result.Status);
                }
            } catch (e) {
                console.error('HiGHS failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled')?.checked || false;
                const minDCSize = parseInt(document.getElementById('new-min-dc-size')?.value || 500);
                const params = { firstMileRate, lastMileRate, storageRate, dio, minDCSizeEnabled, minDCSize };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // GLPK optimization
        async function optimizeWithGLPK(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value);
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value);
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            try {
                const glpk = await initGLPK();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate costs
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const nearestFactory = findNearestActiveFactory(dc);
                        const firstMileDist = nearestFactory ? distance(nearestFactory, dc) : 0;

                        const unitCost = (lastMileDist * lastMileRate / 1000 +
                                         firstMileDist * firstMileRate / 1000 +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build objective
                const objective = [];
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        objective.push({ name: `x${c}_${d}`, coef: costs[c][d] });
                    }
                }

                // Build constraints
                const subjectTo = [];

                // Assignment constraints
                for (let c = 0; c < numCustomers; c++) {
                    const vars = [];
                    for (let d = 0; d < numDCs; d++) {
                        vars.push({ name: `x${c}_${d}`, coef: 1 });
                    }
                    subjectTo.push({
                        name: `assign${c}`,
                        vars: vars,
                        bnds: { type: glpk.GLP_FX, lb: 1, ub: 1 }
                    });
                }

                // Linking constraints
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        subjectTo.push({
                            name: `link${c}_${d}`,
                            vars: [
                                { name: `x${c}_${d}`, coef: 1 },
                                { name: `y${d}`, coef: -1 }
                            ],
                            bnds: { type: glpk.GLP_UP, lb: 0, ub: 0 }
                        });
                    }
                }

                // Binary variables list
                const binaries = [];
                for (let d = 0; d < numDCs; d++) {
                    binaries.push(`y${d}`);
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        binaries.push(`x${c}_${d}`);
                    }
                }

                const model = {
                    name: 'FacilityLocation',
                    objective: {
                        direction: glpk.GLP_MIN,
                        name: 'cost',
                        vars: objective
                    },
                    subjectTo: subjectTo,
                    binaries: binaries
                };

                console.log('Solving with GLPK...');
                const result = await glpk.solve(model, { msglev: glpk.GLP_MSG_OFF });
                console.log('GLPK result:', result);

                if (result.result.status === glpk.GLP_OPT) {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.result.vars[`y${d}`] || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.result.z };
                } else {
                    throw new Error('GLPK status: ' + result.result.status);
                }
            } catch (e) {
                console.error('GLPK failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled')?.checked || false;
                const minDCSize = parseInt(document.getElementById('new-min-dc-size')?.value || 500);
                const params = { firstMileRate, lastMileRate, storageRate, dio, minDCSizeEnabled, minDCSize };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // Unified optimization function that uses selected solver
        async function runOptimization(solver = 'heuristic') {
            const startTime = performance.now();
            let result;

            try {
                if (solver === 'heuristic') {
                    optimize();
                    result = { success: true };
                } else if (solver === 'highs') {
                    result = await optimizeWithHiGHS();
                } else if (solver === 'glpk') {
                    result = await optimizeWithGLPK();
                }
            } catch (e) {
                console.error('Optimization error:', e);
                alert('Optimization failed: ' + e.message);
                result = { success: false };
            }

            const endTime = performance.now();
            const solveTime = Math.round(endTime - startTime);

            return { ...result, solveTime, solver };
        }

        // Update results
        let comparisonScenario = null;

        // Helper function to generate metrics HTML
        function generateMetricsHTML(dcs, demands, scenarioName, params = null) {
            // Calculate costs for this scenario
            const activeDCs = dcs.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;

            // Use provided params or get from settings inputs
            const firstMileRate = (params?.firstMile || parseFloat(document.getElementById('first-mile-rate').value)) / 1000;
            const lastMileRate = (params?.lastMile || parseFloat(document.getElementById('last-mile-rate').value)) / 1000;
            const storageRate = params?.storage || parseFloat(document.getElementById('storage-rate').value);
            const dio = params?.dio || parseInt(document.getElementById('dio').value);
            const minDCSizeEnabled = params?.minDCSizeEnabled !== undefined ? params.minDCSizeEnabled : document.getElementById('new-min-dc-size-enabled')?.checked;
            const minDCSize = params?.minDCSize !== undefined ? params.minDCSize : parseInt(document.getElementById('new-min-dc-size')?.value || 500);

            // First mile (each DC connects to nearest active factory)
            activeDCs.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                const dist = nearestFactory ? distance(nearestFactory, dc) : 0;
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate * 12;
            });

            // Last mile & storage
            demands.forEach(point => {
                if (point.assignedDC || point.assignedDCId) {
                    totalTransport += point.distance * point.demand * lastMileRate * 12;
                }
            });

            activeDCs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const avgInventory = throughput * (dio / 365);
                // Apply minimum DC size if enabled
                const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                totalStorage += billableInventory * storageRate * 12;
            });

            const costs = {
                total: totalTransport + totalStorage,
                transport: totalTransport,
                storage: totalStorage,
                activeDCs: activeDCs.length
            };

            // Calculate total demand (monthly)
            const totalDemand = demands.reduce((sum, p) => sum + p.demand, 0);

            // FMCG Product Structure:
            // 1 pallet = 60 cartons √ó 50 pieces = 3,000 pieces
            // NSV per piece = $0.10
            // NSV per pallet = 3,000 √ó $0.10 = $300
            const nsvPerPallet = 300;
            // NSV is annual (monthly demand √ó 12 months)
            const nsv = totalDemand * 12 * nsvPerPallet;
            const costPerNSV = costs.total / nsv;

            // Calculate unit cost to serve
            const unitCostToServe = costs.total / totalDemand;

            // Calculate lead time as simple average of lead time to all customers (distance / 500 km/day)
            const avgLeadTime = demands.reduce((sum, p) => sum + ((p.distance || 0) / 500), 0) / demands.length;

            // Calculate total stock: sum for each DC of (DIO * annual output quantity)/365
            // Annual output = monthly demand * 12
            let totalStock = 0;
            activeDCs.forEach(dc => {
                const monthlyThroughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const annualThroughput = monthlyThroughput * 12;
                totalStock += (dio * annualThroughput) / 365;
            });

            // Calculate DIO - should equal the input DIO parameter
            const calculatedDIO = dio;

            // Calculate IOC: average inventory value * WACC (10%)
            // Average inventory value = total stock (pallets) * NSV per pallet
            const avgInventoryValue = totalStock * nsvPerPallet;
            const ioc = avgInventoryValue * 0.10;

            return `
                <div class="metric-card">
                    <div class="metric-label">Number DCs</div>
                    <div class="metric-sublabel">-</div>
                    <div class="metric-value">${costs.activeDCs}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost per NSV</div>
                    <div class="metric-sublabel">Ratio</div>
                    <div class="metric-value">${(costPerNSV * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales Value</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(nsv / 1000000).toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales</div>
                    <div class="metric-sublabel">Volume</div>
                    <div class="metric-value">${Math.round(totalDemand / 1000)}</div>
                    <div class="metric-sublabel" style="margin-top:5px">(k Pallets)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost-to-Serve</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(costs.total / 1000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Unit CTS</div>
                    <div class="metric-sublabel">(USD/Pallet)</div>
                    <div class="metric-value">${Math.round(unitCostToServe).toLocaleString()}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">IOC</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(ioc / 1000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">DIO</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${calculatedDIO.toFixed(0)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Lead Time</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${avgLeadTime.toFixed(2)}</div>
                </div>
            `;
        }

        function updateResults() {
            const costs = calculateCosts();

            // Update scenario 1
            document.getElementById('scenario-label-1').textContent = scenario1.name;
            document.getElementById('metrics-grid-1').innerHTML = generateMetricsHTML(
                scenario1.dcLocations,
                scenario1.demandPoints,
                scenario1.name
            );

            // Update scenario 2 if exists
            if (scenario2) {
                document.getElementById('scenario-2-section').style.display = 'block';
                document.getElementById('map-container-analytics-2').style.display = 'block';
                document.getElementById('map-comparison-container').classList.add('two-scenarios');
                document.getElementById('scenario-label-2').textContent = scenario2.name;
                document.getElementById('metrics-grid-2').innerHTML = generateMetricsHTML(
                    scenario2.dcLocations,
                    scenario2.demandPoints,
                    scenario2.name
                );

                // Invalidate Leaflet map sizes after making them visible
                setTimeout(() => {
                    if (mapAnalytics1) mapAnalytics1.invalidateSize();
                    if (mapAnalytics2) mapAnalytics2.invalidateSize();
                    // Force redraw of both maps
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }
                    if (mapAnalytics2 && markersAnalytics2) {
                        renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
                    }
                }, 50);
            } else {
                document.getElementById('scenario-2-section').style.display = 'none';
                document.getElementById('map-container-analytics-2').style.display = 'none';
                document.getElementById('map-comparison-container').classList.remove('two-scenarios');
                // Clear the second map markers
                if (markersAnalytics2) markersAnalytics2.clearLayers();
            }

            // Update charts
            updateCharts(costs);
        }

        // Draw charts
        function updateCharts(costs) {
            // Sample data for waterfall chart effect
            const firstMileCost = costs.transport * 0.52; // Estimate
            const storageCost = costs.storage;
            const lastMileCost = costs.transport * 0.48;

            // Absolute chart
            const absoluteCanvas = document.getElementById('absolute-chart');
            const absCtx = absoluteCanvas.getContext('2d');
            absCtx.clearRect(0, 0, absoluteCanvas.width, absoluteCanvas.height);

            // Draw bars for absolute cost
            const maxCost = costs.total;
            const barWidth = 80;
            const spacing = 50;
            const chartHeight = 250;
            const baseY = 270;

            // First mile
            const fm_height = (firstMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50, baseY - fm_height, barWidth, fm_height);
            absCtx.fillStyle = '#2D3748';
            absCtx.font = '14px Arial';
            absCtx.textAlign = 'center';
            absCtx.fillText(Math.round(firstMileCost / 1000) + 'M', 90, baseY - fm_height - 5);

            // Storage (stacked on first mile)
            const st_height = (storageCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + barWidth + spacing, baseY - fm_height - st_height, barWidth, fm_height + st_height);
            absCtx.fillText(Math.round((firstMileCost + storageCost) / 1000) + 'M', 90 + barWidth + spacing, baseY - fm_height - st_height - 5);

            // Last mile (stacked on storage)
            const lm_height = (lastMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight, barWidth, costs.total / maxCost * chartHeight);
            absCtx.fillText(Math.round(costs.total / 1000) + 'M', 90 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight - 5);

            // Relative chart (cost per pallet)
            const relativeCanvas = document.getElementById('relative-chart');
            const relCtx = relativeCanvas.getContext('2d');
            relCtx.clearRect(0, 0, relativeCanvas.width, relativeCanvas.height);

            const totalDemand = demandPoints.reduce((sum, p) => sum + p.demand, 0);
            const fm_per_pallet = firstMileCost / totalDemand;
            const st_per_pallet = storageCost / totalDemand;
            const lm_per_pallet = lastMileCost / totalDemand;
            const total_per_pallet = costs.total / totalDemand;

            const maxPerPallet = total_per_pallet;

            // First mile
            const fm_height_rel = (fm_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50, baseY - fm_height_rel, barWidth, fm_height_rel);
            relCtx.fillStyle = '#2D3748';
            relCtx.font = '14px Arial';
            relCtx.textAlign = 'center';
            relCtx.fillText(Math.round(fm_per_pallet), 90, baseY - fm_height_rel - 5);

            // Storage (stacked)
            const st_height_rel = (st_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + barWidth + spacing, baseY - fm_height_rel - st_height_rel, barWidth, fm_height_rel + st_height_rel);
            relCtx.fillText(Math.round(fm_per_pallet + st_per_pallet), 90 + barWidth + spacing, baseY - fm_height_rel - st_height_rel - 5);

            // Last mile (stacked)
            const total_height_rel = (total_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - total_height_rel, barWidth, total_height_rel);
            relCtx.fillText(Math.round(total_per_pallet), 90 + (barWidth + spacing) * 2, baseY - total_height_rel - 5);
        }

        // Initialize
        generateDemandPoints();
        assignCustomers();
        updateDemandSummary();
        updateFactorySummary();
        updateDCSummary();

        // Initialize scenario 1 with current state
        scenario1.demandPoints = JSON.parse(JSON.stringify(demandPoints));
        scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
        // Re-assign customers to restore object references
        assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);

        drawMap();
        updateResults();

        // Load saved scenarios into all dropdowns
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('dno-scenario-')) {
                const name = key.replace('dno-scenario-', '');
                ['scenario-select-1', 'scenario-select-2', 'scenario-select-3'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    }
                });
            }
        }

        // DC list
        const dcList = document.getElementById('dc-list');
        dcLocations.forEach(dc => {
            const div = document.createElement('div');
            div.className = 'dc-checkbox';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = dc.id;
            checkbox.checked = dc.active;
            checkbox.addEventListener('change', () => {
                dc.active = checkbox.checked;
                assignCustomers();
                drawMap();
                updateResults();
            });
            const label = document.createElement('label');
            label.htmlFor = dc.id;
            label.textContent = dc.name;
            div.appendChild(checkbox);
            div.appendChild(label);
            dcList.appendChild(div);
        });

        // Parameters
        ['first-mile-rate', 'last-mile-rate', 'storage-rate', 'dio'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                updateResults();
            });
        });

        // Solver and run mode handling
        let selectedSolver = 'highs';
        let runMode = 'auto';
        let autoRunTimeout = null;
        let isOptimizing = false;

        const solverNames = {
            'heuristic': 'Heuristic',
            'highs': 'HiGHS',
            'glpk': 'GLPK'
        };

        // Run mode selector handler
        document.getElementById('run-mode-select').addEventListener('change', function() {
            runMode = this.value;
            const runBtn = document.getElementById('run-new-optimization');
            if (runMode === 'manual') {
                runBtn.style.display = 'inline-block';
            } else {
                runBtn.style.display = 'none';
                // Trigger auto-run when switching to auto mode
                triggerAutoRun();
            }
        });

        // Solver selector handler
        document.getElementById('solver-select').addEventListener('change', function() {
            selectedSolver = this.value;
            if (runMode === 'auto') {
                triggerAutoRun();
            }
        });

        // Auto-run trigger (debounced)
        function triggerAutoRun() {
            if (runMode !== 'auto') return;
            if (autoRunTimeout) clearTimeout(autoRunTimeout);
            autoRunTimeout = setTimeout(() => {
                runOptimization(false); // false = don't add to feed
            }, 300);
        }

        // Update live indicators
        function updateLiveIndicators(costs, demandPoints, dcLocations) {
            // Calculate additional metrics
            const totalDemand = demandPoints.reduce((sum, p) => sum + p.demand, 0);
            const nsvPerPallet = 300;
            const nsv = totalDemand * 12 * nsvPerPallet;
            const costPerNSV = costs.total / nsv;
            const unitCostToServe = costs.total / totalDemand;
            const dio = parseFloat(document.getElementById('new-dio').value) || 30;
            const avgLeadTime = demandPoints.reduce((sum, p) => sum + ((p.distance || 0) / 500), 0) / demandPoints.length;

            // Update metric card values (matching Analytics tab format)
            document.getElementById('live-total-cost').textContent = (costs.total / 1000000).toFixed(1);
            document.getElementById('live-transport-cost').textContent = (costs.transport / 1000000).toFixed(2);
            document.getElementById('live-storage-cost').textContent = (costs.storage / 1000000).toFixed(2);
            document.getElementById('live-active-dcs').textContent = costs.activeDCs;
            document.getElementById('live-cost-per-nsv').textContent = (costPerNSV * 100).toFixed(2) + '%';
            document.getElementById('live-unit-cost').textContent = Math.round(unitCostToServe).toLocaleString();
            document.getElementById('live-dio').textContent = dio;
            document.getElementById('live-lead-time').textContent = avgLeadTime.toFixed(2);
        }

        // Run optimization
        document.getElementById('run-optimization').addEventListener('click', () => {
            optimize();
            // Update checkboxes
            dcLocations.forEach(dc => {
                document.getElementById(dc.id).checked = dc.active;
            });
            // Update scenario 1 with optimized state
            scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
            scenario1.demandPoints = JSON.parse(JSON.stringify(demandPoints));
            assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);

            drawMap();
            updateResults();
        });

        // Save scenario
        document.getElementById('save-scenario').addEventListener('click', () => {
            const name = prompt('Enter scenario name:');
            if (name) {
                const scenario = {
                    name,
                    dcActive: dcLocations.map(dc => dc.active),
                    parameters: {
                        firstMileRate: document.getElementById('first-mile-rate').value,
                        lastMileRate: document.getElementById('last-mile-rate').value,
                        storageRate: document.getElementById('storage-rate').value,
                        dio: document.getElementById('dio').value
                    },
                    demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));
                alert('Scenario saved!');
            }
        });

        // Helper function to load a scenario
        function loadScenario(scenarioValue, scenarioName) {
            const tempDcLocations = JSON.parse(JSON.stringify(dcLocations));
            const tempDemandPoints = JSON.parse(JSON.stringify(demandPoints));

            if (scenarioValue === 'baseline') {
                tempDcLocations.forEach((dc, i) => dc.active = [0,2,4,6,8].includes(i));
            } else {
                // Load saved scenario
                const savedScenario = JSON.parse(localStorage.getItem('dno-scenario-' + scenarioValue));
                if (savedScenario) {
                    tempDcLocations.forEach((dc, i) => dc.active = savedScenario.dcActive[i]);
                    savedScenario.demands.forEach((d, i) => {
                        if (tempDemandPoints[i]) tempDemandPoints[i].demand = d.demand;
                    });
                }
            }

            // Assign customers for temp data using the scenario-specific function
            assignCustomersToScenario(tempDemandPoints, tempDcLocations);

            return {
                demandPoints: tempDemandPoints,
                dcLocations: tempDcLocations,
                name: scenarioName
            };
        }

        // Scenario select handlers
        const select1 = document.getElementById('scenario-select-1');
        const select2 = document.getElementById('scenario-select-2');

        select1.addEventListener('change', (e) => {
            if (e.target.value === '') return;
            const scenarioName = select1.options[select1.selectedIndex].text;
            scenario1 = loadScenario(e.target.value, scenarioName);

            // Update current working state
            dcLocations = JSON.parse(JSON.stringify(scenario1.dcLocations));
            demandPoints = JSON.parse(JSON.stringify(scenario1.demandPoints));

            // Update DC checkboxes
            dcLocations.forEach(dc => {
                const checkbox = document.getElementById(dc.id);
                if (checkbox) checkbox.checked = dc.active;
            });

            drawMap();
            updateResults();
        });

        select2.addEventListener('change', (e) => {
            if (e.target.value === '') {
                scenario2 = null;
            } else {
                const scenarioName = select2.options[select2.selectedIndex].text;
                scenario2 = loadScenario(e.target.value, scenarioName);
            }

            drawMap();
            updateResults();
        });

        // ===== NEW SCENARIO TAB IMPLEMENTATION =====

        // New working state for scenario creator
        let newScenarioDCs = JSON.parse(JSON.stringify(dcLocations));
        let newScenarioDemands = JSON.parse(JSON.stringify(demandPoints));
        let scenarioFeedCounter = 0;

        // Clustering state
        let currentClusteringResult = null;  // { centroids, assignments, iterations }
        let clusterColors = [];              // Array of HSL color strings
        let isClusteredViewActive = false;   // Toggle state

        // Initialize DC list for new scenario creator
        const newDCList = document.getElementById('new-dc-list');

        // Function to update the DC list UI
        function updateNewScenarioDCList() {
            reinitializeNewScenarioCheckboxes();
        }

        // Function to reinitialize DC checkboxes with current newScenarioDCs array
        function reinitializeNewScenarioCheckboxes() {
            // Clear existing checkboxes
            newDCList.innerHTML = '';

            // Create new checkboxes linked to current newScenarioDCs
            newScenarioDCs.forEach(dc => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; font-size: 13px;';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'new-' + dc.id;
                checkbox.checked = dc.active;
                checkbox.style.marginRight = '8px';
                checkbox.addEventListener('change', () => {
                    dc.active = checkbox.checked;
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    triggerAutoRun();
                });
                const label = document.createElement('label');
                label.htmlFor = 'new-' + dc.id;
                label.textContent = dc.name;
                div.appendChild(checkbox);
                div.appendChild(label);
                newDCList.appendChild(div);
            });
        }

        // Initial checkbox setup
        reinitializeNewScenarioCheckboxes();

        // Select All button handler
        document.getElementById('select-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = true);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        });

        // Clear All button handler
        document.getElementById('clear-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = false);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        });

        // Min DC Size checkbox handler
        document.getElementById('new-min-dc-size-enabled').addEventListener('change', function() {
            const minDCSizeInput = document.getElementById('new-min-dc-size');
            if (this.checked) {
                minDCSizeInput.disabled = false;
                minDCSizeInput.style.background = 'white';
            } else {
                minDCSizeInput.disabled = true;
                minDCSizeInput.style.background = '#f5f5f5';
            }
            triggerAutoRun();
        });

        // Parameter input change handlers for auto-run
        ['new-first-mile-rate', 'new-last-mile-rate', 'new-storage-rate', 'new-dio', 'new-min-dc-size'].forEach(id => {
            document.getElementById(id).addEventListener('change', triggerAutoRun);
        });

        // Global function to toggle DC active state from popup
        window.toggleDCFromPopup = function(dcId) {
            // Find DC in newScenarioDCs and toggle
            const dc = newScenarioDCs.find(d => d.id === dcId);
            if (dc) {
                dc.active = !dc.active;
                // Also update in dcLocations if present
                const mainDC = dcLocations.find(d => d.id === dcId);
                if (mainDC) mainDC.active = dc.active;
                // Close popup and refresh
                mapNewScenario.closePopup();
                updateNewScenarioDCList();
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                triggerAutoRun();
            }
        };

        // Global function to delete DC from popup
        window.deleteDCFromPopup = function(dcId) {
            // Remove from dcLocations
            const idx = dcLocations.findIndex(d => d.id === dcId);
            if (idx > -1) {
                dcLocations.splice(idx, 1);
            }
            // Remove from newScenarioDCs
            const nsIdx = newScenarioDCs.findIndex(d => d.id === dcId);
            if (nsIdx > -1) {
                newScenarioDCs.splice(nsIdx, 1);
            }
            // Close popup and refresh
            mapNewScenario.closePopup();
            updateNewScenarioDCList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        };

        // Helper function to add a new DC
        function addNewDC(lat, lng) {
            const newId = 'DC' + (dcLocations.length + 1);
            const newDC = {
                id: newId,
                name: 'New DC ' + (dcLocations.length + 1),
                lat: lat,
                lng: lng,
                active: true
            };
            dcLocations.push(newDC);
            newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
            updateNewScenarioDCList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        }

        // Helper function to add a new Factory
        function addNewFactory(lat, lng) {
            const newId = 'F' + (factories.length + 1);
            const newFactory = {
                id: newId,
                name: 'Factory ' + (factories.length + 1),
                lat: lat,
                lng: lng,
                active: true
            };
            factories.push(newFactory);
            updateFactoryList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        }

        // Global function to toggle Factory active state from popup
        window.toggleFactoryFromPopup = function(factoryId) {
            const f = factories.find(f => f.id === factoryId);
            if (f) {
                f.active = !f.active;
                mapNewScenario.closePopup();
                updateFactoryList();
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                triggerAutoRun();
            }
        };

        // Global function to delete Factory from popup
        window.deleteFactoryFromPopup = function(factoryId) {
            const idx = factories.findIndex(f => f.id === factoryId);
            if (idx > -1) {
                factories.splice(idx, 1);
            }
            mapNewScenario.closePopup();
            updateFactoryList();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            triggerAutoRun();
        };

        // Update Factory list in UI
        function updateFactoryList() {
            const list = document.getElementById('new-factory-list');
            if (!list) return;
            list.innerHTML = '';
            factories.forEach(f => {
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 4px 0;';
                item.innerHTML = `
                    <input type="checkbox" id="factory-${f.id}" ${f.active ? 'checked' : ''} style="cursor: pointer;">
                    <label for="factory-${f.id}" style="cursor: pointer; font-size: 13px; ${f.active ? '' : 'color: #999;'}">${f.name}</label>
                `;
                const checkbox = item.querySelector('input');
                checkbox.addEventListener('change', () => {
                    f.active = checkbox.checked;
                    updateFactoryList();
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                    renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    triggerAutoRun();
                });
                list.appendChild(item);
            });
        }

        // Map click popup handlers
        document.getElementById('popup-add-dc').addEventListener('click', function() {
            if (pendingClickLocation) {
                addNewDC(pendingClickLocation.lat, pendingClickLocation.lng);
                pendingClickLocation = null;
            }
            document.getElementById('map-click-popup').style.display = 'none';
        });

        document.getElementById('popup-add-factory').addEventListener('click', function() {
            if (pendingClickLocation) {
                addNewFactory(pendingClickLocation.lat, pendingClickLocation.lng);
                pendingClickLocation = null;
            }
            document.getElementById('map-click-popup').style.display = 'none';
        });

        document.getElementById('popup-cancel').addEventListener('click', function() {
            pendingClickLocation = null;
            document.getElementById('map-click-popup').style.display = 'none';
        });

        // Close popup when clicking elsewhere
        document.addEventListener('click', function(e) {
            const popup = document.getElementById('map-click-popup');
            if (popup.style.display === 'block' && !popup.contains(e.target)) {
                // Check if click is on the map
                const mapContainer = document.getElementById('new-scenario-map');
                if (!mapContainer.contains(e.target)) {
                    popup.style.display = 'none';
                    pendingClickLocation = null;
                }
            }
        });

        // Initialize factory list
        updateFactoryList();

        // Volume circles toggle handler
        document.getElementById('show-volume-circles').addEventListener('change', function() {
            showVolumeCircles = this.checked;
            // Re-render all visible maps
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }
            if (mapAnalytics1 && markersAnalytics1 && scenario1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }
            if (mapAnalytics2 && markersAnalytics2 && scenario2) {
                renderMapMarkers(mapAnalytics2, markersAnalytics2, scenario2.dcLocations, scenario2.demandPoints, false);
            }
        });

        // Initial assignment and draw for new scenario
        assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
        setTimeout(() => {
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            // Initial auto-run
            triggerAutoRun();
        }, 200);

        // Reference Scenario select handler
        document.getElementById('reference-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                document.getElementById('reference-scenario-display').style.display = 'none';
                return;
            }

            const refScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Show display
            document.getElementById('reference-scenario-display').style.display = 'block';

            // Generate metrics
            document.getElementById('reference-metrics').innerHTML = generateMetricsHTML(
                refScenario.dcLocations,
                refScenario.demandPoints,
                refScenario.name
            );

            // Draw map using Leaflet
            if (mapReference && markersReference) {
                mapReference.invalidateSize();
                renderMapMarkers(mapReference, markersReference, refScenario.dcLocations, refScenario.demandPoints, false);
            }

            // Display parameters
            const params = document.getElementById('reference-parameters');
            params.innerHTML = `
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>First Mile Rate:</strong><br>$${document.getElementById('first-mile-rate').value}/pallet/1,000km
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Last Mile Rate:</strong><br>$${document.getElementById('last-mile-rate').value}/pallet/1,000km
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Storage Rate:</strong><br>$${document.getElementById('storage-rate').value}/pallet/month
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>DIO:</strong><br>${document.getElementById('dio').value} days
                </div>
            `;
        });

        // Store preloaded scenario state for reset functionality
        let preloadedState = null;

        // Preload scenario handler
        document.getElementById('preload-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                preloadedState = null;
                document.getElementById('reset-to-preloaded').style.display = 'none';
                return;
            }

            const preloadScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Update DCs
            newScenarioDCs = JSON.parse(JSON.stringify(preloadScenario.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadScenario.demandPoints));

            // Store preloaded state for reset
            preloadedState = {
                dcLocations: JSON.parse(JSON.stringify(preloadScenario.dcLocations)),
                demandPoints: JSON.parse(JSON.stringify(preloadScenario.demandPoints)),
                firstMileRate: document.getElementById('first-mile-rate').value,
                lastMileRate: document.getElementById('last-mile-rate').value,
                storageRate: document.getElementById('storage-rate').value,
                dio: document.getElementById('dio').value,
                minDCSizeEnabled: document.getElementById('new-min-dc-size-enabled').checked,
                minDCSize: document.getElementById('new-min-dc-size').value
            };

            // Reinitialize checkboxes with new DC array
            reinitializeNewScenarioCheckboxes();

            // Update parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;
            document.getElementById('new-min-dc-size-enabled').checked = preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').value = preloadedState.minDCSize;
            document.getElementById('new-min-dc-size').disabled = !preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').style.background = preloadedState.minDCSizeEnabled ? 'white' : '#f5f5f5';

            // Show reset button
            document.getElementById('reset-to-preloaded').style.display = 'block';

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Reset to preloaded handler
        document.getElementById('reset-to-preloaded').addEventListener('click', () => {
            if (!preloadedState) return;

            // Restore preloaded state
            newScenarioDCs = JSON.parse(JSON.stringify(preloadedState.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadedState.demandPoints));

            // Reinitialize checkboxes with restored DC array
            reinitializeNewScenarioCheckboxes();

            // Restore parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;
            document.getElementById('new-min-dc-size-enabled').checked = preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').value = preloadedState.minDCSize;
            document.getElementById('new-min-dc-size').disabled = !preloadedState.minDCSizeEnabled;
            document.getElementById('new-min-dc-size').style.background = preloadedState.minDCSizeEnabled ? 'white' : '#f5f5f5';

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Store last optimization result for Quick Save
        let lastOptimizationResult = null;

        // Main optimization function
        async function runOptimization(addToFeed = true) {
            if (isOptimizing) return;
            isOptimizing = true;

            const btn = document.getElementById('run-new-optimization');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Optimizing...';
            }

            try {
                const solver = selectedSolver;

                // Get parameters
                const firstMile = parseFloat(document.getElementById('new-first-mile-rate').value);
                const lastMile = parseFloat(document.getElementById('new-last-mile-rate').value);
                const storage = parseFloat(document.getElementById('new-storage-rate').value);
                const dio = parseInt(document.getElementById('new-dio').value);
                const minDCSizeEnabled = document.getElementById('new-min-dc-size-enabled').checked;
                const minDCSize = parseInt(document.getElementById('new-min-dc-size').value || 500);

                // Clone current state
                const runDCs = JSON.parse(JSON.stringify(newScenarioDCs));
                const runDemands = JSON.parse(JSON.stringify(demandPoints));

                const startTime = performance.now();

                if (solver === 'heuristic') {
                    // Run heuristic optimization on runDCs
                    function calculateScenarioCost(dcs, demands) {
                        const activeDCs = dcs.filter(dc => dc.active);
                        let total = 0;
                        const fm = firstMile / 1000;
                        const lm = lastMile / 1000;

                        activeDCs.forEach(dc => {
                            const nearestFactory = findNearestActiveFactory(dc);
                            const dist = nearestFactory ? distance(nearestFactory, dc) : 0;
                            const throughput = demands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                            total += dist * throughput * fm * 12;
                            const avgInventory = throughput * (dio / 365);
                            const billableInventory = minDCSizeEnabled ? Math.max(avgInventory, minDCSize) : avgInventory;
                            total += billableInventory * storage * 12;
                        });
                        demands.forEach(point => {
                            if (point.assignedDC) {
                                total += point.distance * point.demand * lm * 12;
                            }
                        });
                        return total;
                    }

                    // Start with all DCs active that are within range of a factory
                    runDCs.forEach(dc => {
                        const nearestFactory = findNearestActiveFactory(dc);
                        dc.active = nearestFactory ? distance(nearestFactory, dc) <= 4000 : false;
                    });
                    assignCustomersToScenario(runDemands, runDCs);
                    let currentCost = calculateScenarioCost(runDCs, runDemands);

                    let improved = true;
                    let iterations = 0;
                    while (improved && iterations < 10) {
                        improved = false;
                        iterations++;
                        let bestSavings = 0;
                        let bestDCToClose = -1;

                        for (let i = 0; i < runDCs.length; i++) {
                            if (!runDCs[i].active) continue;
                            runDCs[i].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            const allAssigned = runDemands.every(p => p.assignedDC !== null);
                            if (allAssigned) {
                                const newCost = calculateScenarioCost(runDCs, runDemands);
                                const savings = currentCost - newCost;
                                if (savings > bestSavings) {
                                    bestSavings = savings;
                                    bestDCToClose = i;
                                }
                            }
                            runDCs[i].active = true;
                        }

                        if (bestDCToClose >= 0) {
                            runDCs[bestDCToClose].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            currentCost = calculateScenarioCost(runDCs, runDemands);
                            improved = true;
                        }
                    }
                    assignCustomersToScenario(runDemands, runDCs);

                } else if (solver === 'highs' || solver === 'glpk') {
                    try {
                        if (solver === 'highs') {
                            await optimizeWithHiGHS(runDCs, runDemands);
                        } else {
                            await optimizeWithGLPK(runDCs, runDemands);
                        }
                    } catch (e) {
                        console.error('Solver error:', e);
                    }
                    assignCustomersToScenario(runDemands, runDCs);
                }

                const endTime = performance.now();
                const solveTime = Math.round(endTime - startTime);

                // Calculate costs for display
                const costs = calculateCostsForScenario(runDCs, runDemands, {firstMile, lastMile, storage, dio, minDCSizeEnabled, minDCSize});

                // Update live indicators
                updateLiveIndicators(costs, runDemands, runDCs);

                // Show run time indicator
                const runTimeIndicator = document.getElementById('run-time-indicator');
                runTimeIndicator.textContent = solverNames[solver] + ' - ' + solveTime + 'ms';
                runTimeIndicator.style.display = 'inline-block';

                // Update map with optimized network
                newScenarioDCs.forEach((dc, i) => {
                    dc.active = runDCs[i].active;
                });
                assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                updateNewScenarioDCList();

                // Store result for Quick Save
                lastOptimizationResult = {
                    dcs: runDCs,
                    demands: runDemands,
                    params: {firstMile, lastMile, storage, dio, minDCSizeEnabled, minDCSize, solver: solverNames[solver], solveTime}
                };

                // Add to feed if requested (manual run or save)
                if (addToFeed) {
                    scenarioFeedCounter++;
                    const scenarioName = 'Run_' + scenarioFeedCounter + '_' + solverNames[solver] + '_' + new Date().toLocaleTimeString();
                    addScenarioToFeed(scenarioName, runDCs, runDemands, lastOptimizationResult.params);
                }

            } finally {
                isOptimizing = false;
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Run Optimization';
                }
            }
        }

        // Helper function to calculate costs for a scenario
        function calculateCostsForScenario(dcs, demands, params) {
            const activeDCs = dcs.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const fm = params.firstMile / 1000;
            const lm = params.lastMile / 1000;

            activeDCs.forEach(dc => {
                const nearestFactory = findNearestActiveFactory(dc);
                const dist = nearestFactory ? distance(nearestFactory, dc) : 0;
                const throughput = demands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * fm * 12;
                const avgInventory = throughput * (params.dio / 365);
                const billableInventory = params.minDCSizeEnabled ? Math.max(avgInventory, params.minDCSize) : avgInventory;
                totalStorage += billableInventory * params.storage * 12;
            });
            demands.forEach(point => {
                if (point.assignedDC) {
                    totalTransport += point.distance * point.demand * lm * 12;
                }
            });

            return {
                total: totalTransport + totalStorage,
                transport: totalTransport,
                storage: totalStorage,
                activeDCs: activeDCs.length
            };
        }

        // Run Optimization button handler (for manual mode)
        document.getElementById('run-new-optimization').addEventListener('click', async () => {
            await runOptimization(true);
        });

        // Quick Save handler - adds to feed without saving to localStorage
        document.getElementById('quick-save-scenario').addEventListener('click', async () => {
            if (!lastOptimizationResult) {
                // Run optimization first if no result exists
                await runOptimization(false);
            }
            if (lastOptimizationResult) {
                scenarioFeedCounter++;
                const scenarioName = 'Run_' + scenarioFeedCounter + '_' + lastOptimizationResult.params.solver + '_' + new Date().toLocaleTimeString();
                addScenarioToFeed(scenarioName, lastOptimizationResult.dcs, lastOptimizationResult.demands, lastOptimizationResult.params);
            }
        });

        // Save Scenario handler - saves to localStorage and adds to dropdowns
        document.getElementById('save-new-scenario').addEventListener('click', async () => {
            const name = prompt('Enter scenario name:');
            if (!name) return;

            // Run optimization if needed
            if (!lastOptimizationResult) {
                await runOptimization(false);
            }

            const scenario = {
                name,
                dcActive: newScenarioDCs.map(dc => dc.active),
                parameters: {
                    firstMileRate: document.getElementById('new-first-mile-rate').value,
                    lastMileRate: document.getElementById('new-last-mile-rate').value,
                    storageRate: document.getElementById('new-storage-rate').value,
                    dio: document.getElementById('new-dio').value,
                    minDCSizeEnabled: document.getElementById('new-min-dc-size-enabled').checked,
                    minDCSize: document.getElementById('new-min-dc-size').value
                },
                demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
            };
            localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));

            // Add to all dropdowns
            const option1 = document.createElement('option');
            option1.value = name;
            option1.textContent = name;
            document.getElementById('scenario-select-1').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-2').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-3').appendChild(option1.cloneNode(true));
            document.getElementById('reference-scenario-select').appendChild(option1.cloneNode(true));
            document.getElementById('preload-scenario-select').appendChild(option1);

            // Also add to scenario feed
            if (lastOptimizationResult) {
                scenarioFeedCounter++;
                addScenarioToFeed(name, lastOptimizationResult.dcs, lastOptimizationResult.demands, lastOptimizationResult.params);
            }

            alert('Scenario "' + name + '" saved!');
        });

        // Data Admin: Load CSV handler
        document.getElementById('load-demand-btn').addEventListener('click', function() {
            const fileInput = document.getElementById('demand-csv-input');
            const errorDiv = document.getElementById('csv-error');
            const successDiv = document.getElementById('csv-success');
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            if (!fileInput.files || fileInput.files.length === 0) {
                errorDiv.textContent = 'Please select a CSV file first';
                errorDiv.style.display = 'block';
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const newDemands = parseDemandsCSV(e.target.result);
                    demandPoints = newDemands;

                    // Reassign to DCs and update displays
                    assignCustomers();
                    updateDemandSummary();

                    // Update new scenario data
                    newScenarioDemands = JSON.parse(JSON.stringify(demandPoints));
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

                    // Update New Scenario map if it exists
                    if (mapNewScenario && markersNewScenario) {
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    }

                    // Update Analytics maps if they exist
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }

                    // Clear file input
                    fileInput.value = '';

                    successDiv.textContent = `Successfully loaded ${newDemands.length} demand points (${demandPoints.reduce((sum, p) => sum + p.demand, 0).toLocaleString()} pallets/month)`;
                    successDiv.style.display = 'block';
                } catch (err) {
                    errorDiv.textContent = err.message;
                    errorDiv.style.display = 'block';
                }
            };

            reader.readAsText(file);
        });

        // Data Admin: Reset to default handler
        document.getElementById('reset-demand-btn').addEventListener('click', function() {
            generateDemandPoints();
            assignCustomers();
            updateDemandSummary();

            // Update new scenario data
            newScenarioDemands = JSON.parse(JSON.stringify(demandPoints));
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

            // Update New Scenario map if it exists
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Update Analytics maps if they exist
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }

            const successDiv = document.getElementById('csv-success');
            const errorDiv = document.getElementById('csv-error');
            errorDiv.style.display = 'none';
            successDiv.textContent = 'Reset to default demand data';
            successDiv.style.display = 'block';
        });

        // Data Admin: Table toggle handler
        document.getElementById('demand-table-toggle').addEventListener('click', function() {
            const container = document.getElementById('demand-table-container');
            const icon = document.getElementById('demand-table-icon');
            const isHidden = container.style.display === 'none';
            container.style.display = isHidden ? 'block' : 'none';
            icon.textContent = isHidden ? '‚ñº' : '‚ñ∂';
        });

        // Data Admin: Sortable table headers
        document.querySelectorAll('.sortable-header').forEach(header => {
            header.addEventListener('click', function() {
                const col = this.getAttribute('data-sort');
                if (tableSortColumn === col) {
                    // Toggle direction if same column
                    tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    // New column, default to ascending
                    tableSortColumn = col;
                    tableSortDirection = 'asc';
                }
                updateDemandTable();
            });
        });

        // Data Admin: Load Factory CSV handler
        document.getElementById('load-factory-btn').addEventListener('click', function() {
            const fileInput = document.getElementById('factory-csv-input');
            const errorDiv = document.getElementById('factory-csv-error');
            const successDiv = document.getElementById('factory-csv-success');
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            if (!fileInput.files || fileInput.files.length === 0) {
                errorDiv.textContent = 'Please select a CSV file first';
                errorDiv.style.display = 'block';
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const newFactories = parseFactoriesCSV(e.target.result);
                    factories = newFactories;

                    // Update displays
                    updateFactorySummary();
                    updateFactoryList();

                    // Reassign customers to account for new factories
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

                    // Update New Scenario map if it exists
                    if (mapNewScenario && markersNewScenario) {
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    }

                    // Update Analytics maps if they exist
                    assignCustomers();
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }

                    // Clear file input
                    fileInput.value = '';

                    successDiv.textContent = `Successfully loaded ${newFactories.length} factories`;
                    successDiv.style.display = 'block';
                } catch (err) {
                    errorDiv.textContent = 'Error: ' + err.message;
                    errorDiv.style.display = 'block';
                }
            };

            reader.readAsText(file);
        });

        // Data Admin: Reset Factory to default handler
        document.getElementById('reset-factory-btn').addEventListener('click', function() {
            factories = [
                {id: 'F1', name: 'Jatake, Tangerang', lat: -6.1897, lng: 106.5108, active: true}
            ];

            updateFactorySummary();
            updateFactoryList();

            // Reassign customers
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            assignCustomers();

            // Update New Scenario map if it exists
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Update Analytics maps if they exist
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }

            const successDiv = document.getElementById('factory-csv-success');
            const errorDiv = document.getElementById('factory-csv-error');
            errorDiv.style.display = 'none';
            successDiv.textContent = 'Reset to default factory data';
            successDiv.style.display = 'block';
        });

        // Data Admin: Load DC CSV handler
        document.getElementById('load-dc-btn').addEventListener('click', function() {
            const fileInput = document.getElementById('dc-csv-input');
            const errorDiv = document.getElementById('dc-csv-error');
            const successDiv = document.getElementById('dc-csv-success');
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            if (!fileInput.files || fileInput.files.length === 0) {
                errorDiv.textContent = 'Please select a CSV file first';
                errorDiv.style.display = 'block';
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const newDCs = parseDCsCSV(e.target.result);
                    dcLocations = newDCs;
                    newScenarioDCs = JSON.parse(JSON.stringify(newDCs));

                    // Update displays
                    updateDCSummary();
                    reinitializeDCCheckboxes();
                    reinitializeNewScenarioCheckboxes();

                    // Reassign customers to new DCs
                    assignCustomers();
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

                    // Update New Scenario map if it exists
                    if (mapNewScenario && markersNewScenario) {
                        renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
                    }

                    // Update Analytics scenario 1 with new DCs
                    scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
                    assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);
                    if (mapAnalytics1 && markersAnalytics1) {
                        renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
                    }

                    // Clear file input
                    fileInput.value = '';

                    successDiv.textContent = `Successfully loaded ${newDCs.length} distribution centers`;
                    successDiv.style.display = 'block';
                } catch (err) {
                    errorDiv.textContent = 'Error: ' + err.message;
                    errorDiv.style.display = 'block';
                }
            };

            reader.readAsText(file);
        });

        // Data Admin: Reset DC to default handler
        document.getElementById('reset-dc-btn').addEventListener('click', function() {
            dcLocations = [
                {id: 'DC1', name: 'Medan Hub', lat: 3.5952, lng: 98.6722, active: true},
                {id: 'DC2', name: 'Pekanbaru Hub', lat: 0.5071, lng: 101.4478, active: false},
                {id: 'DC3', name: 'Palembang Hub', lat: -2.9761, lng: 104.7754, active: true},
                {id: 'DC4', name: 'Lampung Hub', lat: -5.4294, lng: 105.2610, active: false},
                {id: 'DC5', name: 'Jakarta Hub', lat: -6.2088, lng: 106.8456, active: true},
                {id: 'DC6', name: 'Bandung Hub', lat: -6.9175, lng: 107.6191, active: false},
                {id: 'DC7', name: 'Semarang Hub', lat: -6.9666, lng: 110.4196, active: true},
                {id: 'DC8', name: 'Yogyakarta Hub', lat: -7.7956, lng: 110.3695, active: false},
                {id: 'DC9', name: 'Surabaya Hub', lat: -7.2575, lng: 112.7521, active: true},
                {id: 'DC10', name: 'Malang Hub', lat: -7.9666, lng: 112.6326, active: false},
                {id: 'DC11', name: 'Padang Hub', lat: -0.9471, lng: 100.4172, active: false},
                {id: 'DC12', name: 'Jambi Hub', lat: -1.6101, lng: 103.6131, active: false}
            ];
            newScenarioDCs = JSON.parse(JSON.stringify(dcLocations));

            updateDCSummary();
            reinitializeDCCheckboxes();
            reinitializeNewScenarioCheckboxes();

            // Reassign customers
            assignCustomers();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

            // Update New Scenario map if it exists
            if (mapNewScenario && markersNewScenario) {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Update Analytics scenario 1
            scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
            assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);
            if (mapAnalytics1 && markersAnalytics1) {
                renderMapMarkers(mapAnalytics1, markersAnalytics1, scenario1.dcLocations, scenario1.demandPoints, false);
            }

            const successDiv = document.getElementById('dc-csv-success');
            const errorDiv = document.getElementById('dc-csv-error');
            errorDiv.style.display = 'none';
            successDiv.textContent = 'Reset to default DC data';
            successDiv.style.display = 'block';
        });

        // ===== CLUSTERING EVENT HANDLERS =====

        // Clustering section toggle (collapsible)
        document.getElementById('clustering-toggle').addEventListener('click', function(e) {
            // Don't toggle if clicking on buttons
            if (e.target.tagName === 'BUTTON') return;

            const content = document.getElementById('clustering-content');
            const icon = document.getElementById('clustering-toggle-icon');
            const isHidden = content.style.display === 'none';
            content.style.display = isHidden ? 'block' : 'none';
            icon.innerHTML = isHidden ? '&#9660;' : '&#9654;';
        });

        // Run Clustering button
        document.getElementById('run-clustering').addEventListener('click', function() {
            const k = parseInt(document.getElementById('cluster-count').value);
            const algorithm = document.getElementById('clustering-algorithm').value;

            // Validate input
            if (isNaN(k) || k < 1 || k > 200) {
                alert('Please enter a valid number of clusters (1-200).');
                return;
            }

            // Show loading indicator
            const infoDiv = document.getElementById('clustering-info');
            infoDiv.innerHTML = '<strong>Running clustering...</strong> Please wait.';
            infoDiv.style.display = 'block';

            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                // Run selected algorithm
                if (algorithm === 'kmeans') {
                    currentClusteringResult = weightedKMeans(newScenarioDemands, k);
                } else {
                    currentClusteringResult = weightedKMedoids(newScenarioDemands, k);
                }

                clusterColors = generateClusterColors(k);

                // Update info display
                const totalDemand = newScenarioDemands.reduce((sum, p) => sum + p.demand, 0);
                const avgDemand = Math.round(totalDemand / k);
                infoDiv.innerHTML =
                    `<strong>${k} clusters</strong> created in ${currentClusteringResult.iterations} iterations. ` +
                    `Total demand: ${totalDemand.toLocaleString()} pallets. ` +
                    `Avg per cluster: ${avgDemand.toLocaleString()} pallets.`;

                // Show centroid lines option
                document.getElementById('centroid-lines-label').style.display = 'flex';

                // Auto-enable clustered view
                document.getElementById('show-clustered-view').checked = true;
                isClusteredViewActive = true;

                // Render clustered view on main map
                const showLines = document.getElementById('show-centroid-lines').checked;
                renderClusteredView(mapNewScenario, markersNewScenario, newScenarioDemands,
                                   currentClusteringResult, showLines);

                // Show and initialize the clustering map section
                const mapSection = document.getElementById('clustering-map-section');
                mapSection.style.display = 'block';

                // Initialize clustering map if not already done
                if (!mapClustering) {
                    mapClustering = initLeafletMap('clustering-map');
                    if (mapClustering) {
                        markersClustering = L.layerGroup().addTo(mapClustering);
                    }
                }

                // Render clustering map with Voronoi
                if (mapClustering) {
                    setTimeout(() => {
                        mapClustering.invalidateSize();
                        renderClusteringMap({
                            showVoronoi: document.getElementById('show-voronoi-tiles').checked,
                            showDemandPoints: document.getElementById('show-demand-points').checked,
                            showLinks: document.getElementById('show-cluster-links').checked
                        });
                    }, 100);
                }
            }, 0);
        });

        // Toggle clustered view checkbox
        document.getElementById('show-clustered-view').addEventListener('change', function() {
            isClusteredViewActive = this.checked;

            if (this.checked && currentClusteringResult) {
                const showLines = document.getElementById('show-centroid-lines').checked;
                renderClusteredView(mapNewScenario, markersNewScenario, newScenarioDemands,
                                   currentClusteringResult, showLines);
            } else {
                renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
            }

            // Show/hide centroid lines option
            document.getElementById('centroid-lines-label').style.display =
                (this.checked && currentClusteringResult) ? 'flex' : 'none';
        });

        // Toggle centroid lines checkbox
        document.getElementById('show-centroid-lines').addEventListener('change', function() {
            if (isClusteredViewActive && currentClusteringResult) {
                renderClusteredView(mapNewScenario, markersNewScenario, newScenarioDemands,
                                   currentClusteringResult, this.checked);
            }
        });

        // Reset clustering button
        document.getElementById('reset-clustering').addEventListener('click', function() {
            currentClusteringResult = null;
            clusterColors = [];
            isClusteredViewActive = false;

            document.getElementById('show-clustered-view').checked = true; // Keep checked by default
            document.getElementById('show-centroid-lines').checked = false;
            document.getElementById('centroid-lines-label').style.display = 'none';
            document.getElementById('clustering-info').style.display = 'none';

            // Hide clustering map section
            document.getElementById('clustering-map-section').style.display = 'none';

            // Clear clustering map layers
            if (markersClustering) {
                markersClustering.clearLayers();
            }
            if (voronoiLayer && mapClustering) {
                mapClustering.removeLayer(voronoiLayer);
                voronoiLayer = null;
            }

            // Restore normal map view
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);
        });

        // Clustering map visualization toggle handlers
        document.getElementById('show-voronoi-tiles').addEventListener('change', function() {
            if (currentClusteringResult && mapClustering) {
                renderClusteringMap({
                    showVoronoi: this.checked,
                    showDemandPoints: document.getElementById('show-demand-points').checked,
                    showLinks: document.getElementById('show-cluster-links').checked
                });
            }
        });

        document.getElementById('show-demand-points').addEventListener('change', function() {
            if (currentClusteringResult && mapClustering) {
                renderClusteringMap({
                    showVoronoi: document.getElementById('show-voronoi-tiles').checked,
                    showDemandPoints: this.checked,
                    showLinks: document.getElementById('show-cluster-links').checked
                });
            }
        });

        document.getElementById('show-cluster-links').addEventListener('change', function() {
            if (currentClusteringResult && mapClustering) {
                renderClusteringMap({
                    showVoronoi: document.getElementById('show-voronoi-tiles').checked,
                    showDemandPoints: document.getElementById('show-demand-points').checked,
                    showLinks: this.checked
                });
            }
        });

        // Add centroids as DCs button
        document.getElementById('add-centroids-as-dcs').addEventListener('click', function() {
            if (!currentClusteringResult || !currentClusteringResult.centroids) {
                alert('Please run clustering first.');
                return;
            }

            const { centroids } = currentClusteringResult;
            const startId = dcLocations.length + 1;

            centroids.forEach((centroid, i) => {
                const newId = 'DC' + (startId + i);
                const newDC = {
                    id: newId,
                    name: `Cluster ${i + 1} Centroid`,
                    lat: centroid.lat,
                    lng: centroid.lng,
                    active: true
                };

                // Add to both global and scenario DC arrays
                dcLocations.push(newDC);
                newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
            });

            // Update UI
            updateNewScenarioDCList();
            reinitializeNewScenarioCheckboxes();
            reinitializeDCCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);

            // Turn off clustered view and show normal map with new DCs
            document.getElementById('show-clustered-view').checked = false;
            isClusteredViewActive = false;
            document.getElementById('centroid-lines-label').style.display = 'none';
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);

            triggerAutoRun();

            alert(`${centroids.length} centroids added as new DCs.`);
        });

        // Replace DCs with centroids button
        document.getElementById('replace-dcs-with-centroids').addEventListener('click', function() {
            if (!currentClusteringResult || !currentClusteringResult.centroids) {
                alert('Please run clustering first.');
                return;
            }

            if (!confirm('This will replace all existing DCs with cluster centroids. Continue?')) {
                return;
            }

            const { centroids } = currentClusteringResult;

            // Clear existing DCs
            dcLocations.length = 0;
            newScenarioDCs.length = 0;

            // Add centroids as new DCs
            centroids.forEach((centroid, i) => {
                const newDC = {
                    id: 'DC' + (i + 1),
                    name: `Cluster ${i + 1} Centroid`,
                    lat: centroid.lat,
                    lng: centroid.lng,
                    active: true
                };

                dcLocations.push(newDC);
                newScenarioDCs.push(JSON.parse(JSON.stringify(newDC)));
            });

            // Update UI
            updateNewScenarioDCList();
            reinitializeNewScenarioCheckboxes();
            reinitializeDCCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            updateDCSummary();

            // Turn off clustered view and show normal map with new DCs
            document.getElementById('show-clustered-view').checked = false;
            isClusteredViewActive = false;
            document.getElementById('centroid-lines-label').style.display = 'none';
            renderMapMarkers(mapNewScenario, markersNewScenario, newScenarioDCs, newScenarioDemands, true);

            triggerAutoRun();

            alert(`Replaced all DCs with ${centroids.length} cluster centroids.`);
        });

        // ===== END CLUSTERING EVENT HANDLERS =====

        // Expand All / Collapse All scenario handlers
        document.getElementById('expand-all-scenarios').addEventListener('click', function() {
            const feed = document.getElementById('scenario-feed');
            feed.querySelectorAll('.scenario-details').forEach(details => {
                details.style.display = 'block';
            });
            feed.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.textContent = 'Collapse';
            });
        });

        document.getElementById('collapse-all-scenarios').addEventListener('click', function() {
            const feed = document.getElementById('scenario-feed');
            feed.querySelectorAll('.scenario-details').forEach(details => {
                details.style.display = 'none';
            });
            feed.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.textContent = 'Expand';
            });
        });

        // Function to add scenario to feed
        function addScenarioToFeed(name, dcs, demands, params) {
            const feed = document.getElementById('scenario-feed');
            const scenarioId = 'scenario-' + Date.now();

            const scenarioBlock = document.createElement('div');
            scenarioBlock.id = scenarioId;
            scenarioBlock.style.cssText = 'background: white; padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px;';

            const solverInfo = params.solver ? `<span style="margin-left: 10px; padding: 4px 10px; background: var(--cel-blue); color: white; border-radius: 12px; font-size: 12px;">${params.solver}${params.solveTime ? ' - ' + params.solveTime + 'ms' : ''}</span>` : '';

            scenarioBlock.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center;">
                        <h3 style="font-size: 18px; font-weight: 600; color: var(--text-dark); margin: 0;">${name}</h3>
                        ${solverInfo}
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="toggle-btn" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Expand</button>
                        <button class="hide-btn" style="padding: 6px 14px; background: #ffc107; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Hide</button>
                        <button class="save-btn" style="padding: 6px 14px; background: var(--cel-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Save</button>
                        <button class="delete-btn" style="padding: 6px 14px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Delete</button>
                    </div>
                </div>
                <div class="metrics-grid scenario-metrics" style="margin-bottom: 0;"></div>
                <div class="scenario-details" style="margin-top: 15px; display: none;">
                    <div>
                        <div class="scenario-map" id="${scenarioId}-map" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 8px;"></div>
                    </div>
                    <div style="margin-top: 20px; display: grid; grid-template-columns: repeat(6, 1fr); gap: 15px;">
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>First Mile Rate:</strong><br>$${params.firstMile}/pallet/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Last Mile Rate:</strong><br>$${params.lastMile}/pallet/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Storage Rate:</strong><br>$${params.storage}/pallet/month</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>DIO:</strong><br>${params.dio} days</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Min DC Size:</strong><br>${params.minDCSizeEnabled ? params.minDCSize + ' pallets' : 'Disabled'}</div>
                        <div style="padding: 15px; background: #e8f4fd; border-radius: 4px;"><strong>Solver:</strong><br>${params.solver || 'Heuristic'}${params.solveTime ? ' (' + params.solveTime + 'ms)' : ''}</div>
                    </div>
                </div>
            `;

            feed.appendChild(scenarioBlock);

            // Show the scenario feed controls when first scenario is added
            document.getElementById('scenario-feed-controls').style.display = 'block';

            // Generate metrics (pass params for minDCSize support)
            const metricsGrid = scenarioBlock.querySelector('.scenario-metrics');
            const metricsParams = params ? {
                firstMile: params.firstMile,
                lastMile: params.lastMile,
                storage: params.storage,
                dio: params.dio,
                minDCSizeEnabled: params.minDCSizeEnabled,
                minDCSize: params.minDCSize
            } : null;
            metricsGrid.innerHTML = generateMetricsHTML(dcs, demands, name, metricsParams);

            // Initialize mini Leaflet map for scenario
            setTimeout(() => {
                const mapContainer = document.getElementById(scenarioId + '-map');
                if (mapContainer && !mapContainer._leaflet_id) {
                    const miniMap = L.map(mapContainer, {
                        center: INDONESIA_CENTER,
                        zoom: INDONESIA_ZOOM,
                        zoomControl: true,
                        scrollWheelZoom: false
                    });
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                        attribution: '¬© CARTO',
                        maxZoom: 18
                    }).addTo(miniMap);

                    const markersLayer = L.layerGroup().addTo(miniMap);
                    renderMapMarkers(miniMap, markersLayer, dcs, demands, false);

                    // Store map reference for cleanup
                    mapContainer._leafletMap = miniMap;
                }
            }, 100);

            // Add event listeners
            scenarioBlock.querySelector('.toggle-btn').addEventListener('click', function() {
                const details = scenarioBlock.querySelector('.scenario-details');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    this.textContent = 'Collapse';
                } else {
                    details.style.display = 'none';
                    this.textContent = 'Expand';
                }
            });

            scenarioBlock.querySelector('.hide-btn').addEventListener('click', () => {
                scenarioBlock.style.display = 'none';
            });

            scenarioBlock.querySelector('.save-btn').addEventListener('click', () => {
                const saveName = prompt('Enter scenario name:', name);
                if (!saveName) return;

                const scenario = {
                    name: saveName,
                    dcActive: dcs.map(dc => dc.active),
                    parameters: {
                        firstMileRate: params.firstMile,
                        lastMileRate: params.lastMile,
                        storageRate: params.storage,
                        dio: params.dio,
                        minDCSizeEnabled: params.minDCSizeEnabled || false,
                        minDCSize: params.minDCSize || 500
                    },
                    demands: demands.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + saveName, JSON.stringify(scenario));

                // Update the scenario block heading to reflect the saved name
                const heading = scenarioBlock.querySelector('h3');
                if (heading) {
                    heading.textContent = saveName;
                }

                // Update the internal name variable for future operations
                name = saveName;

                // Add to all dropdowns if not already there
                const existingOption = document.querySelector(`option[value="${saveName}"]`);
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = saveName;
                    option.textContent = saveName;
                    document.getElementById('scenario-select-1').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-2').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-3').appendChild(option.cloneNode(true));
                    document.getElementById('reference-scenario-select').appendChild(option.cloneNode(true));
                    document.getElementById('preload-scenario-select').appendChild(option);
                }

                alert('Scenario saved as "' + saveName + '"!');
            });

            scenarioBlock.querySelector('.delete-btn').addEventListener('click', () => {
                scenarioBlock.remove();
                // Remove from localStorage if it was saved
                localStorage.removeItem('dno-scenario-' + name);
                // Remove from dropdowns
                document.querySelectorAll('option').forEach(opt => {
                    if (opt.value === name) opt.remove();
                });
            });
        }

        // Function to restore saved scenarios from localStorage on page load
        function restoreSavedScenarios() {
            // Find all saved scenarios in localStorage
            const savedScenarios = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('dno-scenario-')) {
                    const scenarioName = key.replace('dno-scenario-', '');
                    const scenarioData = JSON.parse(localStorage.getItem(key));
                    savedScenarios.push({ name: scenarioName, data: scenarioData });
                }
            }

            // Restore each scenario to the feed
            savedScenarios.forEach(({ name, data }) => {
                // Reconstruct DC locations with active states
                const dcs = JSON.parse(JSON.stringify(dcLocations));
                dcs.forEach((dc, index) => {
                    if (data.dcActive && data.dcActive[index] !== undefined) {
                        dc.active = data.dcActive[index];
                    }
                });

                // Use current demand points (they're generated with a fixed seed)
                const demands = JSON.parse(JSON.stringify(demandPoints));

                // Assign customers to DCs
                assignCustomersToScenario(demands, dcs);

                // Extract parameters
                const params = {
                    firstMile: parseFloat(data.parameters.firstMileRate),
                    lastMile: parseFloat(data.parameters.lastMileRate),
                    storage: parseFloat(data.parameters.storageRate),
                    dio: parseInt(data.parameters.dio)
                };

                // Add to scenario feed
                addScenarioToFeed(name, dcs, demands, params);
            });
        }

        // Restore saved scenarios when page loads
        restoreSavedScenarios();
    </script>
</body>
</html>