<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOM - Distribution Network Design</title>
    <!-- Solver Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/highs@1.8.0/build/highs.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/glpk.js@4.0.1/dist/glpk.min.js"></script>
    <style>
        :root {
            --cel-red: #CB333B;
            --cel-blue: #385D7F;
            --cel-dark-blue: #2c4a5f;
            --cel-orange: #FE5000;
            --cel-green: #30B700;
            --cel-yellow: #FFD100;
            --bg-light: #F5F7FA;
            --text-dark: #2D3748;
            --sidebar-bg: #4A6883;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-light);
            color: var(--text-dark);
        }
        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background-color: var(--sidebar-bg);
            color: white;
            padding: 30px 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .logo-section {
            text-align: center;
            margin-bottom: 30px;
        }
        .logo-section img {
            width: 200px;
            margin-bottom: 20px;
        }
        .company-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .project-name {
            font-size: 14px;
            opacity: 0.9;
            border-top: 2px solid rgba(255,255,255,0.3);
            padding-top: 15px;
            margin-top: 15px;
        }

        .sidebar-section {
            margin-bottom: 30px;
        }
        .sidebar-section h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .scenario-select, .unit-select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background-color: white;
            color: var(--text-dark);
            font-size: 14px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .sidebar-button {
            background-color: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .sidebar-button:hover {
            background-color: rgba(255,255,255,0.3);
        }
        .sidebar-button.primary {
            background-color: var(--cel-blue);
            border-color: var(--cel-blue);
        }
        .sidebar-button.primary:hover {
            background-color: var(--cel-dark-blue);
        }

        /* Main Content */
        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Tabs */
        .tabs {
            display: flex;
            background-color: white;
            border-bottom: 2px solid #e2e8f0;
        }
        .tab {
            padding: 15px 30px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #64748b;
        }
        .tab.active {
            color: var(--cel-blue);
            border-bottom-color: var(--cel-blue);
        }
        .tab:hover {
            background-color: #f8fafc;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
        }

        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        /* Key Metrics */
        .section-title {
            font-size: 28px;
            font-weight: 600;
            color: var(--cel-blue);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--cel-blue);
        }
        .scenario-label {
            font-size: 18px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 20px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 10px;
            margin-bottom: 40px;
        }
        .metric-card {
            background: white;
            padding: 15px 10px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            min-height: 110px;
        }
        .metric-label {
            font-size: 11px;
            color: #64748b;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .metric-sublabel {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 8px;
            min-height: 12px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--cel-blue);
        }
        .metric-tag {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 12px;
            background-color: #e2e8f0;
            color: #64748b;
            font-size: 11px;
            border-radius: 12px;
        }

        /* Cost Breakdown */
        .cost-breakdown {
            margin-top: 40px;
        }
        .charts-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 20px;
        }
        .chart-wrapper {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 20px;
        }

        /* Map Container */
        #map-container, #map-container-analytics {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        #map, #map-analytics {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .network-map-section {
            margin-top: 40px;
            margin-bottom: 40px;
        }

        /* Map Comparison Container */
        #map-comparison-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
        }
        #map-comparison-container.two-scenarios {
            grid-template-columns: 1fr;
        }
        .map-container-single {
            position: relative;
            width: 100%;
            height: 700px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .map-container-single canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        .map-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(74, 104, 131, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            z-index: 5;
        }
        #tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            display: none;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            font-size: 12px;
        }

        /* Settings Expander */
        .settings-expander {
            margin-top: auto;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
        .settings-toggle {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 14px;
            font-weight: 600;
        }
        .settings-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .settings-content.expanded {
            max-height: 800px;
        }
        .parameter-input {
            margin-bottom: 15px;
        }
        .parameter-input label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            opacity: 0.9;
        }
        .parameter-input input {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 13px;
        }
        .dc-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .dc-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .dc-checkbox input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="logo-section">
                <img src="pictures/ATOM_logo.png" alt="ATOM Logo">
                <div class="company-name">Acme Milk Corporate (AMC)</div>
                <div class="project-name">Distribution Network Design</div>
            </div>

            <button class="sidebar-button primary">
                ‚ÑπÔ∏è Scenario Comparison
            </button>

            <div class="sidebar-section">
                <h3>Scenario Selection</h3>
                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px;">First Scenario:</label>
                <select class="scenario-select" id="scenario-select-1">
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>

                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px; margin-top: 15px;">Second Scenario:</label>
                <select class="scenario-select" id="scenario-select-2">
                    <option value="">Choose an option</option>
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>

                <label style="font-size: 12px; opacity: 0.9; display: block; margin-bottom: 5px; margin-top: 15px;">Third Scenario:</label>
                <select class="scenario-select" id="scenario-select-3">
                    <option value="">Choose an option</option>
                    <option value="baseline">0,5_Baseline_2028</option>
                </select>
            </div>

            <div class="sidebar-section">
                <h3>Unit Selection</h3>
                <select class="unit-select" id="unit-select">
                    <option value="usd">US Dollar (USD)</option>
                    <option value="eur">Euro (EUR)</option>
                </select>
            </div>

            <button class="sidebar-button" id="run-optimization">
                üîÑ Run Optimization
            </button>
            <button class="sidebar-button" id="save-scenario">
                üíæ Save Scenario
            </button>

            <div class="settings-expander">
                <div class="settings-toggle" id="settings-toggle">
                    <span>‚öôÔ∏è Advanced Settings</span>
                    <span id="toggle-icon">‚ñº</span>
                </div>
                <div class="settings-content" id="settings-content">
                    <div class="sidebar-section">
                        <h3>Parameters</h3>
                        <div class="parameter-input">
                            <label>First Mile Rate ($/pallet/1,000km):</label>
                            <input type="number" id="first-mile-rate" value="5.60" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>Last Mile Rate ($/pallet/1,000km):</label>
                            <input type="number" id="last-mile-rate" value="9.60" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>Storage Rate ($/pallet/month):</label>
                            <input type="number" id="storage-rate" value="0.30" step="0.01">
                        </div>
                        <div class="parameter-input">
                            <label>DIO (days):</label>
                            <input type="number" id="dio" value="30">
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <h3>DC Selection</h3>
                        <div class="dc-list" id="dc-list"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <div class="tabs">
                <div class="tab active" data-tab="new-scenario">New Scenario</div>
                <div class="tab" data-tab="analytics">Analytics</div>
            </div>

            <div class="content-area">
                <!-- Analytics Tab -->
                <div class="tab-content" id="analytics-tab">
                    <h2 class="section-title">Key Metrics</h2>

                    <!-- Scenario 1 -->
                    <div class="scenario-label" id="scenario-label-1">0,5_Baseline_2028</div>
                    <div class="metrics-grid" id="metrics-grid-1">
                        <!-- Metrics will be populated by JavaScript -->
                    </div>

                    <!-- Scenario 2 (hidden by default) -->
                    <div id="scenario-2-section" style="display: none;">
                        <div class="scenario-label" id="scenario-label-2">Scenario 2</div>
                        <div class="metrics-grid" id="metrics-grid-2">
                            <!-- Metrics will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="network-map-section">
                        <h2 class="section-title">Network Map</h2>
                        <div id="map-comparison-container">
                            <!-- Scenario 1 Map -->
                            <div id="map-container-analytics-1" class="map-container-single">
                                <div class="map-label">Scenario 1</div>
                                <canvas id="map-analytics-1"></canvas>
                                <div id="tooltip-analytics-1" style="position: absolute; background: white; border: 1px solid #ccc; padding: 10px; border-radius: 4px; display: none; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 12px;"></div>
                            </div>

                            <!-- Scenario 2 Map (hidden by default) -->
                            <div id="map-container-analytics-2" class="map-container-single" style="display: none;">
                                <div class="map-label">Scenario 2</div>
                                <canvas id="map-analytics-2"></canvas>
                                <div id="tooltip-analytics-2" style="position: absolute; background: white; border: 1px solid #ccc; padding: 10px; border-radius: 4px; display: none; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.15); font-size: 12px;"></div>
                            </div>
                        </div>
                    </div>

                    <div class="cost-breakdown">
                        <h2 class="section-title">Cost Breakdown</h2>
                        <div class="charts-container">
                            <div class="chart-wrapper">
                                <div class="chart-title">Absolute Logistics Cost Breakdown</div>
                                <canvas id="absolute-chart" width="400" height="300"></canvas>
                            </div>
                            <div class="chart-wrapper">
                                <div class="chart-title">Relative Logistics Cost Breakdown</div>
                                <canvas id="relative-chart" width="400" height="300"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- New Scenario Tab -->
                <div class="tab-content active" id="new-scenario-tab">
                    <h2 class="section-title">New Scenario</h2>

                    <!-- Reference Scenario Section -->
                    <div style="margin-bottom: 40px;">
                        <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 15px; color: var(--text-dark);">Reference Scenario</h3>
                        <select id="reference-scenario-select" style="width: 300px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 20px;">
                            <option value="">Select a scenario...</option>
                            <option value="baseline">0,5_Baseline_2028</option>
                                </select>
                        <div id="reference-scenario-display" style="display: none;">
                            <div class="metrics-grid" id="reference-metrics"></div>
                            <div style="margin-top: 30px;">
                                <canvas id="reference-map" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 8px;"></canvas>
                            </div>
                            <div style="margin-top: 20px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;" id="reference-parameters"></div>
                        </div>
                    </div>

                    <!-- New Scenario Creator -->
                    <div style="background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 20px; color: var(--text-dark);">Create New Scenario</h3>

                        <div style="margin-bottom: 20px;">
                            <label style="display: block; margin-bottom: 8px; font-weight: 500;">Preload from scenario:</label>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <select id="preload-scenario-select" style="width: 300px; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                                    <option value="">None</option>
                                    <option value="baseline">0,5_Baseline_2028</option>
                                </select>
                                <button id="reset-to-preloaded" style="display: none; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">Reset to preloaded</button>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 300px 1fr; gap: 30px;">
                            <!-- Left: Parameters and DC Selection -->
                            <div>
                                <h4 style="font-size: 16px; font-weight: 600; margin-bottom: 15px;">Parameters</h4>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; font-size: 13px; margin-bottom: 5px;">First Mile Rate ($/pallet/1,000km):</label>
                                    <input type="number" id="new-first-mile-rate" value="5.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; font-size: 13px; margin-bottom: 5px;">Last Mile Rate ($/pallet/1,000km):</label>
                                    <input type="number" id="new-last-mile-rate" value="9.60" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <label style="display: block; font-size: 13px; margin-bottom: 5px;">Storage Rate ($/pallet/month):</label>
                                    <input type="number" id="new-storage-rate" value="0.30" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                </div>
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; font-size: 13px; margin-bottom: 5px;">DIO (days):</label>
                                    <input type="number" id="new-dio" value="30" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                </div>

                                <h4 style="font-size: 16px; font-weight: 600; margin-bottom: 15px;">DC Selection</h4>
                                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <button id="select-all-dcs" style="flex: 1; padding: 8px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Select All</button>
                                    <button id="clear-all-dcs" style="flex: 1; padding: 8px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear All</button>
                                </div>
                                <div id="new-dc-list" style="max-height: 350px; overflow-y: auto;"></div>
                            </div>

                            <!-- Right: Map -->
                            <div>
                                <h4 style="font-size: 16px; font-weight: 600; margin-bottom: 15px;">Network Preview</h4>
                                <canvas id="new-scenario-map" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 8px;"></canvas>
                            </div>
                        </div>

                        <div style="margin-top: 30px; display: flex; gap: 15px; align-items: center;">
                            <div style="display: inline-flex; position: relative;">
                                <button id="run-new-optimization" style="padding: 12px 24px; background: var(--cel-blue); color: white; border: none; border-radius: 4px 0 0 4px; font-weight: 600; cursor: pointer;">Run Optimization</button>
                                <button id="run-new-optimization-dropdown" style="padding: 12px 10px; background: var(--cel-dark-blue); color: white; border: none; border-radius: 0 4px 4px 0; cursor: pointer; border-left: 1px solid rgba(255,255,255,0.3);">‚ñº</button>
                                <div id="solver-dropdown-menu" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 100; min-width: 220px; margin-top: 2px;">
                                    <div class="solver-option" data-solver="heuristic" style="padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #eee;">
                                        <strong style="display: block; color: var(--text-dark);">Heuristic</strong>
                                        <small style="color: #64748b;">Fast local search (~1-10ms)</small>
                                    </div>
                                    <div class="solver-option" data-solver="highs" style="padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #eee;">
                                        <strong style="display: block; color: var(--text-dark);">HiGHS</strong>
                                        <small style="color: #64748b;">MIP solver - optimal solutions</small>
                                    </div>
                                    <div class="solver-option" data-solver="glpk" style="padding: 10px 15px; cursor: pointer;">
                                        <strong style="display: block; color: var(--text-dark);">GLPK</strong>
                                        <small style="color: #64748b;">GNU MIP solver - optimal solutions</small>
                                    </div>
                                </div>
                            </div>
                            <span id="new-scenario-solver-label" style="font-size: 13px; color: #64748b;">(Using: Heuristic)</span>
                            <button id="save-new-scenario" style="padding: 12px 24px; background: var(--cel-green); color: white; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">Save Scenario</button>
                        </div>
                    </div>

                    <!-- Scenario Feed (dynamically populated) -->
                    <div id="scenario-feed" style="margin-top: 40px;"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                tab.classList.add('active');
                const tabName = tab.getAttribute('data-tab');
                document.getElementById(tabName + '-tab').classList.add('active');

                // Redraw canvases when switching to New Scenario tab
                if (tabName === 'new-scenario') {
                    setTimeout(() => {
                        const newScenarioMapCanvas = document.getElementById('new-scenario-map');
                        if (newScenarioMapCanvas) {
                            resizeCanvas(newScenarioMapCanvas);
                            const newScenarioMapCtx = newScenarioMapCanvas.getContext('2d');
                            drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);
                        }
                    }, 50);
                }
            });
        });

        // Settings toggle
        document.getElementById('settings-toggle').addEventListener('click', () => {
            const content = document.getElementById('settings-content');
            const icon = document.getElementById('toggle-icon');
            content.classList.toggle('expanded');
            icon.textContent = content.classList.contains('expanded') ? '‚ñ≤' : '‚ñº';
        });

        // JavaScript code here
        // Analytics map canvases
        const canvasAnalytics1 = document.getElementById('map-analytics-1');
        const ctxAnalytics1 = canvasAnalytics1 ? canvasAnalytics1.getContext('2d') : null;
        const canvasAnalytics2 = document.getElementById('map-analytics-2');
        const ctxAnalytics2 = canvasAnalytics2 ? canvasAnalytics2.getContext('2d') : null;

        // Function to set canvas size with proper resolution
        function resizeCanvas(canvasElement) {
            if (!canvasElement) return;
            const dpr = window.devicePixelRatio || 1;
            const rect = canvasElement.parentElement.getBoundingClientRect();

            canvasElement.width = rect.width * dpr;
            canvasElement.height = 700 * dpr;

            canvasElement.style.width = rect.width + 'px';
            canvasElement.style.height = '700px';

            const context = canvasElement.getContext('2d');
            context.scale(dpr, dpr);
        }

        // Initialize canvas sizes
        resizeCanvas(canvasAnalytics1);
        resizeCanvas(canvasAnalytics2);

        // Data structures
        let demandPoints = [];
        let dcLocations = [
            {id: 'DC1', name: 'North Hub', x: 120, y: 180, active: true},
            {id: 'DC2', name: 'North Secondary', x: 200, y: 250, active: false},
            {id: 'DC3', name: 'Central Prime', x: 180, y: 420, active: true},
            {id: 'DC4', name: 'Central West', x: 100, y: 480, active: false},
            {id: 'DC5', name: 'South Hub', x: 160, y: 680, active: true},
            {id: 'DC6', name: 'South Port', x: 250, y: 720, active: false},
            {id: 'DC7', name: 'Island North', x: 700, y: 230, active: true},
            {id: 'DC8', name: 'Island Central', x: 720, y: 400, active: false},
            {id: 'DC9', name: 'Island South', x: 750, y: 580, active: true},
            {id: 'DC10', name: 'Mainland East', x: 350, y: 350, active: false},
            {id: 'DC11', name: 'Remote North', x: 400, y: 100, active: false},
            {id: 'DC12', name: 'Island Port', x: 600, y: 450, active: false}
        ];
        const factory = {x: 50, y: 400};

        // Scenario storage
        let scenario1 = {
            demandPoints: [],
            dcLocations: JSON.parse(JSON.stringify(dcLocations)),
            name: '0,5_Baseline_2028'
        };
        let scenario2 = null;

        // Seeded random number generator for consistent demand generation
        function seededRandom(seed) {
            let state = seed;
            return function() {
                state = (state * 9301 + 49297) % 233280;
                return state / 233280;
            };
        }

        // Generate demand points
        // Target: ~350k pallets/month (50x scale for realistic unit costs)
        function generateDemandPoints() {
            demandPoints = [];
            const random = seededRandom(12345); // Fixed seed for consistent results
            const clusters = [
                {center: {x: 150, y: 200}, count: 25, demandRange: [1600, 4500], id: 'A'},
                {center: {x: 200, y: 450}, count: 20, demandRange: [3650, 7700], id: 'B'},
                {center: {x: 180, y: 650}, count: 20, demandRange: [1600, 3650], id: 'C'},
                {center: {x: 750, y: 250}, count: 15, demandRange: [2000, 4650], id: 'D'},
                {center: {x: 780, y: 550}, count: 12, demandRange: [2650, 6300], id: 'E'}
            ];
            clusters.forEach(cluster => {
                for (let i = 0; i < cluster.count; i++) {
                    const x = cluster.center.x + (random() - 0.5) * 100;
                    const y = cluster.center.y + (random() - 0.5) * 100;
                    const demand = Math.floor(random() * (cluster.demandRange[1] - cluster.demandRange[0]) + cluster.demandRange[0]);
                    demandPoints.push({x, y, demand, cluster: cluster.id, assignedDC: null, distance: 0});
                }
            });
            // Scattered
            for (let i = 0; i < 8; i++) {
                const x = random() * 1000;
                const y = random() * 800;
                const demand = Math.floor(random() * 1600 + 800);
                demandPoints.push({x, y, demand, cluster: 'scattered', assignedDC: null, distance: 0});
            }
        }

        // Distance calculation
        function distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            let dist = Math.sqrt(dx*dx + dy*dy) * 5; // 1 unit = 5 km
            // Check if crosses water (water between x=450-550)
            const waterStart = 450;
            const waterEnd = 550;
            const crossesWater = (p1.x < waterStart && p2.x > waterEnd) || (p1.x > waterEnd && p2.x < waterStart);
            if (crossesWater) dist *= 1.5;
            return dist;
        }

        // Assign customers to DCs
        function assignCustomers() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            demandPoints.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) { // Assign to nearest DC regardless of distance to fulfill all demand
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null; // Store DC ID for cloning
                point.distance = minDist;
            });
        }

        // Assign customers to DCs (for scenario data with separate DC arrays)
        function assignCustomersToScenario(demands, dcs) {
            const activeDCs = dcs.filter(dc => dc.active);
            demands.forEach(point => {
                let minDist = Infinity;
                let bestDC = null;
                activeDCs.forEach(dc => {
                    const dist = distance(point, dc);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDC = dc;
                    }
                });
                point.assignedDC = bestDC;
                point.assignedDCId = bestDC ? bestDC.id : null;
                point.distance = minDist;
            });
        }

        // Calculate costs
        function calculateCosts() {
            const activeDCs = dcLocations.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value) / 1000;
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value) / 1000;
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            // First mile
            activeDCs.forEach(dc => {
                const dist = distance(factory, dc);
                if (dist > 4000) return; // SLA violation, but for now ignore
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate;
            });

            // Last mile and storage
            activeDCs.forEach(dc => {
                const throughput = demandPoints.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                const avgInventory = throughput * (dio / 365);
                totalStorage += avgInventory * storageRate * 12;
                demandPoints.filter(p => p.assignedDC === dc).forEach(p => {
                    totalTransport += p.distance * p.demand * lastMileRate;
                });
            });

            return {total: totalTransport + totalStorage, transport: totalTransport, storage: totalStorage, activeDCs: activeDCs.length};
        }

        // Draw map
        function drawMap() {
            drawMapOnCanvas(ctxAnalytics1, canvasAnalytics1, scenario1.dcLocations, scenario1.demandPoints);
            if (scenario2) {
                drawMapOnCanvas(ctxAnalytics2, canvasAnalytics2, scenario2.dcLocations, scenario2.demandPoints);
            }
        }

        function drawMapOnCanvas(context, canvasElement, dcs, demands) {
            if (!context || !canvasElement) return;
            const rect = canvasElement.getBoundingClientRect();
            context.clearRect(0, 0, rect.width, 700);

            // Scale factor for canvas (use style width for proper scaling, keep Y at 1:1 with original 800px design scaled to 700px)
            const scaleX = rect.width / 1000;
            const scaleY = 700 / 800;

            // Water
            context.fillStyle = '#B8D4E8';
            context.fillRect(450 * scaleX, 0, 100 * scaleX, 700);
            // Land
            context.fillStyle = '#E8E8E8';
            context.fillRect(0, 0, 450 * scaleX, 700);
            context.fillRect(550 * scaleX, 0, 450 * scaleX, 700);

            // Factory
            context.fillStyle = '#CB333B';
            context.fillRect(factory.x * scaleX - 10, factory.y * scaleY - 10, 20, 20);
            context.fillStyle = 'white';
            context.font = '16px Arial';
            context.fillText('F', factory.x * scaleX - 5, factory.y * scaleY + 5);

            // DCs
            dcs.forEach(dc => {
                if (dc.active) {
                    context.fillStyle = '#385D7F';
                    const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                    const size = Math.max(5, Math.sqrt(throughput) / 14);
                    context.beginPath();
                    context.arc(dc.x * scaleX, dc.y * scaleY, size, 0, 2 * Math.PI);
                    context.fill();
                    context.fillStyle = 'white';
                    context.fillText(dc.id, dc.x * scaleX - 10, dc.y * scaleY - 10);
                } else {
                    context.strokeStyle = 'gray';
                    context.setLineDash([5, 5]);
                    context.beginPath();
                    context.arc(dc.x * scaleX, dc.y * scaleY, 10, 0, 2 * Math.PI);
                    context.stroke();
                    context.setLineDash([]);
                }
            });

            // Demand points
            demands.forEach(point => {
                const intensity = Math.min(255, point.demand / 4);
                context.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                context.beginPath();
                context.arc(point.x * scaleX, point.y * scaleY, 3, 0, 2 * Math.PI);
                context.fill();
            });

            // Flows
            const activeDCs = dcs.filter(dc => dc.active);
            // First mile - only draw links for DCs with actual throughput
            context.strokeStyle = 'rgba(56, 93, 127, 0.5)';
            context.lineWidth = 2;
            activeDCs.forEach(dc => {
                // Check if this DC has any customers assigned to it
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                if (throughput > 0) {
                    context.beginPath();
                    context.moveTo(factory.x * scaleX, factory.y * scaleY);
                    context.lineTo(dc.x * scaleX, dc.y * scaleY);
                    context.stroke();
                }
            });
            // Last mile
            context.strokeStyle = 'rgba(254, 80, 0, 0.5)';
            demands.forEach(point => {
                let assignedDC = point.assignedDC;
                // If assignedDC doesn't match, find by ID (for cloned scenarios)
                if (!assignedDC || !dcs.includes(assignedDC)) {
                    assignedDC = dcs.find(dc => dc.id === point.assignedDCId);
                }
                if (assignedDC) {
                    context.beginPath();
                    context.moveTo(assignedDC.x * scaleX, assignedDC.y * scaleY);
                    context.lineTo(point.x * scaleX, point.y * scaleY);
                    context.stroke();
                }
            });
        }

        // Tooltip function
        function setupTooltip(canvasElement, tooltipElement) {
            if (!canvasElement || !tooltipElement) return;
            canvasElement.addEventListener('mousemove', (e) => {
                const rect = canvasElement.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const scaleX = rect.width / 1000;
                const scaleY = 700 / 800;
                let hoveredDC = null;
                dcLocations.forEach(dc => {
                    const dist = Math.sqrt((x - dc.x * scaleX)**2 + (y - dc.y * scaleY)**2);
                    if (dist < 15) hoveredDC = dc;
                });
                if (hoveredDC) {
                    const throughput = demandPoints.filter(p => p.assignedDC === hoveredDC).reduce((sum, p) => sum + p.demand, 0);
                    const storageRate = parseFloat(document.getElementById('storage-rate').value);
                    const dio = parseInt(document.getElementById('dio').value);
                    const storageCost = throughput * (dio / 365) * storageRate * 12;
                    tooltipElement.innerHTML = `${hoveredDC.name}<br>Throughput: ${throughput} pallets<br>Storage Cost: $${storageCost.toLocaleString()}`;
                    tooltipElement.style.left = e.pageX + 10 + 'px';
                    tooltipElement.style.top = e.pageY + 10 + 'px';
                    tooltipElement.style.display = 'block';
                } else {
                    tooltipElement.style.display = 'none';
                }
            });
            canvasElement.addEventListener('mouseout', () => {
                tooltipElement.style.display = 'none';
            });
        }

        // Setup tooltips
        const tooltipAnalytics1 = document.getElementById('tooltip-analytics-1');
        const tooltipAnalytics2 = document.getElementById('tooltip-analytics-2');
        setupTooltip(canvasAnalytics1, tooltipAnalytics1);
        setupTooltip(canvasAnalytics2, tooltipAnalytics2);

        // Optimization function
        function optimize() {
            // Heuristic optimization
            // Step 1: Activate all feasible DCs (distance from factory <= 4000 km)
            dcLocations.forEach(dc => {
                dc.active = distance(factory, dc) <= 4000;
            });
            assignCustomers();
            
            // Step 2: Local search - try closing DCs that don't reduce total cost
            let improved = true;
            let iterations = 0;
            while (improved && iterations < 10) { // Limit iterations
                improved = false;
                iterations++;
                const currentCosts = calculateCosts();
                for (let i = 0; i < dcLocations.length; i++) {
                    if (!dcLocations[i].active) continue;
                    // Try closing this DC
                    dcLocations[i].active = false;
                    assignCustomers();
                    const trialCosts = calculateCosts();
                    if (trialCosts.total < currentCosts.total) {
                        // Keep closed
                        improved = true;
                        break; // Accept first improvement
                    } else {
                        // Reopen
                        dcLocations[i].active = true;
                    }
                }
            }
            assignCustomers();
        }

        // ===== MIP SOLVER IMPLEMENTATIONS =====

        // Global solver instances (initialized lazily)
        let highsInstance = null;
        let glpkInstance = null;

        // Initialize HiGHS solver
        async function initHiGHS() {
            if (highsInstance) return highsInstance;
            try {
                // HiGHS from CDN exposes a global 'highs' factory function
                if (typeof highs === 'undefined') {
                    throw new Error('HiGHS library not loaded');
                }
                highsInstance = await highs({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/highs@1.8.0/build/${file}`
                });
                console.log('HiGHS initialized successfully');
                return highsInstance;
            } catch (e) {
                console.error('Failed to initialize HiGHS:', e);
                throw e;
            }
        }

        // Initialize GLPK solver
        async function initGLPK() {
            if (glpkInstance) return glpkInstance;
            try {
                if (typeof GLPK === 'undefined') {
                    throw new Error('GLPK library not loaded');
                }
                glpkInstance = await GLPK();
                console.log('GLPK initialized successfully');
                return glpkInstance;
            } catch (e) {
                console.error('Failed to initialize GLPK:', e);
                throw e;
            }
        }

        // Optimized greedy solver (better than simple heuristic, faster than MIP)
        function optimizeGreedy(targetDCs, targetDemands, params) {
            const { firstMileRate, lastMileRate, storageRate, dio } = params;

            // Calculate cost for a given DC configuration
            function calcTotalCost() {
                const activeDCs = targetDCs.filter(dc => dc.active);
                if (activeDCs.length === 0) return Infinity;

                let total = 0;
                targetDemands.forEach(point => {
                    let minDist = Infinity;
                    let bestDC = null;
                    activeDCs.forEach(dc => {
                        const dist = distance(point, dc);
                        if (dist < minDist) {
                            minDist = dist;
                            bestDC = dc;
                        }
                    });
                    if (bestDC) {
                        // Last mile cost
                        total += minDist * point.demand * lastMileRate / 1000 * 12;
                        point.assignedDC = bestDC;
                        point.distance = minDist;
                    }
                });

                // First mile and storage costs
                activeDCs.forEach(dc => {
                    const throughput = targetDemands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                    const distFromFactory = distance(factory, dc);
                    total += distFromFactory * throughput * firstMileRate / 1000 * 12;
                    total += throughput * (dio / 365) * storageRate * 12;
                });

                return total;
            }

            // Start with all DCs active
            targetDCs.forEach(dc => dc.active = true);
            let bestCost = calcTotalCost();

            // Greedy removal - keep removing DCs while cost improves
            let improved = true;
            while (improved) {
                improved = false;
                let bestRemoval = -1;
                let bestNewCost = bestCost;

                for (let i = 0; i < targetDCs.length; i++) {
                    if (!targetDCs[i].active) continue;

                    targetDCs[i].active = false;
                    const newCost = calcTotalCost();

                    if (newCost < bestNewCost) {
                        bestNewCost = newCost;
                        bestRemoval = i;
                    }

                    targetDCs[i].active = true;
                }

                if (bestRemoval >= 0) {
                    targetDCs[bestRemoval].active = false;
                    bestCost = bestNewCost;
                    improved = true;
                }
            }

            // Final assignment
            calcTotalCost();
        }

        // HiGHS optimization
        async function optimizeWithHiGHS(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value);
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value);
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            try {
                const solver = await initHiGHS();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate assignment costs for each customer to each DC
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const firstMileDist = distance(factory, dc);

                        const unitCost = (lastMileDist * lastMileRate / 1000 +
                                         firstMileDist * firstMileRate / 1000 +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build LP string
                let lp = 'Minimize\n obj:';
                const terms = [];

                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        terms.push(` ${costs[c][d].toFixed(2)} x${c}_${d}`);
                    }
                }
                lp += terms.join(' +') + '\n';

                lp += 'Subject To\n';

                // Each customer assigned to exactly one DC
                for (let c = 0; c < numCustomers; c++) {
                    const assignTerms = [];
                    for (let d = 0; d < numDCs; d++) {
                        assignTerms.push(`x${c}_${d}`);
                    }
                    lp += ` c${c}: ${assignTerms.join(' + ')} = 1\n`;
                }

                // Linking: x[c,d] <= y[d]
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` l${c}_${d}: x${c}_${d} - y${d} <= 0\n`;
                    }
                }

                lp += 'Binary\n';
                for (let d = 0; d < numDCs; d++) {
                    lp += ` y${d}\n`;
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        lp += ` x${c}_${d}\n`;
                    }
                }
                lp += 'End\n';

                console.log('Solving with HiGHS...');
                const result = solver.solve(lp);
                console.log('HiGHS result:', result);

                if (result.Status === 'Optimal') {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.Columns[`y${d}`]?.Primal || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.ObjectiveValue };
                } else {
                    throw new Error('HiGHS status: ' + result.Status);
                }
            } catch (e) {
                console.error('HiGHS failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const params = { firstMileRate, lastMileRate, storageRate, dio };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // GLPK optimization
        async function optimizeWithGLPK(targetDCs = dcLocations, targetDemands = demandPoints) {
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value);
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value);
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            try {
                const glpk = await initGLPK();

                const numDCs = targetDCs.length;
                const numCustomers = targetDemands.length;

                // Pre-calculate costs
                const costs = [];
                for (let c = 0; c < numCustomers; c++) {
                    costs[c] = [];
                    for (let d = 0; d < numDCs; d++) {
                        const customer = targetDemands[c];
                        const dc = targetDCs[d];
                        const lastMileDist = distance(customer, dc);
                        const firstMileDist = distance(factory, dc);

                        const unitCost = (lastMileDist * lastMileRate / 1000 +
                                         firstMileDist * firstMileRate / 1000 +
                                         (dio / 365) * storageRate) * 12;
                        costs[c][d] = unitCost * customer.demand;
                    }
                }

                // Build objective
                const objective = [];
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        objective.push({ name: `x${c}_${d}`, coef: costs[c][d] });
                    }
                }

                // Build constraints
                const subjectTo = [];

                // Assignment constraints
                for (let c = 0; c < numCustomers; c++) {
                    const vars = [];
                    for (let d = 0; d < numDCs; d++) {
                        vars.push({ name: `x${c}_${d}`, coef: 1 });
                    }
                    subjectTo.push({
                        name: `assign${c}`,
                        vars: vars,
                        bnds: { type: glpk.GLP_FX, lb: 1, ub: 1 }
                    });
                }

                // Linking constraints
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        subjectTo.push({
                            name: `link${c}_${d}`,
                            vars: [
                                { name: `x${c}_${d}`, coef: 1 },
                                { name: `y${d}`, coef: -1 }
                            ],
                            bnds: { type: glpk.GLP_UP, lb: 0, ub: 0 }
                        });
                    }
                }

                // Binary variables list
                const binaries = [];
                for (let d = 0; d < numDCs; d++) {
                    binaries.push(`y${d}`);
                }
                for (let c = 0; c < numCustomers; c++) {
                    for (let d = 0; d < numDCs; d++) {
                        binaries.push(`x${c}_${d}`);
                    }
                }

                const model = {
                    name: 'FacilityLocation',
                    objective: {
                        direction: glpk.GLP_MIN,
                        name: 'cost',
                        vars: objective
                    },
                    subjectTo: subjectTo,
                    binaries: binaries
                };

                console.log('Solving with GLPK...');
                const result = await glpk.solve(model, { msglev: glpk.GLP_MSG_OFF });
                console.log('GLPK result:', result);

                if (result.result.status === glpk.GLP_OPT) {
                    // Extract which DCs are open
                    for (let d = 0; d < numDCs; d++) {
                        const val = result.result.vars[`y${d}`] || 0;
                        targetDCs[d].active = val > 0.5;
                    }
                    assignCustomersToScenario(targetDemands, targetDCs);
                    return { success: true, objective: result.result.z };
                } else {
                    throw new Error('GLPK status: ' + result.result.status);
                }
            } catch (e) {
                console.error('GLPK failed, using greedy fallback:', e);
                console.log('Using greedy optimization as fallback...');
                // Fallback to greedy
                const params = { firstMileRate, lastMileRate, storageRate, dio };
                optimizeGreedy(targetDCs, targetDemands, params);
                return { success: true, fallback: true, message: 'Used greedy fallback: ' + e.message };
            }
        }

        // Unified optimization function that uses selected solver
        async function runOptimization(solver = 'heuristic') {
            const startTime = performance.now();
            let result;

            try {
                if (solver === 'heuristic') {
                    optimize();
                    result = { success: true };
                } else if (solver === 'highs') {
                    result = await optimizeWithHiGHS();
                } else if (solver === 'glpk') {
                    result = await optimizeWithGLPK();
                }
            } catch (e) {
                console.error('Optimization error:', e);
                alert('Optimization failed: ' + e.message);
                result = { success: false };
            }

            const endTime = performance.now();
            const solveTime = Math.round(endTime - startTime);

            return { ...result, solveTime, solver };
        }

        // Update results
        let comparisonScenario = null;

        // Helper function to generate metrics HTML
        function generateMetricsHTML(dcs, demands, scenarioName) {
            // Calculate costs for this scenario
            const activeDCs = dcs.filter(dc => dc.active);
            let totalTransport = 0;
            let totalStorage = 0;
            const firstMileRate = parseFloat(document.getElementById('first-mile-rate').value) / 1000;
            const lastMileRate = parseFloat(document.getElementById('last-mile-rate').value) / 1000;
            const storageRate = parseFloat(document.getElementById('storage-rate').value);
            const dio = parseInt(document.getElementById('dio').value);

            // First mile
            activeDCs.forEach(dc => {
                const dist = distance(factory, dc);
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                totalTransport += dist * throughput * firstMileRate * 12;
            });

            // Last mile & storage
            demands.forEach(point => {
                if (point.assignedDC || point.assignedDCId) {
                    totalTransport += point.distance * point.demand * lastMileRate * 12;
                }
            });

            activeDCs.forEach(dc => {
                const throughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                totalStorage += throughput * (dio / 365) * storageRate * 12;
            });

            const costs = {
                total: totalTransport + totalStorage,
                transport: totalTransport,
                storage: totalStorage,
                activeDCs: activeDCs.length
            };

            // Calculate total demand (monthly)
            const totalDemand = demands.reduce((sum, p) => sum + p.demand, 0);

            // FMCG Product Structure:
            // 1 pallet = 60 cartons √ó 50 pieces = 3,000 pieces
            // NSV per piece = $0.10
            // NSV per pallet = 3,000 √ó $0.10 = $300
            const nsvPerPallet = 300;
            // NSV is annual (monthly demand √ó 12 months)
            const nsv = totalDemand * 12 * nsvPerPallet;
            const costPerNSV = costs.total / nsv;

            // Calculate unit cost to serve
            const unitCostToServe = costs.total / totalDemand;

            // Calculate lead time as simple average of lead time to all customers (distance / 500 km/day)
            const avgLeadTime = demands.reduce((sum, p) => sum + ((p.distance || 0) / 500), 0) / demands.length;

            // Calculate total stock: sum for each DC of (DIO * annual output quantity)/365
            // Annual output = monthly demand * 12
            let totalStock = 0;
            activeDCs.forEach(dc => {
                const monthlyThroughput = demands.filter(p => p.assignedDC === dc || p.assignedDCId === dc.id).reduce((sum, p) => sum + p.demand, 0);
                const annualThroughput = monthlyThroughput * 12;
                totalStock += (dio * annualThroughput) / 365;
            });

            // Calculate DIO - should equal the input DIO parameter
            const calculatedDIO = dio;

            // Calculate IOC: average inventory value * WACC (10%)
            // Average inventory value = total stock (pallets) * NSV per pallet
            const avgInventoryValue = totalStock * nsvPerPallet;
            const ioc = avgInventoryValue * 0.10;

            return `
                <div class="metric-card">
                    <div class="metric-label">Number DCs</div>
                    <div class="metric-sublabel">-</div>
                    <div class="metric-value">${costs.activeDCs}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost per NSV</div>
                    <div class="metric-sublabel">Ratio</div>
                    <div class="metric-value">${(costPerNSV * 100).toFixed(2)}%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales Value</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(nsv / 1000000).toLocaleString(undefined, {maximumFractionDigits: 0})}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Net Sales</div>
                    <div class="metric-sublabel">Volume</div>
                    <div class="metric-value">${Math.round(totalDemand / 1000)}</div>
                    <div class="metric-sublabel" style="margin-top:5px">(k Pallets)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Cost-to-Serve</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(costs.total / 1000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Unit Cost-to-</div>
                    <div class="metric-sublabel">Serve</div>
                    <div class="metric-value">${Math.round(unitCostToServe).toLocaleString()}</div>
                    <div class="metric-sublabel" style="margin-top:5px">(USD/Pallet)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">IOC</div>
                    <div class="metric-sublabel">(M USD)</div>
                    <div class="metric-value">${(ioc / 1000000).toFixed(1)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">DIO</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${calculatedDIO.toFixed(0)}</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Lead Time</div>
                    <div class="metric-sublabel">(days)</div>
                    <div class="metric-value">${avgLeadTime.toFixed(2)}</div>
                </div>
            `;
        }

        function updateResults() {
            const costs = calculateCosts();

            // Update scenario 1
            document.getElementById('scenario-label-1').textContent = scenario1.name;
            document.getElementById('metrics-grid-1').innerHTML = generateMetricsHTML(
                scenario1.dcLocations,
                scenario1.demandPoints,
                scenario1.name
            );

            // Update scenario 2 if exists
            if (scenario2) {
                document.getElementById('scenario-2-section').style.display = 'block';
                document.getElementById('map-container-analytics-2').style.display = 'block';
                document.getElementById('map-comparison-container').classList.add('two-scenarios');
                document.getElementById('scenario-label-2').textContent = scenario2.name;
                document.getElementById('metrics-grid-2').innerHTML = generateMetricsHTML(
                    scenario2.dcLocations,
                    scenario2.demandPoints,
                    scenario2.name
                );

                // Resize canvases after making them visible
                setTimeout(() => {
                    resizeCanvas(canvasAnalytics2);
                    // Force redraw of both maps
                    drawMapOnCanvas(ctxAnalytics1, canvasAnalytics1, scenario1.dcLocations, scenario1.demandPoints);
                    drawMapOnCanvas(ctxAnalytics2, canvasAnalytics2, scenario2.dcLocations, scenario2.demandPoints);
                }, 50);
            } else {
                document.getElementById('scenario-2-section').style.display = 'none';
                document.getElementById('map-container-analytics-2').style.display = 'none';
                document.getElementById('map-comparison-container').classList.remove('two-scenarios');
                // Clear the second canvas
                const rect = canvasAnalytics2.getBoundingClientRect();
                ctxAnalytics2.clearRect(0, 0, rect.width, 700);
            }

            // Update charts
            updateCharts(costs);
        }

        // Draw charts
        function updateCharts(costs) {
            // Sample data for waterfall chart effect
            const firstMileCost = costs.transport * 0.52; // Estimate
            const storageCost = costs.storage;
            const lastMileCost = costs.transport * 0.48;

            // Absolute chart
            const absoluteCanvas = document.getElementById('absolute-chart');
            const absCtx = absoluteCanvas.getContext('2d');
            absCtx.clearRect(0, 0, absoluteCanvas.width, absoluteCanvas.height);

            // Draw bars for absolute cost
            const maxCost = costs.total;
            const barWidth = 80;
            const spacing = 50;
            const chartHeight = 250;
            const baseY = 270;

            // First mile
            const fm_height = (firstMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50, baseY - fm_height, barWidth, fm_height);
            absCtx.fillStyle = '#2D3748';
            absCtx.font = '14px Arial';
            absCtx.textAlign = 'center';
            absCtx.fillText(Math.round(firstMileCost / 1000) + 'M', 90, baseY - fm_height - 5);

            // Storage (stacked on first mile)
            const st_height = (storageCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + barWidth + spacing, baseY - fm_height - st_height, barWidth, fm_height + st_height);
            absCtx.fillText(Math.round((firstMileCost + storageCost) / 1000) + 'M', 90 + barWidth + spacing, baseY - fm_height - st_height - 5);

            // Last mile (stacked on storage)
            const lm_height = (lastMileCost / maxCost) * chartHeight;
            absCtx.fillStyle = '#385D7F';
            absCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight, barWidth, costs.total / maxCost * chartHeight);
            absCtx.fillText(Math.round(costs.total / 1000) + 'M', 90 + (barWidth + spacing) * 2, baseY - costs.total / maxCost * chartHeight - 5);

            // Relative chart (cost per pallet)
            const relativeCanvas = document.getElementById('relative-chart');
            const relCtx = relativeCanvas.getContext('2d');
            relCtx.clearRect(0, 0, relativeCanvas.width, relativeCanvas.height);

            const totalDemand = demandPoints.reduce((sum, p) => sum + p.demand, 0);
            const fm_per_pallet = firstMileCost / totalDemand;
            const st_per_pallet = storageCost / totalDemand;
            const lm_per_pallet = lastMileCost / totalDemand;
            const total_per_pallet = costs.total / totalDemand;

            const maxPerPallet = total_per_pallet;

            // First mile
            const fm_height_rel = (fm_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50, baseY - fm_height_rel, barWidth, fm_height_rel);
            relCtx.fillStyle = '#2D3748';
            relCtx.font = '14px Arial';
            relCtx.textAlign = 'center';
            relCtx.fillText(Math.round(fm_per_pallet), 90, baseY - fm_height_rel - 5);

            // Storage (stacked)
            const st_height_rel = (st_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + barWidth + spacing, baseY - fm_height_rel - st_height_rel, barWidth, fm_height_rel + st_height_rel);
            relCtx.fillText(Math.round(fm_per_pallet + st_per_pallet), 90 + barWidth + spacing, baseY - fm_height_rel - st_height_rel - 5);

            // Last mile (stacked)
            const total_height_rel = (total_per_pallet / maxPerPallet) * chartHeight;
            relCtx.fillStyle = '#385D7F';
            relCtx.fillRect(50 + (barWidth + spacing) * 2, baseY - total_height_rel, barWidth, total_height_rel);
            relCtx.fillText(Math.round(total_per_pallet), 90 + (barWidth + spacing) * 2, baseY - total_height_rel - 5);
        }

        // Initialize
        generateDemandPoints();
        assignCustomers();

        // Initialize scenario 1 with current state
        scenario1.demandPoints = JSON.parse(JSON.stringify(demandPoints));
        scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
        // Re-assign customers to restore object references
        assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);

        drawMap();
        updateResults();

        // Load saved scenarios into all dropdowns
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith('dno-scenario-')) {
                const name = key.replace('dno-scenario-', '');
                ['scenario-select-1', 'scenario-select-2', 'scenario-select-3'].forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    }
                });
            }
        }

        // DC list
        const dcList = document.getElementById('dc-list');
        dcLocations.forEach(dc => {
            const div = document.createElement('div');
            div.className = 'dc-checkbox';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = dc.id;
            checkbox.checked = dc.active;
            checkbox.addEventListener('change', () => {
                dc.active = checkbox.checked;
                assignCustomers();
                drawMap();
                updateResults();
            });
            const label = document.createElement('label');
            label.htmlFor = dc.id;
            label.textContent = dc.name;
            div.appendChild(checkbox);
            div.appendChild(label);
            dcList.appendChild(div);
        });

        // Parameters
        ['first-mile-rate', 'last-mile-rate', 'storage-rate', 'dio'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                updateResults();
            });
        });

        // Solver dropdown split button handling
        let selectedSolver = 'heuristic';
        const solverNames = {
            'heuristic': 'Heuristic',
            'highs': 'HiGHS',
            'glpk': 'GLPK'
        };

        const dropdownMenu = document.getElementById('solver-dropdown-menu');
        const dropdownBtn = document.getElementById('run-new-optimization-dropdown');

        // Toggle dropdown menu
        dropdownBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdownMenu.style.display = dropdownMenu.style.display === 'none' ? 'block' : 'none';
        });

        // Close dropdown when clicking elsewhere
        document.addEventListener('click', () => {
            dropdownMenu.style.display = 'none';
        });

        // Handle solver selection from dropdown
        document.querySelectorAll('.solver-option').forEach(option => {
            option.addEventListener('mouseenter', () => {
                option.style.backgroundColor = '#f0f4f8';
            });
            option.addEventListener('mouseleave', () => {
                option.style.backgroundColor = 'white';
            });
            option.addEventListener('click', (e) => {
                e.stopPropagation();
                selectedSolver = option.dataset.solver;
                document.getElementById('new-scenario-solver-label').textContent = '(Using: ' + solverNames[selectedSolver] + ')';
                dropdownMenu.style.display = 'none';
            });
        });

        // Run optimization
        document.getElementById('run-optimization').addEventListener('click', () => {
            optimize();
            // Update checkboxes
            dcLocations.forEach(dc => {
                document.getElementById(dc.id).checked = dc.active;
            });
            // Update scenario 1 with optimized state
            scenario1.dcLocations = JSON.parse(JSON.stringify(dcLocations));
            scenario1.demandPoints = JSON.parse(JSON.stringify(demandPoints));
            assignCustomersToScenario(scenario1.demandPoints, scenario1.dcLocations);

            drawMap();
            updateResults();
        });

        // Save scenario
        document.getElementById('save-scenario').addEventListener('click', () => {
            const name = prompt('Enter scenario name:');
            if (name) {
                const scenario = {
                    name,
                    dcActive: dcLocations.map(dc => dc.active),
                    parameters: {
                        firstMileRate: document.getElementById('first-mile-rate').value,
                        lastMileRate: document.getElementById('last-mile-rate').value,
                        storageRate: document.getElementById('storage-rate').value,
                        dio: document.getElementById('dio').value
                    },
                    demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));
                alert('Scenario saved!');
            }
        });

        // Helper function to load a scenario
        function loadScenario(scenarioValue, scenarioName) {
            const tempDcLocations = JSON.parse(JSON.stringify(dcLocations));
            const tempDemandPoints = JSON.parse(JSON.stringify(demandPoints));

            if (scenarioValue === 'baseline') {
                tempDcLocations.forEach((dc, i) => dc.active = [0,2,4,6,8].includes(i));
            } else {
                // Load saved scenario
                const savedScenario = JSON.parse(localStorage.getItem('dno-scenario-' + scenarioValue));
                if (savedScenario) {
                    tempDcLocations.forEach((dc, i) => dc.active = savedScenario.dcActive[i]);
                    savedScenario.demands.forEach((d, i) => {
                        if (tempDemandPoints[i]) tempDemandPoints[i].demand = d.demand;
                    });
                }
            }

            // Assign customers for temp data using the scenario-specific function
            assignCustomersToScenario(tempDemandPoints, tempDcLocations);

            return {
                demandPoints: tempDemandPoints,
                dcLocations: tempDcLocations,
                name: scenarioName
            };
        }

        // Scenario select handlers
        const select1 = document.getElementById('scenario-select-1');
        const select2 = document.getElementById('scenario-select-2');

        select1.addEventListener('change', (e) => {
            if (e.target.value === '') return;
            const scenarioName = select1.options[select1.selectedIndex].text;
            scenario1 = loadScenario(e.target.value, scenarioName);

            // Update current working state
            dcLocations = JSON.parse(JSON.stringify(scenario1.dcLocations));
            demandPoints = JSON.parse(JSON.stringify(scenario1.demandPoints));

            // Update DC checkboxes
            dcLocations.forEach(dc => {
                const checkbox = document.getElementById(dc.id);
                if (checkbox) checkbox.checked = dc.active;
            });

            drawMap();
            updateResults();
        });

        select2.addEventListener('change', (e) => {
            if (e.target.value === '') {
                scenario2 = null;
            } else {
                const scenarioName = select2.options[select2.selectedIndex].text;
                scenario2 = loadScenario(e.target.value, scenarioName);
            }

            drawMap();
            updateResults();
        });

        // ===== NEW SCENARIO TAB IMPLEMENTATION =====

        // New working state for scenario creator
        let newScenarioDCs = JSON.parse(JSON.stringify(dcLocations));
        let newScenarioDemands = JSON.parse(JSON.stringify(demandPoints));
        let scenarioFeedCounter = 0;

        // Initialize New Scenario tab canvases
        const referenceMapCanvas = document.getElementById('reference-map');
        const referenceMapCtx = referenceMapCanvas.getContext('2d');
        const newScenarioMapCanvas = document.getElementById('new-scenario-map');
        const newScenarioMapCtx = newScenarioMapCanvas.getContext('2d');

        // Initialize DC list for new scenario creator
        const newDCList = document.getElementById('new-dc-list');

        // Function to reinitialize DC checkboxes with current newScenarioDCs array
        function reinitializeNewScenarioCheckboxes() {
            // Clear existing checkboxes
            newDCList.innerHTML = '';

            // Create new checkboxes linked to current newScenarioDCs
            newScenarioDCs.forEach(dc => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; margin-bottom: 8px; font-size: 13px;';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = 'new-' + dc.id;
                checkbox.checked = dc.active;
                checkbox.style.marginRight = '8px';
                checkbox.addEventListener('change', () => {
                    dc.active = checkbox.checked;
                    assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
                    resizeCanvas(newScenarioMapCanvas);
                    drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);
                });
                const label = document.createElement('label');
                label.htmlFor = 'new-' + dc.id;
                label.textContent = dc.name;
                div.appendChild(checkbox);
                div.appendChild(label);
                newDCList.appendChild(div);
            });
        }

        // Initial checkbox setup
        reinitializeNewScenarioCheckboxes();

        // Select All button handler
        document.getElementById('select-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = true);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            resizeCanvas(newScenarioMapCanvas);
            drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);
        });

        // Clear All button handler
        document.getElementById('clear-all-dcs').addEventListener('click', () => {
            newScenarioDCs.forEach(dc => dc.active = false);
            reinitializeNewScenarioCheckboxes();
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            resizeCanvas(newScenarioMapCanvas);
            drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);
        });

        // Initial assignment and draw for new scenario
        assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
        resizeCanvas(newScenarioMapCanvas);
        drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);

        // Reference Scenario select handler
        document.getElementById('reference-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                document.getElementById('reference-scenario-display').style.display = 'none';
                return;
            }

            const refScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Show display
            document.getElementById('reference-scenario-display').style.display = 'block';

            // Generate metrics
            document.getElementById('reference-metrics').innerHTML = generateMetricsHTML(
                refScenario.dcLocations,
                refScenario.demandPoints,
                refScenario.name
            );

            // Draw map
            resizeCanvas(referenceMapCanvas);
            drawMapOnCanvas(referenceMapCtx, referenceMapCanvas, refScenario.dcLocations, refScenario.demandPoints);

            // Display parameters
            const params = document.getElementById('reference-parameters');
            params.innerHTML = `
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>First Mile Rate:</strong><br>$${document.getElementById('first-mile-rate').value}/pallet/1,000km
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Last Mile Rate:</strong><br>$${document.getElementById('last-mile-rate').value}/pallet/1,000km
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>Storage Rate:</strong><br>$${document.getElementById('storage-rate').value}/pallet/month
                </div>
                <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;">
                    <strong>DIO:</strong><br>${document.getElementById('dio').value} days
                </div>
            `;
        });

        // Store preloaded scenario state for reset functionality
        let preloadedState = null;

        // Preload scenario handler
        document.getElementById('preload-scenario-select').addEventListener('change', (e) => {
            if (e.target.value === '') {
                preloadedState = null;
                document.getElementById('reset-to-preloaded').style.display = 'none';
                return;
            }

            const preloadScenario = loadScenario(e.target.value, e.target.options[e.target.selectedIndex].text);

            // Update DCs
            newScenarioDCs = JSON.parse(JSON.stringify(preloadScenario.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadScenario.demandPoints));

            // Store preloaded state for reset
            preloadedState = {
                dcLocations: JSON.parse(JSON.stringify(preloadScenario.dcLocations)),
                demandPoints: JSON.parse(JSON.stringify(preloadScenario.demandPoints)),
                firstMileRate: document.getElementById('first-mile-rate').value,
                lastMileRate: document.getElementById('last-mile-rate').value,
                storageRate: document.getElementById('storage-rate').value,
                dio: document.getElementById('dio').value
            };

            // Reinitialize checkboxes with new DC array
            reinitializeNewScenarioCheckboxes();

            // Update parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;

            // Show reset button
            document.getElementById('reset-to-preloaded').style.display = 'block';

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            resizeCanvas(newScenarioMapCanvas);
            drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);
        });

        // Reset to preloaded handler
        document.getElementById('reset-to-preloaded').addEventListener('click', () => {
            if (!preloadedState) return;

            // Restore preloaded state
            newScenarioDCs = JSON.parse(JSON.stringify(preloadedState.dcLocations));
            newScenarioDemands = JSON.parse(JSON.stringify(preloadedState.demandPoints));

            // Reinitialize checkboxes with restored DC array
            reinitializeNewScenarioCheckboxes();

            // Restore parameters
            document.getElementById('new-first-mile-rate').value = preloadedState.firstMileRate;
            document.getElementById('new-last-mile-rate').value = preloadedState.lastMileRate;
            document.getElementById('new-storage-rate').value = preloadedState.storageRate;
            document.getElementById('new-dio').value = preloadedState.dio;

            // Redraw
            assignCustomersToScenario(newScenarioDemands, newScenarioDCs);
            resizeCanvas(newScenarioMapCanvas);
            drawMapOnCanvas(newScenarioMapCtx, newScenarioMapCanvas, newScenarioDCs, newScenarioDemands);
        });

        // Run Optimization handler
        document.getElementById('run-new-optimization').addEventListener('click', async () => {
            const btn = document.getElementById('run-new-optimization');
            const dropdownBtn = document.getElementById('run-new-optimization-dropdown');
            btn.disabled = true;
            dropdownBtn.disabled = true;
            btn.textContent = '‚è≥ Optimizing...';

            try {
                scenarioFeedCounter++;
                const solver = selectedSolver;
                const scenarioName = 'Run_' + scenarioFeedCounter + '_' + solverNames[solver] + '_' + new Date().toLocaleTimeString();

                // Get parameters
                const firstMile = parseFloat(document.getElementById('new-first-mile-rate').value);
                const lastMile = parseFloat(document.getElementById('new-last-mile-rate').value);
                const storage = parseFloat(document.getElementById('new-storage-rate').value);
                const dio = parseInt(document.getElementById('new-dio').value);

                // Clone current state
                const runDCs = JSON.parse(JSON.stringify(newScenarioDCs));
                const runDemands = JSON.parse(JSON.stringify(demandPoints));

                const startTime = performance.now();

                if (solver === 'heuristic') {
                    // Run heuristic optimization on runDCs
                    function calculateScenarioCost(dcs, demands) {
                        const activeDCs = dcs.filter(dc => dc.active);
                        let total = 0;
                        const fm = firstMile / 1000;
                        const lm = lastMile / 1000;

                        activeDCs.forEach(dc => {
                            const dist = distance(factory, dc);
                            const throughput = demands.filter(p => p.assignedDC === dc).reduce((sum, p) => sum + p.demand, 0);
                            total += dist * throughput * fm * 12;
                            total += throughput * (dio / 365) * storage * 12;
                        });
                        demands.forEach(point => {
                            if (point.assignedDC) {
                                total += point.distance * point.demand * lm * 12;
                            }
                        });
                        return total;
                    }

                    // Start with all DCs active that are within range
                    runDCs.forEach(dc => {
                        dc.active = distance(factory, dc) <= 4000;
                    });
                    assignCustomersToScenario(runDemands, runDCs);
                    let currentCost = calculateScenarioCost(runDCs, runDemands);

                    let improved = true;
                    let iterations = 0;
                    while (improved && iterations < 10) {
                        improved = false;
                        iterations++;
                        let bestSavings = 0;
                        let bestDCToClose = -1;

                        for (let i = 0; i < runDCs.length; i++) {
                            if (!runDCs[i].active) continue;
                            runDCs[i].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            const allAssigned = runDemands.every(p => p.assignedDC !== null);
                            if (allAssigned) {
                                const newCost = calculateScenarioCost(runDCs, runDemands);
                                const savings = currentCost - newCost;
                                if (savings > bestSavings) {
                                    bestSavings = savings;
                                    bestDCToClose = i;
                                }
                            }
                            runDCs[i].active = true;
                        }

                        if (bestDCToClose >= 0) {
                            runDCs[bestDCToClose].active = false;
                            assignCustomersToScenario(runDemands, runDCs);
                            currentCost = calculateScenarioCost(runDCs, runDemands);
                            improved = true;
                        }
                    }
                    assignCustomersToScenario(runDemands, runDCs);

                } else if (solver === 'highs' || solver === 'glpk') {
                    // Use MIP solver with the target arrays directly
                    try {
                        if (solver === 'highs') {
                            await optimizeWithHiGHS(runDCs, runDemands);
                        } else {
                            await optimizeWithGLPK(runDCs, runDemands);
                        }
                    } catch (e) {
                        console.error('Solver error in New Scenario:', e);
                    }
                    // Ensure customers are assigned after optimization
                    assignCustomersToScenario(runDemands, runDCs);
                }

                const endTime = performance.now();
                const solveTime = Math.round(endTime - startTime);

                // Update label with solve time
                document.getElementById('new-scenario-solver-label').textContent = `(${solverNames[solver]}: ${solveTime}ms)`;

                // Add to scenario feed
                addScenarioToFeed(scenarioName, runDCs, runDemands, {firstMile, lastMile, storage, dio, solver: solverNames[solver], solveTime});

            } finally {
                btn.disabled = false;
                dropdownBtn.disabled = false;
                btn.textContent = 'Run Optimization';
            }
        });

        // Save Scenario handler
        document.getElementById('save-new-scenario').addEventListener('click', () => {
            const name = prompt('Enter scenario name:');
            if (!name) return;

            const scenario = {
                name,
                dcActive: newScenarioDCs.map(dc => dc.active),
                parameters: {
                    firstMileRate: document.getElementById('new-first-mile-rate').value,
                    lastMileRate: document.getElementById('new-last-mile-rate').value,
                    storageRate: document.getElementById('new-storage-rate').value,
                    dio: document.getElementById('new-dio').value
                },
                demands: demandPoints.map(p => ({cluster: p.cluster, demand: p.demand}))
            };
            localStorage.setItem('dno-scenario-' + name, JSON.stringify(scenario));

            // Add to all dropdowns
            const option1 = document.createElement('option');
            option1.value = name;
            option1.textContent = name;
            document.getElementById('scenario-select-1').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-2').appendChild(option1.cloneNode(true));
            document.getElementById('scenario-select-3').appendChild(option1.cloneNode(true));
            document.getElementById('reference-scenario-select').appendChild(option1.cloneNode(true));
            document.getElementById('preload-scenario-select').appendChild(option1);

            alert('Scenario saved!');
        });

        // Function to add scenario to feed
        function addScenarioToFeed(name, dcs, demands, params) {
            const feed = document.getElementById('scenario-feed');
            const scenarioId = 'scenario-' + Date.now();

            const scenarioBlock = document.createElement('div');
            scenarioBlock.id = scenarioId;
            scenarioBlock.style.cssText = 'background: white; padding: 20px 25px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 20px;';

            const solverInfo = params.solver ? `<span style="margin-left: 10px; padding: 4px 10px; background: var(--cel-blue); color: white; border-radius: 12px; font-size: 12px;">${params.solver}${params.solveTime ? ' - ' + params.solveTime + 'ms' : ''}</span>` : '';

            scenarioBlock.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center;">
                        <h3 style="font-size: 18px; font-weight: 600; color: var(--text-dark); margin: 0;">${name}</h3>
                        ${solverInfo}
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="toggle-btn" style="padding: 6px 14px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Collapse</button>
                        <button class="hide-btn" style="padding: 6px 14px; background: #ffc107; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Hide</button>
                        <button class="save-btn" style="padding: 6px 14px; background: var(--cel-green); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Save</button>
                        <button class="delete-btn" style="padding: 6px 14px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">Delete</button>
                    </div>
                </div>
                <div class="metrics-grid scenario-metrics" style="margin-bottom: 0;"></div>
                <div class="scenario-details" style="margin-top: 15px;">
                    <div>
                        <canvas class="scenario-canvas" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 8px;"></canvas>
                    </div>
                    <div style="margin-top: 20px; display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px;">
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>First Mile Rate:</strong><br>$${params.firstMile}/pallet/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Last Mile Rate:</strong><br>$${params.lastMile}/pallet/1,000km</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>Storage Rate:</strong><br>$${params.storage}/pallet/month</div>
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 4px;"><strong>DIO:</strong><br>${params.dio} days</div>
                        <div style="padding: 15px; background: #e8f4fd; border-radius: 4px;"><strong>Solver:</strong><br>${params.solver || 'Heuristic'}${params.solveTime ? ' (' + params.solveTime + 'ms)' : ''}</div>
                    </div>
                </div>
            `;

            feed.appendChild(scenarioBlock);

            // Generate metrics
            const metricsGrid = scenarioBlock.querySelector('.scenario-metrics');
            metricsGrid.innerHTML = generateMetricsHTML(dcs, demands, name);

            // Draw map
            const canvas = scenarioBlock.querySelector('.scenario-canvas');
            const ctx = canvas.getContext('2d');
            resizeCanvas(canvas);
            drawMapOnCanvas(ctx, canvas, dcs, demands);

            // Add event listeners
            scenarioBlock.querySelector('.toggle-btn').addEventListener('click', function() {
                const details = scenarioBlock.querySelector('.scenario-details');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    this.textContent = 'Collapse';
                } else {
                    details.style.display = 'none';
                    this.textContent = 'Expand';
                }
            });

            scenarioBlock.querySelector('.hide-btn').addEventListener('click', () => {
                scenarioBlock.style.display = 'none';
            });

            scenarioBlock.querySelector('.save-btn').addEventListener('click', () => {
                const saveName = prompt('Enter scenario name:', name);
                if (!saveName) return;

                const scenario = {
                    name: saveName,
                    dcActive: dcs.map(dc => dc.active),
                    parameters: {
                        firstMileRate: params.firstMile,
                        lastMileRate: params.lastMile,
                        storageRate: params.storage,
                        dio: params.dio
                    },
                    demands: demands.map(p => ({cluster: p.cluster, demand: p.demand}))
                };
                localStorage.setItem('dno-scenario-' + saveName, JSON.stringify(scenario));

                // Update the scenario block heading to reflect the saved name
                const heading = scenarioBlock.querySelector('h3');
                if (heading) {
                    heading.textContent = saveName;
                }

                // Update the internal name variable for future operations
                name = saveName;

                // Add to all dropdowns if not already there
                const existingOption = document.querySelector(`option[value="${saveName}"]`);
                if (!existingOption) {
                    const option = document.createElement('option');
                    option.value = saveName;
                    option.textContent = saveName;
                    document.getElementById('scenario-select-1').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-2').appendChild(option.cloneNode(true));
                    document.getElementById('scenario-select-3').appendChild(option.cloneNode(true));
                    document.getElementById('reference-scenario-select').appendChild(option.cloneNode(true));
                    document.getElementById('preload-scenario-select').appendChild(option);
                }

                alert('Scenario saved as "' + saveName + '"!');
            });

            scenarioBlock.querySelector('.delete-btn').addEventListener('click', () => {
                if (confirm('Are you sure you want to delete this scenario? This cannot be undone.')) {
                    scenarioBlock.remove();
                    // Remove from localStorage if it was saved
                    localStorage.removeItem('dno-scenario-' + name);
                    // Remove from dropdowns
                    document.querySelectorAll('option').forEach(opt => {
                        if (opt.value === name) opt.remove();
                    });
                }
            });
        }

        // Function to restore saved scenarios from localStorage on page load
        function restoreSavedScenarios() {
            // Find all saved scenarios in localStorage
            const savedScenarios = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('dno-scenario-')) {
                    const scenarioName = key.replace('dno-scenario-', '');
                    const scenarioData = JSON.parse(localStorage.getItem(key));
                    savedScenarios.push({ name: scenarioName, data: scenarioData });
                }
            }

            // Restore each scenario to the feed
            savedScenarios.forEach(({ name, data }) => {
                // Reconstruct DC locations with active states
                const dcs = JSON.parse(JSON.stringify(dcLocations));
                dcs.forEach((dc, index) => {
                    if (data.dcActive && data.dcActive[index] !== undefined) {
                        dc.active = data.dcActive[index];
                    }
                });

                // Use current demand points (they're generated with a fixed seed)
                const demands = JSON.parse(JSON.stringify(demandPoints));

                // Assign customers to DCs
                assignCustomersToScenario(demands, dcs);

                // Extract parameters
                const params = {
                    firstMile: parseFloat(data.parameters.firstMileRate),
                    lastMile: parseFloat(data.parameters.lastMileRate),
                    storage: parseFloat(data.parameters.storageRate),
                    dio: parseInt(data.parameters.dio)
                };

                // Add to scenario feed
                addScenarioToFeed(name, dcs, demands, params);
            });
        }

        // Restore saved scenarios when page loads
        restoreSavedScenarios();
    </script>
</body>
</html>